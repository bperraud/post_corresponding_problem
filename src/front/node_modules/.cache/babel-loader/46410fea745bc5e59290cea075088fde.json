{"ast":null,"code":"/*\n * Copyright (c) 2020, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst ResultsetStub = require('../../../Stubs/mysqlx_resultset_pb');\n\nconst ServerMessagesStub = require('../../../Stubs/mysqlx_pb').ServerMessages;\n\nconst bytes = require('../../ScalarValues/bytes');\n\nconst errors = require('../../../../constants/errors');\n\nconst jspb = require('google-protobuf');\n\nconst util = require('util');\n\nconst wraps = require('../../Traits/Wraps');\n/**\n * Known max values for some specific data types.\n * @private\n * @readonly\n * @name MAX_DATATYPE_SIZE\n * @enum {number}\n */\n\n\nconst MAX_DATATYPE_SIZE = {\n  DATETIME: 8,\n  TIME: 5\n};\n/**\n * Decode a column value encoded using X Protocol BIT.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @returns {string} A string containing the decimal value (to avoid loosing precision).\n */\n\nfunction decodeBitSequence(decoder) {\n  return decoder.readUnsignedVarint64String();\n}\n/**\n * Decode a column value encoded using X Protocol DATETIME or TIMESTAMP.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {Object} [options] - object containing the column metadata\n * @returns {Date|number} A JavaScript date (DATETIME) or number (TIMESTAMP).\n */\n\n\nfunction decodeDatetime(decoder, options) {\n  options = Object.assign({\n    maxSize: MAX_DATATYPE_SIZE.DATETIME\n  }, options);\n  return formatDatetime(decodeTemporalValue(decoder, options), options);\n}\n/**\n * Decode a column value encoded using X Protocol DECIMAL.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number|string} A JavaScript number or string (to avoid loosing precision) containing the decimal value.\n */\n\n\nfunction decodeDecimal(decoder, options) {\n  const data = bytes(decoder.readBytes(options.length)).toBuffer(); // scale is always a positive value, so we should assume its an unsigned int\n\n  const scale = data.readUInt8(0); // read the remaining sequence (in hex to make it easier to operate on 4 bit segments)\n\n  const remaining = data.slice(1).toString('hex');\n  let lastFourBits = remaining.charAt(remaining.length - 1).toLowerCase();\n  let bcd;\n\n  if (lastFourBits !== '0') {\n    // the last character should be the sign\n    bcd = remaining.slice(0, remaining.length - 1);\n  } else {\n    // the last character should be the extra 4 bit zeroed padding\n    bcd = remaining.slice(0, remaining.length - 2);\n    lastFourBits = remaining.charAt(remaining.length - 2).toLowerCase();\n  }\n\n  const sign = lastFourBits === 'c' ? '+' : '-';\n  const int = bcd.slice(0, bcd.length - scale);\n  const decimal = bcd.slice(bcd.length - scale);\n\n  if (!decimal.length) {\n    return formatSafeNumber(`${sign}${int}`);\n  }\n\n  return formatSafeNumber(`${sign}${int}.${decimal}`);\n}\n/**\n * Decode a column value encoded using X Protocol DOUBLE.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number} A JavaScript number.\n */\n\n\nfunction decodeDouble(decoder, options) {\n  return formatDecimal(decoder.readDouble(), options);\n}\n/**\n * Decode a column value encoded using X Protocol FLOAT.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number} A JavaScript number.\n */\n\n\nfunction decodeFloat(decoder, options) {\n  return formatDecimal(decoder.readFloat(), options);\n}\n/**\n* Decode a column value encoded using X Protocol BYTES.\n* @private\n* @param {jspb.BinaryDecoder} decoder\n* @param {options} [options] - object containing the column metadata\n* @returns {string|Buffer} A JavaScript string (textual data) or a Node.js Buffer (binary data).\n*/\n\n\nfunction decodeOpaqueByteString(decoder, options) {\n  // XML should be equivalent to plain text.\n  options = Object.assign({}, options);\n\n  if (!options.length) {\n    return null;\n  }\n\n  if (options.column.isBinary()) {\n    // remove the extra '\\0' defined by the protocol\n    const data = bytes(decoder.readBytes(options.length - 1)).toBuffer();\n\n    if (options.column.isFlagged()) {\n      return rightPad(data, options.column.getLength(), '\\0');\n    }\n\n    return data;\n  } // remove the extra '\\0' defined by the protocol\n\n\n  let data = decoder.readString(options.length - 1);\n\n  if (options.column.isFlagged()) {\n    data = rightPad(data, options.column.getLength(), ' ');\n  }\n\n  if (!options.column.isJSON()) {\n    return data;\n  }\n\n  return JSON.parse(data);\n}\n/**\n * Decode a column value encoded using X Protocol SET.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {string[]} A JavaScript array of JavaScript strings.\n */\n\n\nfunction decodeSet(decoder, options) {\n  let group = []; // Sequence format is defined in the mysqlx_resultset.proto definition\n  // [0] - the NULL value\n\n  if (decoder.atEnd()) {\n    return null;\n  }\n\n  const beginning = decoder.getCursor();\n  const firstByte = bytes(decoder.readBytes(1)).toBuffer(); // [1] 0x00 - a set containing a blank string ''\n\n  if (firstByte.toString('hex') === '00') {\n    return group.concat('');\n  } // [1] 0x01 - this would be an invalid value, but is to be treated as the empty set\n\n\n  if (firstByte.toString('hex') === '01' && decoder.atEnd()) {\n    return group;\n  }\n\n  const secondByte = bytes(decoder.readBytes(1)).toBuffer(); // [2] 0x01 0x00 - a set with a single item, which is the '\\0' character\n\n  if (firstByte.toString('hex') === '01' && secondByte.toString('hex') === '00') {\n    return group.concat('\\0');\n  } // We need read the whole sequence so we must restart the cursor (it is\n  // partially consumed by this point).\n\n\n  decoder.setCursor(beginning);\n\n  while (!decoder.atEnd()) {\n    // [8] 0x03 F O O 0x03 B A R - a set with 2 items: FOO,BAR\n    group = group.concat(decoder.readStringWithLength());\n  }\n\n  return group;\n}\n/**\n * Decode a column value encoded using X Protocol SINT.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number|string} A JavaScript number or string (to avoid loosing precision) containing the decimal value.\n */\n\n\nfunction decodeSignedInt(decoder, options) {\n  const beginning = decoder.getCursor(); // let's start by trying to decode the value as a JavaScript number\n\n  const signedInt = decoder.readZigzagVarint64(); // if there is no chance of losing precision, we can proceed\n\n  if (signedInt >= Number.MIN_SAFE_INTEGER && signedInt <= Number.MAX_SAFE_INTEGER) {\n    return signedInt;\n  } // otherwise, we need to go back and decode it as string\n\n\n  decoder.setCursor(beginning);\n  return decoder.readZigzagVarint64String();\n}\n/**\n * Decode a column value encoded using X Protocol TIME.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {string} A JavaScript string containting the time representation.\n */\n\n\nfunction decodeTime(decoder, options) {\n  options = Object.assign({\n    maxSize: MAX_DATATYPE_SIZE.TIME\n  }, options);\n  return formatTime(decodeTemporalValue(decoder, options));\n}\n/**\n * Decode a column value encoded using X Protocol TIME, DATE, DATETIME or TIMESTAMP.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing internal implementation details\n * @returns {number[]} A JavaScript array encoding the temporal representation.\n */\n\n\nfunction decodeTemporalValue(decoder, options) {\n  options = Object.assign({\n    maxSize: 0\n  }, options);\n  const startingPoint = Buffer.alloc(options.maxSize);\n  const value = startingPoint.toJSON().data;\n  let i = 0;\n\n  while (!decoder.atEnd()) {\n    // No precision loss, since the maximum value is 999999 (useconds).\n    value[i++] = decoder.readUnsignedVarint64();\n  }\n\n  return value;\n}\n/**\n * Decode a column value encoded using X Protocol UINT.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number|string} A JavaScript string (when there is overflow or zerofill) or number.\n */\n\n\nfunction decodeUnsignedInt(decoder, options) {\n  const uint = formatSafeNumber(decoder.readUnsignedVarint64String());\n\n  if (!options.column.isFlagged()) {\n    return uint;\n  }\n\n  return leftPad(uint, options.column.getLength(), '0');\n}\n/**\n * Format the output of a JavaScript number to avoid loosing precision.\n * @private\n * @param {string} value - string containing a numeric value\n * @returns {number|string} A JavaScript string (when there is overflow) or number.\n */\n\n\nfunction formatSafeNumber(value) {\n  const num = parseFloat(value);\n\n  if (num < Number.MIN_SAFE_INTEGER || num > Number.MAX_SAFE_INTEGER) {\n    return value;\n  }\n\n  return num;\n}\n/**\n * Format a temporal value encoded as an array.\n * @private\n * @param {number[]} temporal\n * @param {options} [options] - object containing internal implementation details\n * @returns {string} A JavaScript string containing the time representation.\n */\n\n\nfunction formatDatetime(temporal, options) {\n  const year = leftPad(temporal[0], 4, '0');\n  const month = leftPad(temporal[1], 2, '0');\n  const day = leftPad(temporal[2], 2, '0');\n  const timeSlice = temporal.slice(2, temporal.length);\n  const time = formatTime(timeSlice, {\n    signed: false\n  });\n  const date = new Date(`${year}-${month}-${day}T${time}Z`);\n\n  if (options.column.isFlagged()) {\n    // should be a timestamp\n    return date.getTime();\n  }\n\n  return date;\n}\n/**\n * Apply a rounding mask to a decimal value according to the metadata definition.\n * @private\n * @param {number} value - JavaScript number\n * @param {options} [options] - object containing the column metadata\n * @returns {number} The masked JavaScript number.\n */\n\n\nfunction formatDecimal(value, options) {\n  // number of decimal digits\n  const fractionalDigits = options.column.getFractionalDigits() || value.toPrecision().slice(Math.floor(value).toString().length + 1).length;\n  return Math.round(value * Math.pow(10, fractionalDigits)) / Math.pow(10, fractionalDigits);\n}\n/**\n * Format a temporal value encoded as an array.\n * @private\n * @param {number[]} temporal\n * @param {options} [options] - object containing internal implementation details\n * @returns {string} A JavaScript string containing the time representation.\n */\n\n\nfunction formatTime(temporal, options) {\n  options = Object.assign({\n    signed: true\n  }, options);\n  const hour = leftPad(temporal[1], 2, '0');\n  const minutes = leftPad(temporal[2], 2, '0');\n  const seconds = leftPad(temporal[3], 2, '0');\n  const useconds = leftPad(temporal[4], 6, '0');\n  const time = `${hour}:${minutes}:${seconds}.${useconds}`;\n\n  if (!options.signed) {\n    return time;\n  }\n\n  const negate = temporal[0] > 0 ? '-' : '+';\n  return `${negate}${time}`;\n}\n/**\n * Left pad a value with a given length.\n * @private\n * @param {Buffer|number|string} value - value to pad\n * @param {number} [size] - expected output size\n * @param {string} [char] - filler character\n * @returns {string} The left-padded JavaScript string or Node.js Buffer.\n */\n\n\nfunction leftPad(value, size, char) {\n  char = char || ' ';\n\n  if (Buffer.isBuffer(value)) {\n    if (!size || size <= value.length) {\n      return value;\n    }\n\n    const padding = Buffer.alloc(size - value.length);\n    return Buffer.concat([padding, value], padding.length + value.length);\n  }\n\n  const asString = value.toString();\n  const maxSize = value.toString().length;\n\n  if (!size || size <= maxSize) {\n    return asString;\n  }\n\n  return char.repeat(size - maxSize).concat(asString);\n}\n/**\n * Right pad a value with a length.\n * @private\n * @param {Buffer|number|string} value - value to pad\n * @param {number} [size] - expected output size\n * @param {string} [char] - filler character\n * @returns {string} The right-padded JavaScript string or Node.js Buffer.\n */\n\n\nfunction rightPad(value, size, char) {\n  char = char || ' ';\n\n  if (Buffer.isBuffer(value)) {\n    if (!size || size <= value.length) {\n      return value;\n    }\n\n    const padding = Buffer.alloc(size - value.length);\n    return Buffer.concat([value, padding], value.length + padding.length);\n  }\n\n  const asString = value.toString();\n  const maxSize = value.toString().length;\n\n  if (!size || size <= maxSize) {\n    return asString;\n  }\n\n  return asString.concat(char.repeat(size - maxSize));\n}\n/**\n * Decode a column value for each Mysqlx.Resultset.Row.\n * @private\n * @param {Uint8Array} field - Protocol Buffers `bytes` type.\n * @param {Object} [options] - object containing the column metadata\n * @returns {*} - A native JavaScript type.\n */\n\n\nfunction decodeField(field, options) {\n  let data;\n\n  if (!options.column) {\n    throw new Error(errors.MESSAGES.ER_X_CLIENT_NO_COLUMN_METADATA);\n  } // Empty field values match to NULL.\n\n\n  if (!field.length) {\n    return null;\n  }\n\n  const writer = new jspb.BinaryWriter();\n  writer.writeBytes(1, field);\n  const reader = jspb.BinaryReader.alloc(writer.getResultBuffer()); // Start cursor (currently at -1, which does not match any valid WireType).\n\n  if (!reader.nextField()) {\n    throw new Error(util.format(errors.MESSAGES.ER_X_CLIENT_BAD_PROTOBUF_MESSAGE, 'Mysqlx.Resultset.Row.field'));\n  }\n\n  const decoder = reader.getFieldDecoder();\n  const type = options.column.getTypeId();\n\n  if (type === ResultsetStub.ColumnMetaData.FieldType.FLOAT) {\n    data = decodeFloat(decoder, options);\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.DOUBLE) {\n    data = decodeDouble(decoder, options);\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.SINT) {\n    data = decodeSignedInt(decoder, options);\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.UINT) {\n    data = decodeUnsignedInt(decoder, options);\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.BIT) {\n    data = decodeBitSequence(decoder, options);\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.BYTES || type === ResultsetStub.ColumnMetaData.FieldType.ENUM) {\n    data = decodeOpaqueByteString(decoder, Object.assign({}, {\n      length: field.length\n    }, options));\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.TIME) {\n    data = decodeTime(decoder, options);\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.DATETIME) {\n    data = decodeDatetime(decoder, options);\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.DECIMAL) {\n    data = decodeDecimal(decoder, Object.assign({}, {\n      length: field.length\n    }, options));\n  } else if (type === ResultsetStub.ColumnMetaData.FieldType.SET) {\n    data = decodeSet(decoder, options);\n  } else {\n    throw new Error(util.format(errors.MESSAGES.ER_X_CLIENT_BAD_PROTOBUF_MESSAGE, 'Mysqlx.Resultset.ColumnMetaData.type'));\n  }\n\n  decoder.free();\n  reader.free();\n  return data;\n}\n/**\n * @private\n * @alias module:adapters.Mysqlx.Resultset.Row\n * @param {proto.Mysqlx.Resultset.Row} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Resultset.Row}\n */\n\n\nfunction Row(proto, options) {\n  const state = Object.assign({}, {\n    metadata: []\n  }, options);\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Retrieve the column metadata associated to the given row.\n     * @private\n     * @function\n     * @name module:adapters.Mysqlx.Resultset.Row#getColumnMetadata\n     * @returns {Array<module:adapters.Mysqlx.Resultset.ColumnMetadata>} The array of column metadata type instances.\n     */\n    getColumnMetadata() {\n      return state.metadata;\n    },\n\n    /**\n     * Set the column metadata for the current row.\n     * @private\n     * @function\n     * @name module:adapters.Mysqlx.Resultset.Row#setColumnMetadata\n     * @returns {module:adapters.Mysqlx.Resultset.Row} The Row instance.\n     */\n    setColumnMetadata(metadata) {\n      state.metadata = metadata;\n      return this;\n    },\n\n    /**\n     * Decode the binary content of every field in the row.\n     * @private\n     * @function\n     * @name module:adapters.Mysqlx.Resultset.Row#toArray\n     * @returns {Array<*>} An array of native JavaScript values.\n     */\n    toArray() {\n      return proto.getFieldList().map((field, index) => decodeField(field, {\n        column: state.metadata[index]\n      }));\n    },\n\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @private\n     * @function\n     * @name module:adapters.Mysqlx.Resultset.Row#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      return {\n        fields: this.toArray()\n      };\n    }\n\n  });\n}\n/**\n * Creates a wrapper from a raw X Protocol message payload.\n * @returns {module:adapters.Mysqlx.Resultset.Row}\n */\n\n\nRow.deserialize = function (buffer) {\n  return Row(ResultsetStub.Row.deserializeBinary(bytes.deserialize(buffer)));\n};\n\nRow.MESSAGE_ID = ServerMessagesStub.Type.RESULTSET_ROW;\nmodule.exports = Row;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/Protocol/Wrappers/Messages/Resultset/Row.js"],"names":["ResultsetStub","require","ServerMessagesStub","ServerMessages","bytes","errors","jspb","util","wraps","MAX_DATATYPE_SIZE","DATETIME","TIME","decodeBitSequence","decoder","readUnsignedVarint64String","decodeDatetime","options","Object","assign","maxSize","formatDatetime","decodeTemporalValue","decodeDecimal","data","readBytes","length","toBuffer","scale","readUInt8","remaining","slice","toString","lastFourBits","charAt","toLowerCase","bcd","sign","int","decimal","formatSafeNumber","decodeDouble","formatDecimal","readDouble","decodeFloat","readFloat","decodeOpaqueByteString","column","isBinary","isFlagged","rightPad","getLength","readString","isJSON","JSON","parse","decodeSet","group","atEnd","beginning","getCursor","firstByte","concat","secondByte","setCursor","readStringWithLength","decodeSignedInt","signedInt","readZigzagVarint64","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","readZigzagVarint64String","decodeTime","formatTime","startingPoint","Buffer","alloc","value","toJSON","i","readUnsignedVarint64","decodeUnsignedInt","uint","leftPad","num","parseFloat","temporal","year","month","day","timeSlice","time","signed","date","Date","getTime","fractionalDigits","getFractionalDigits","toPrecision","Math","floor","round","pow","hour","minutes","seconds","useconds","negate","size","char","isBuffer","padding","asString","repeat","decodeField","field","Error","MESSAGES","ER_X_CLIENT_NO_COLUMN_METADATA","writer","BinaryWriter","writeBytes","reader","BinaryReader","getResultBuffer","nextField","format","ER_X_CLIENT_BAD_PROTOBUF_MESSAGE","getFieldDecoder","type","getTypeId","ColumnMetaData","FieldType","FLOAT","DOUBLE","SINT","UINT","BIT","BYTES","ENUM","DECIMAL","SET","free","Row","proto","state","metadata","getColumnMetadata","setColumnMetadata","toArray","getFieldList","map","index","fields","deserialize","buffer","deserializeBinary","MESSAGE_ID","Type","RESULTSET_ROW","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2020, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst ResultsetStub = require('../../../Stubs/mysqlx_resultset_pb');\nconst ServerMessagesStub = require('../../../Stubs/mysqlx_pb').ServerMessages;\nconst bytes = require('../../ScalarValues/bytes');\nconst errors = require('../../../../constants/errors');\nconst jspb = require('google-protobuf');\nconst util = require('util');\nconst wraps = require('../../Traits/Wraps');\n\n/**\n * Known max values for some specific data types.\n * @private\n * @readonly\n * @name MAX_DATATYPE_SIZE\n * @enum {number}\n */\nconst MAX_DATATYPE_SIZE = {\n    DATETIME: 8,\n    TIME: 5\n};\n\n/**\n * Decode a column value encoded using X Protocol BIT.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @returns {string} A string containing the decimal value (to avoid loosing precision).\n */\nfunction decodeBitSequence (decoder) {\n    return decoder.readUnsignedVarint64String();\n}\n\n/**\n * Decode a column value encoded using X Protocol DATETIME or TIMESTAMP.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {Object} [options] - object containing the column metadata\n * @returns {Date|number} A JavaScript date (DATETIME) or number (TIMESTAMP).\n */\nfunction decodeDatetime (decoder, options) {\n    options = Object.assign({ maxSize: MAX_DATATYPE_SIZE.DATETIME }, options);\n\n    return formatDatetime(decodeTemporalValue(decoder, options), options);\n}\n\n/**\n * Decode a column value encoded using X Protocol DECIMAL.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number|string} A JavaScript number or string (to avoid loosing precision) containing the decimal value.\n */\nfunction decodeDecimal (decoder, options) {\n    const data = bytes(decoder.readBytes(options.length)).toBuffer();\n\n    // scale is always a positive value, so we should assume its an unsigned int\n    const scale = data.readUInt8(0);\n\n    // read the remaining sequence (in hex to make it easier to operate on 4 bit segments)\n    const remaining = data.slice(1).toString('hex');\n\n    let lastFourBits = remaining.charAt(remaining.length - 1).toLowerCase();\n    let bcd;\n\n    if (lastFourBits !== '0') {\n        // the last character should be the sign\n        bcd = remaining.slice(0, remaining.length - 1);\n    } else {\n        // the last character should be the extra 4 bit zeroed padding\n        bcd = remaining.slice(0, remaining.length - 2);\n        lastFourBits = remaining.charAt(remaining.length - 2).toLowerCase();\n    }\n\n    const sign = lastFourBits === 'c' ? '+' : '-';\n    const int = bcd.slice(0, bcd.length - scale);\n    const decimal = bcd.slice(bcd.length - scale);\n\n    if (!decimal.length) {\n        return formatSafeNumber(`${sign}${int}`);\n    }\n\n    return formatSafeNumber(`${sign}${int}.${decimal}`);\n}\n\n/**\n * Decode a column value encoded using X Protocol DOUBLE.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number} A JavaScript number.\n */\nfunction decodeDouble (decoder, options) {\n    return formatDecimal(decoder.readDouble(), options);\n}\n\n/**\n * Decode a column value encoded using X Protocol FLOAT.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number} A JavaScript number.\n */\nfunction decodeFloat (decoder, options) {\n    return formatDecimal(decoder.readFloat(), options);\n}\n\n/**\n* Decode a column value encoded using X Protocol BYTES.\n* @private\n* @param {jspb.BinaryDecoder} decoder\n* @param {options} [options] - object containing the column metadata\n* @returns {string|Buffer} A JavaScript string (textual data) or a Node.js Buffer (binary data).\n*/\nfunction decodeOpaqueByteString (decoder, options) {\n    // XML should be equivalent to plain text.\n    options = Object.assign({}, options);\n\n    if (!options.length) {\n        return null;\n    }\n\n    if (options.column.isBinary()) {\n        // remove the extra '\\0' defined by the protocol\n        const data = bytes(decoder.readBytes(options.length - 1)).toBuffer();\n\n        if (options.column.isFlagged()) {\n            return rightPad(data, options.column.getLength(), '\\0');\n        }\n\n        return data;\n    }\n\n    // remove the extra '\\0' defined by the protocol\n    let data = decoder.readString(options.length - 1);\n\n    if (options.column.isFlagged()) {\n        data = rightPad(data, options.column.getLength(), ' ');\n    }\n\n    if (!options.column.isJSON()) {\n        return data;\n    }\n\n    return JSON.parse(data);\n}\n\n/**\n * Decode a column value encoded using X Protocol SET.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {string[]} A JavaScript array of JavaScript strings.\n */\nfunction decodeSet (decoder, options) {\n    let group = [];\n\n    // Sequence format is defined in the mysqlx_resultset.proto definition\n    // [0] - the NULL value\n    if (decoder.atEnd()) {\n        return null;\n    }\n\n    const beginning = decoder.getCursor();\n\n    const firstByte = bytes(decoder.readBytes(1)).toBuffer();\n\n    // [1] 0x00 - a set containing a blank string ''\n    if (firstByte.toString('hex') === '00') {\n        return group.concat('');\n    }\n\n    // [1] 0x01 - this would be an invalid value, but is to be treated as the empty set\n    if (firstByte.toString('hex') === '01' && decoder.atEnd()) {\n        return group;\n    }\n\n    const secondByte = bytes(decoder.readBytes(1)).toBuffer();\n\n    // [2] 0x01 0x00 - a set with a single item, which is the '\\0' character\n    if (firstByte.toString('hex') === '01' && secondByte.toString('hex') === '00') {\n        return group.concat('\\0');\n    }\n\n    // We need read the whole sequence so we must restart the cursor (it is\n    // partially consumed by this point).\n    decoder.setCursor(beginning);\n\n    while (!decoder.atEnd()) {\n        // [8] 0x03 F O O 0x03 B A R - a set with 2 items: FOO,BAR\n        group = group.concat(decoder.readStringWithLength());\n    }\n\n    return group;\n}\n\n/**\n * Decode a column value encoded using X Protocol SINT.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number|string} A JavaScript number or string (to avoid loosing precision) containing the decimal value.\n */\nfunction decodeSignedInt (decoder, options) {\n    const beginning = decoder.getCursor();\n    // let's start by trying to decode the value as a JavaScript number\n    const signedInt = decoder.readZigzagVarint64();\n\n    // if there is no chance of losing precision, we can proceed\n    if (signedInt >= Number.MIN_SAFE_INTEGER && signedInt <= Number.MAX_SAFE_INTEGER) {\n        return signedInt;\n    }\n\n    // otherwise, we need to go back and decode it as string\n    decoder.setCursor(beginning);\n\n    return decoder.readZigzagVarint64String();\n}\n\n/**\n * Decode a column value encoded using X Protocol TIME.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {string} A JavaScript string containting the time representation.\n */\nfunction decodeTime (decoder, options) {\n    options = Object.assign({ maxSize: MAX_DATATYPE_SIZE.TIME }, options);\n\n    return formatTime(decodeTemporalValue(decoder, options));\n}\n\n/**\n * Decode a column value encoded using X Protocol TIME, DATE, DATETIME or TIMESTAMP.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing internal implementation details\n * @returns {number[]} A JavaScript array encoding the temporal representation.\n */\nfunction decodeTemporalValue (decoder, options) {\n    options = Object.assign({ maxSize: 0 }, options);\n\n    const startingPoint = Buffer.alloc(options.maxSize);\n    const value = startingPoint.toJSON().data;\n\n    let i = 0;\n\n    while (!decoder.atEnd()) {\n        // No precision loss, since the maximum value is 999999 (useconds).\n        value[i++] = decoder.readUnsignedVarint64();\n    }\n\n    return value;\n}\n\n/**\n * Decode a column value encoded using X Protocol UINT.\n * @private\n * @param {jspb.BinaryDecoder} decoder\n * @param {options} [options] - object containing the column metadata\n * @returns {number|string} A JavaScript string (when there is overflow or zerofill) or number.\n */\nfunction decodeUnsignedInt (decoder, options) {\n    const uint = formatSafeNumber(decoder.readUnsignedVarint64String());\n\n    if (!options.column.isFlagged()) {\n        return uint;\n    }\n\n    return leftPad(uint, options.column.getLength(), '0');\n}\n\n/**\n * Format the output of a JavaScript number to avoid loosing precision.\n * @private\n * @param {string} value - string containing a numeric value\n * @returns {number|string} A JavaScript string (when there is overflow) or number.\n */\nfunction formatSafeNumber (value) {\n    const num = parseFloat(value);\n\n    if (num < Number.MIN_SAFE_INTEGER || num > Number.MAX_SAFE_INTEGER) {\n        return value;\n    }\n\n    return num;\n}\n\n/**\n * Format a temporal value encoded as an array.\n * @private\n * @param {number[]} temporal\n * @param {options} [options] - object containing internal implementation details\n * @returns {string} A JavaScript string containing the time representation.\n */\nfunction formatDatetime (temporal, options) {\n    const year = leftPad(temporal[0], 4, '0');\n    const month = leftPad(temporal[1], 2, '0');\n    const day = leftPad(temporal[2], 2, '0');\n\n    const timeSlice = temporal.slice(2, temporal.length);\n    const time = formatTime(timeSlice, { signed: false });\n\n    const date = new Date(`${year}-${month}-${day}T${time}Z`);\n\n    if (options.column.isFlagged()) {\n        // should be a timestamp\n        return date.getTime();\n    }\n\n    return date;\n}\n\n/**\n * Apply a rounding mask to a decimal value according to the metadata definition.\n * @private\n * @param {number} value - JavaScript number\n * @param {options} [options] - object containing the column metadata\n * @returns {number} The masked JavaScript number.\n */\nfunction formatDecimal (value, options) {\n    // number of decimal digits\n    const fractionalDigits = options.column.getFractionalDigits() || value.toPrecision().slice(Math.floor(value).toString().length + 1).length;\n\n    return Math.round(value * Math.pow(10, fractionalDigits)) / Math.pow(10, fractionalDigits);\n}\n\n/**\n * Format a temporal value encoded as an array.\n * @private\n * @param {number[]} temporal\n * @param {options} [options] - object containing internal implementation details\n * @returns {string} A JavaScript string containing the time representation.\n */\nfunction formatTime (temporal, options) {\n    options = Object.assign({ signed: true }, options);\n\n    const hour = leftPad(temporal[1], 2, '0');\n    const minutes = leftPad(temporal[2], 2, '0');\n    const seconds = leftPad(temporal[3], 2, '0');\n    const useconds = leftPad(temporal[4], 6, '0');\n\n    const time = `${hour}:${minutes}:${seconds}.${useconds}`;\n\n    if (!options.signed) {\n        return time;\n    }\n\n    const negate = temporal[0] > 0 ? '-' : '+';\n\n    return `${negate}${time}`;\n}\n\n/**\n * Left pad a value with a given length.\n * @private\n * @param {Buffer|number|string} value - value to pad\n * @param {number} [size] - expected output size\n * @param {string} [char] - filler character\n * @returns {string} The left-padded JavaScript string or Node.js Buffer.\n */\nfunction leftPad (value, size, char) {\n    char = char || ' ';\n\n    if (Buffer.isBuffer(value)) {\n        if (!size || size <= value.length) {\n            return value;\n        }\n\n        const padding = Buffer.alloc(size - value.length);\n\n        return Buffer.concat([padding, value], padding.length + value.length);\n    }\n\n    const asString = value.toString();\n    const maxSize = value.toString().length;\n\n    if (!size || size <= maxSize) {\n        return asString;\n    }\n\n    return char.repeat(size - maxSize).concat(asString);\n}\n\n/**\n * Right pad a value with a length.\n * @private\n * @param {Buffer|number|string} value - value to pad\n * @param {number} [size] - expected output size\n * @param {string} [char] - filler character\n * @returns {string} The right-padded JavaScript string or Node.js Buffer.\n */\nfunction rightPad (value, size, char) {\n    char = char || ' ';\n\n    if (Buffer.isBuffer(value)) {\n        if (!size || size <= value.length) {\n            return value;\n        }\n\n        const padding = Buffer.alloc(size - value.length);\n\n        return Buffer.concat([value, padding], value.length + padding.length);\n    }\n\n    const asString = value.toString();\n    const maxSize = value.toString().length;\n\n    if (!size || size <= maxSize) {\n        return asString;\n    }\n\n    return asString.concat(char.repeat(size - maxSize));\n}\n\n/**\n * Decode a column value for each Mysqlx.Resultset.Row.\n * @private\n * @param {Uint8Array} field - Protocol Buffers `bytes` type.\n * @param {Object} [options] - object containing the column metadata\n * @returns {*} - A native JavaScript type.\n */\nfunction decodeField (field, options) {\n    let data;\n\n    if (!options.column) {\n        throw new Error(errors.MESSAGES.ER_X_CLIENT_NO_COLUMN_METADATA);\n    }\n\n    // Empty field values match to NULL.\n    if (!field.length) {\n        return null;\n    }\n\n    const writer = new jspb.BinaryWriter();\n    writer.writeBytes(1, field);\n\n    const reader = jspb.BinaryReader.alloc(writer.getResultBuffer());\n\n    // Start cursor (currently at -1, which does not match any valid WireType).\n    if (!reader.nextField()) {\n        throw new Error(util.format(errors.MESSAGES.ER_X_CLIENT_BAD_PROTOBUF_MESSAGE, 'Mysqlx.Resultset.Row.field'));\n    }\n\n    const decoder = reader.getFieldDecoder();\n    const type = options.column.getTypeId();\n\n    if (type === ResultsetStub.ColumnMetaData.FieldType.FLOAT) {\n        data = decodeFloat(decoder, options);\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.DOUBLE) {\n        data = decodeDouble(decoder, options);\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.SINT) {\n        data = decodeSignedInt(decoder, options);\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.UINT) {\n        data = decodeUnsignedInt(decoder, options);\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.BIT) {\n        data = decodeBitSequence(decoder, options);\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.BYTES || type === ResultsetStub.ColumnMetaData.FieldType.ENUM) {\n        data = decodeOpaqueByteString(decoder, Object.assign({}, { length: field.length }, options));\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.TIME) {\n        data = decodeTime(decoder, options);\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.DATETIME) {\n        data = decodeDatetime(decoder, options);\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.DECIMAL) {\n        data = decodeDecimal(decoder, Object.assign({}, { length: field.length }, options));\n    } else if (type === ResultsetStub.ColumnMetaData.FieldType.SET) {\n        data = decodeSet(decoder, options);\n    } else {\n        throw new Error(util.format(errors.MESSAGES.ER_X_CLIENT_BAD_PROTOBUF_MESSAGE, 'Mysqlx.Resultset.ColumnMetaData.type'));\n    }\n\n    decoder.free();\n    reader.free();\n\n    return data;\n}\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Resultset.Row\n * @param {proto.Mysqlx.Resultset.Row} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Resultset.Row}\n */\nfunction Row (proto, options) {\n    const state = Object.assign({}, { metadata: [] }, options);\n\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Retrieve the column metadata associated to the given row.\n         * @private\n         * @function\n         * @name module:adapters.Mysqlx.Resultset.Row#getColumnMetadata\n         * @returns {Array<module:adapters.Mysqlx.Resultset.ColumnMetadata>} The array of column metadata type instances.\n         */\n        getColumnMetadata () {\n            return state.metadata;\n        },\n\n        /**\n         * Set the column metadata for the current row.\n         * @private\n         * @function\n         * @name module:adapters.Mysqlx.Resultset.Row#setColumnMetadata\n         * @returns {module:adapters.Mysqlx.Resultset.Row} The Row instance.\n         */\n        setColumnMetadata (metadata) {\n            state.metadata = metadata;\n            return this;\n        },\n\n        /**\n         * Decode the binary content of every field in the row.\n         * @private\n         * @function\n         * @name module:adapters.Mysqlx.Resultset.Row#toArray\n         * @returns {Array<*>} An array of native JavaScript values.\n         */\n        toArray () {\n            return proto.getFieldList()\n                .map((field, index) => decodeField(field, { column: state.metadata[index] }));\n        },\n\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @private\n         * @function\n         * @name module:adapters.Mysqlx.Resultset.Row#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            return { fields: this.toArray() };\n        }\n    });\n}\n\n/**\n * Creates a wrapper from a raw X Protocol message payload.\n * @returns {module:adapters.Mysqlx.Resultset.Row}\n */\nRow.deserialize = function (buffer) {\n    return Row(ResultsetStub.Row.deserializeBinary(bytes.deserialize(buffer)));\n};\n\nRow.MESSAGE_ID = ServerMessagesStub.Type.RESULTSET_ROW;\n\nmodule.exports = Row;\n"]},"metadata":{},"sourceType":"script"}