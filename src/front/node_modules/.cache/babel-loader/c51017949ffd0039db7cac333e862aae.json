{"ast":null,"code":"/*\n * Copyright (c) 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst Client = require('../Protocol/Client');\n\nconst Net = require('net');\n\nconst TLS = require('tls');\n\nconst authenticationManager = require('../Authentication/AuthenticationManager');\n\nconst errors = require('../constants/errors');\n\nconst logger = require('../logger');\n\nconst multiHost = require('../topology/multi-host');\n\nconst pkg = require('../package');\n\nconst secureContext = require('../tls/secure-context');\n\nconst srv = require('../topology/dns-srv');\n\nconst system = require('../system');\n\nconst util = require('util');\n\nconst warnings = require('../constants/warnings');\n\nconst {\n  isValidBoolean,\n  isValidInteger,\n  isValidPlainObject\n} = require('../validator');\n/**\n * Connection factory.\n * @module Connection\n */\n\n/**\n * MySQL server endpoint details.\n * @typedef {Object} Endpoint\n * @prop {string} [host=localhost] - hostname or IP (v4 or v6) of a MySQL server instance\n * @prop {number} [port=33060] - X Plugin port on the MySQL server instance\n * @prop {number} [priority] - priority of an endpoint relative to the others (endpoints with higher priority are picked first)\n * @prop {string} [socket] - relative or absolute path of a local Unix socket file\n */\n\n/**\n * Connection TLS-specific properties.\n * @typedef {Object} TLS\n * @prop {boolean} [enabled=true] - enables or disables TLS\n * @prop {string} [ca] - path of a file containing a certificate authority chain used to verify the server certificate\n * @prop {string} [crl] - path of a file containing a certificate revocation list used, alongside a certificate authority, to verify the server certificate\n * @prop {string[]} [versions=TLSv1.2, TLSv1.3] - restrict the list of allowed TLS versions (TLSv1.2, TLSv1.3)\n * @prop {string[]} [ciphershuites] - list of ciphersuites to allow (IANA syntax)\n */\n\n/**\n * Connection configuration properties.\n * @typedef {Object} Properties\n * @prop {string} [auth] - name of the client-side authentication mechanism to use\n * @prop {number} [connectTimeout=10000] - maximum ammount of time (ms) to wait for a server connection to be opened\n * @prop {Object} [connectionAttributes={}] - key-value object containing names and values of session attributes\n * @prop {module:Connection~Endpoint[]} [endpoints=[]] - list of endpoints to connect to\n * @prop {string} [host=localhost] - hostname or IP (v4 or v6) of a MySQL server instance\n * @prop {string} [password] - password for the MySQL account (defaults to '')\n * @prop {number} [port=33060] - X Plugin port on the MySQL server instance\n * @prop {boolean} [resolveSrv=false] - enable or disable DNS SRV resolution\n * @prop {string} [schema] - default database to connect to (defaults to '')\n * @prop {string} [socket] - relative or absolute path of a local Unix socket file\n * @prop {boolean} [resolveSrv=false] - use the host to perform a DNS SRV lookup and obtain the list of endpoints\n * @prop {module:Connection~TLS} [tls] - TLS options\n * @prop {string} [user] - user of the MySQL account (defaults to '')\n */\n\n\nconst VALID_OPTIONS = ['auth', 'connectTimeout', 'connectionAttributes', 'dbPassword', // deprecated\n'dbUser', // deprecated\n'endpoints', 'host', 'password', 'port', 'resolveSrv', 'schema', 'socket', 'ssl', // deprecated\n'sslOptions', // deprecated\n'tls', 'user'];\n/**\n * @private\n * @typedef {Object} DefaultSessionAttributes Default set of session\n * attributes created by the client when connecting to a MySQL server that\n * supports session attributes.\n * @prop {string} _pid - client process id\n * @prop {string} _platform - platform name of the processor architecture\n * @prop {string} _os - name and version of the operating system\n * @prop {string} _client_name - name of the client product\n * @prop {string} _client_version - version of the client product\n * @prop {string} _client_license - license name of the client product\n */\n\nconst CLIENT_SESSION_ATTRIBUTES = {\n  _pid: system.pid(),\n  _platform: system.platform(),\n  _os: system.brand(),\n  _source_host: system.hostname(),\n  _client_name: pkg.name(),\n  _client_version: pkg.version(),\n  _client_license: pkg.license()\n};\n/**\n * Stringifies all the values in a given object.\n * @private\n * @param {Object} obj\n * @returns {Object}\n */\n\nfunction stringifyValues() {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let root = true;\n  return JSON.stringify(obj, (k, v) => {\n    // The replacer should skip the root node to avoid a stack overflow.\n    if (root) {\n      root = false;\n      return v;\n    } // If the value is undefined, in order to keep consistency between\n    // connection strings and configuration objects, we coerce it to\n    // an empty string. If the value is null (only possible with a\n    // configuration object), we also coerce to an empty string in order\n    // to avoid saving 'null'.\n\n\n    if (typeof v === 'undefined' || v === null) {\n      return '';\n    } // If the value is already a string, we should not do anything.\n\n\n    if (typeof v === 'string') {\n      return v;\n    } // If the value is neither an object nor an array, we return its\n    // stringified version.\n\n\n    if (typeof v !== 'object') {\n      return JSON.stringify(v);\n    } // Otherwise we need to recursively do the same for the values in \"v\".\n\n\n    return stringifyValues(v);\n  });\n}\n/**\n * @private\n * @typedef {Object} DeprecatedSSLOptions\n * @prop {string} [ca] - deprecated connection property for providing a path to a certificate authority file\n * @prop {string} [crl] - deprecated connection property for providing a path to a certificate revocation list file\n */\n\n/**\n * Toggle deprecation warnings for deprecated connection properties.\n * @private\n * @param {Object} params\n * @param {string} [params.dbPassword] - deprecate connection property for the MySQL account password\n * @param {string} [params.dbUser] - deprecated connection property for the MySQL account user\n * @param {boolean} [params.ssl] - deprecated connection property for enabling or disabling TLS\n * @param {DeprecatedSSLOptions} [params.dbUser] - deprecated connection property for additional SSL options\n * @returns {boolean}\n */\n\n\nfunction deprecate(_ref) {\n  let {\n    dbPassword,\n    dbUser,\n    ssl,\n    sslOptions\n  } = _ref;\n  const log = logger('connection:options'); // The \"dbPassword\" property is deprecated.\n\n  if (typeof dbPassword !== 'undefined') {\n    log.warning('dbPassword', warnings.MESSAGES.WARN_DEPRECATED_DB_PASSWORD, {\n      type: warnings.TYPES.DEPRECATION,\n      code: warnings.CODES.DEPRECATION\n    });\n  } // The \"dbUser\" property is deprecated.\n\n\n  if (typeof dbUser !== 'undefined') {\n    log.warning('dbUser', warnings.MESSAGES.WARN_DEPRECATED_DB_USER, {\n      type: warnings.TYPES.DEPRECATION,\n      code: warnings.CODES.DEPRECATION\n    });\n  } // The \"ssl\" and \"sslOptions\" properties are deprecated.\n\n\n  if (typeof ssl !== 'undefined') {\n    log.warning('ssl', warnings.MESSAGES.WARN_DEPRECATED_SSL_OPTION, {\n      type: warnings.TYPES.DEPRECATION,\n      code: warnings.CODES.DEPRECATION\n    });\n  }\n\n  if (typeof sslOptions !== 'undefined') {\n    log.warning('sslOptions', warnings.MESSAGES.WARN_DEPRECATED_SSL_ADDITIONAL_OPTIONS, {\n      type: warnings.TYPES.DEPRECATION,\n      code: warnings.CODES.DEPRECATION\n    });\n  }\n\n  return true;\n}\n/**\n * @alias module:Connection\n * @param {Properties} - connection properties\n * @returns {module:Connection}\n */\n\n\nfunction Connection() {\n  let {\n    auth,\n    connectionAttributes = {},\n    connectTimeout = 10000,\n    dbPassword,\n    dbUser,\n    endpoints = [],\n    host = 'localhost',\n    password = '',\n    port = 33060,\n    schema,\n    socket,\n    resolveSrv = false,\n    ssl,\n    sslOptions,\n    tls = {},\n    user = ''\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Internal connection state.\n  const state = {\n    // Contains the name of the authentication mechanism that is\n    // effectively negotiated with the server.\n    auth,\n    // Indicates if the connection supports prepared statements (MySQL\n    // 8.0.16 or higher).\n    canPrepareStatements: true,\n    // Contains the list of connection capabilities that were effectively\n    // negotiated with the server.\n    capabilities: {},\n    // Tracks an internal X Protocol client instance.\n    client: null,\n    // We keep a list of available and unavailable endpoints for\n    // connection failover.\n    endpoints: {\n      // If there is a list of endpoints, we should use it.\n      // If not, it should only include an endpoint with the details\n      // specified by the \"host\", \"port\" and/or \"socket\" properties or\n      // by the first and only element in that list.\n      // When a connection is first opened, all endpoints should be\n      // available. This can change if a socket cannot be created for\n      // a given endpoint.\n      available: endpoints.length ? endpoints : [{\n        host,\n        port,\n        socket\n      }],\n      unavailable: []\n    },\n    // Indicates the connection is being closed.\n    isClosing: false,\n    // Indicates if the connection established with the server\n    // is using TLS.\n    isSecure: false,\n    // Indicates if the connection should be retried to the same endpoint.\n    retry: false,\n    // Indicates the number of milliseconds to wait before retrying a\n    // specific endpoint.\n    retryAfter: 20000,\n    // Contains the connection id assigned by the server.\n    serverId: null,\n    // Contains the list of statements that were prepared and exist in the\n    // scope of the associated server session.\n    statements: [],\n    // Merges any contents of the deprecated \"ssl\" and \"sslOptions\"\n    // properties with the content of the \"tls\" property.\n    // For tls.enable = true, we need to ensure that ssl !== false.\n    // Additional options are merged with precedence for those defined\n    // using the \"tls\" property, except for \"ciphersuites\" and \"versions\"\n    // which we want to override given the validation constraints.\n    tls: Object.assign({}, {\n      enabled: ssl === false ? ssl : true\n    }, sslOptions, tls),\n    // Tracks the list of capabilities that the server does not know.\n    unknownCapabilities: []\n  };\n  return {\n    /**\n     * Adds a set of connection capabilities to the existing ones.\n     * @private\n     * @function\n     * @name module:Connection#addCapabilities\n     * @param {Object} capabilities - set of capabilities\n     * @returns {module:Connection} The connection instance\n     */\n    addCapabilities(capabilities) {\n      state.capabilities = Object.assign({}, state.capabilities, capabilities);\n      return this;\n    },\n\n    /**\n     * Checks if the connection setup allows to retry authentication.\n     * @private\n     * @function\n     * @name module:Connection:allowsAuthenticationRetry\n     * @returns {boolean}\n     */\n    allowsAuthenticationRetry() {\n      // If the application provides its own authentication mechanism,\n      // there is no reason to retry.\n      if (this.hasCustomAuthenticationMechanism()) {\n        return false;\n      } // If the connection is secure, it means the authentication\n      // failed because the credentials did not match, so we should\n      // not allow a retry.\n\n\n      if (state.endpoints.available[0].socket || state.tls.enabled) {\n        return false;\n      } // Which leaves us with checking if the server supports or not\n      // the fallback authentication mechanism.\n\n\n      return this.allowsAuthenticationWith('SHA256_MEMORY');\n    },\n\n    /**\n     * Checks if a given authentication mechanism can be used with the\n     * connection.\n     * @private\n     * @function\n     * @name module:Connection#allowsAuthenticationWith\n     * @param {string} mechanism - name of the authentication mechanism\n     * @returns {boolean}\n     */\n    allowsAuthenticationWith(mechanism) {\n      // This is a workaround because on MySQL 5.7.x, calling\n      // Mysqlx.Connection::CapabilitiesGet over a unix socket does not\n      // return `PLAIN` while is in fact supported.\n      const serverSupportedMechanisms = (state.capabilities['authentication.mechanisms'] || []).concat('PLAIN');\n      return serverSupportedMechanisms.indexOf(mechanism) > -1;\n    },\n\n    /**\n     * Negotiates the proper authentication mechanism for the connection user.\n     * @private\n     * @function\n     * @name module:Connection#authenticate\n     * @returns {module:Connection} The connection instance\n     */\n    authenticate() {\n      // Try the custom authentication mechanism, if it is provided,\n      // PLAIN, if the connection is secure, or MYSQL41, if not.\n      const mechanism = this.getAuth();\n\n      if (!this.allowsAuthenticationWith(mechanism)) {\n        const message = util.format(errors.MESSAGES.ER_DEVAPI_AUTH_UNSUPPORTED_SERVER, mechanism);\n        const error = new Error(message);\n        error.info = {\n          code: errors.ER_ACCESS_DENIED_ERROR,\n          msg: message\n        };\n        return Promise.reject(error);\n      }\n\n      return this.authenticateWith(mechanism).catch(err => {\n        // If the setup does not allow to retry the authentication\n        // or if the error is not related to authentication we\n        // should report it.\n        if (!this.allowsAuthenticationRetry() || err.info && err.info.code !== errors.ER_ACCESS_DENIED_ERROR) {\n          throw err;\n        } // Otherwise we should perform the fallback strategy and\n        // try with SHA256_MEMORY.\n\n\n        return this.authenticateWith('SHA256_MEMORY').catch(err => {\n          // If it is not an authentication error, we should bubble that\n          // error instead.\n          if (err.info && err.info.code !== errors.ER_ACCESS_DENIED_ERROR) {\n            throw err;\n          } // Otherwise, we improve the existing error message.\n\n\n          err.message = err.info.msg = errors.MESSAGES.ER_DEVAPI_AUTH_MORE_INFO;\n          throw err;\n        });\n      });\n    },\n\n    /**\n     * Authenticates the connection user with a given mechanism.\n     * @private\n     * @function\n     * @name module:Connection#authenticateWith\n     * @param {string} mechanism - name of the authentication mechanism\n     * @returns {Promise<module:Connection>} A Promise that resolves to the\n     * connection instance.\n     */\n    authenticateWith(mechanism) {\n      const plugin = authenticationManager.getPlugin(mechanism);\n      const theUser = this.getUser(); // We don't expose a getPassword() method because, the connection\n      // is publicly available with session._getConnection()\n\n      const thePassword = password || dbPassword || '';\n      return plugin({\n        password: thePassword,\n        schema,\n        user: theUser\n      }).run(state.client).then(session => {\n        state.auth = mechanism;\n        state.serverId = session.connectionId;\n        return this;\n      });\n    },\n\n    /**\n     * Retrieves the server-side connection capabilities that have been\n     * effectively negotiated.\n     * @private\n     * @function\n     * @name module:Connection#capabilitiesGet\n     * @returns {Promise}\n     */\n    capabilitiesGet() {\n      return state.client.capabilitiesGet();\n    },\n\n    /**\n     * Negotiates a set of connection capabilities with the server\n     * (X Plugin).\n     * @private\n     * @function\n     * @name module:Connection#capabilitiesSet\n     * @returns {Promise}\n     */\n    capabilitiesSet() {\n      // TODO(Rui): any additional capability, such as compression, can\n      // be negotiated in this pipeline.\n      const capabilities = {}; // If TLS is enabled and the connection is not using a local Unix socket,\n      // we need to enable TLS in the X Plugin.\n\n      if (state.tls.enabled === true && !state.endpoints.available[0].socket) {\n        // The X Protocol capability name is \"tls\".\n        capabilities.tls = true;\n      } // If connection attributes are to be sent, we need to merge the\n      // default client attributes. Additionally, if the server does\n      // not support session attributes, the connection is re-tried and\n      // we should disable them in the second attempt.\n\n\n      if (connectionAttributes !== false && state.unknownCapabilities.indexOf('session_connect_attrs') === -1) {\n        const attributes = Object.assign({}, CLIENT_SESSION_ATTRIBUTES, connectionAttributes); // The X Plugin requires all connection attributes to be\n        // encoded as strings. The client attributes are already\n        // expected to be strings. However, custom application\n        // attributes that are not strings need to be coerced.\n        // If they are not able to be coerced (e.g. null or\n        // undefined), we should propagate the error reported by the\n        // plugin.\n        // The X Protocol capability name is \"session_connect_attrs\".\n\n        capabilities.session_connect_attrs = JSON.parse(stringifyValues(attributes));\n      }\n\n      return state.client.capabilitiesSet(capabilities).then(() => {\n        // Must return the client capabilities for further\n        // processing.\n        return capabilities;\n      }).catch(err => {\n        // When TLS is not enabled in the server, we want\n        // to report back a custom message.\n        if (err.info && err.info.code === errors.ER_X_CAPABILITIES_PREPARE_FAILED) {\n          // By TLS not being enabled, it means that the X\n          // Plugin will report an error stating that the \"tls\"\n          // capability failed. This is a generic error that can\n          // mean any other capability is invalid, so we need to\n          // ensure we are dealing with TLS. Currently the only\n          // way to retrieve the capability name is to parse the\n          // error message.\n          const failedCapability = err.message.match(/Capability prepare failed for '([^']+)'.*/)[1]; // If the failure is not related to TLS, we should\n          // report the error as is.\n\n          if (failedCapability !== 'tls') {\n            throw err;\n          } // Otherwise, we want to report a custom message.\n\n\n          const message = errors.MESSAGES.ER_DEVAPI_NO_SERVER_TLS;\n          err.message = message;\n          err.info.msg = message;\n          throw err;\n        } // When a new capability is introduced, it will be unknown\n        // to older server versions. In that case, the server will\n        // report an error and will close the connection. However,\n        // since there is no way to ensure the capability is\n        // supported beforehand, we have to try and send it anyway\n        // asking for forgiveness instead of permission. Thus, in\n        // order to make it seamless to the application, we need\n        // to destroy the network socket and re-create the\n        // connection without the unknown capabilities.\n\n\n        if (!err.info || err.info.code !== errors.ER_X_CAPABILITY_NOT_FOUND) {\n          throw err;\n        } // By this point, the server has sent back an\n        // ER_X_CAPABILITY_NOT_FOUND error and has closed the\n        // connection.\n        // So, the first thing we need to do is to track the\n        // unknown capability. Currently the only way to retrieve\n        // the capability name is to parse the error message.\n\n\n        const unknownCapability = err.message.match(/Capability '([^']+)'.*/)[1];\n        state.unknownCapabilities.push(unknownCapability); // And we need to ensure that we re-create a connection to\n        // the same endpoint. Since we are now tracking unknown\n        // capabilities, any new connection will not try to\n        // negotiate those.\n\n        state.retry = true;\n        const socket = state.client.getConnection();\n        socket.destroy(err);\n      });\n    },\n\n    /**\n     * Closes the X Protocol connection and the underlying connection\n     * socket.\n     * This method is overriden by PoolConnection\n     * @private\n     * @function\n     * @name module:Connection#close\n     * @returns {Promise}\n     */\n    close() {\n      return this.destroy();\n    },\n\n    /**\n     * Creates a network socket to the most appropriate MySQL server\n     * endpoint.\n     * @private\n     * @function\n     * @name module:Connection#connect\n     * @returns {Promise<module:Connection>}\n     */\n    connect() {\n      return new Promise((resolve, reject) => {\n        // We want to connect to the first endpoint that is available.\n        const endpoint = state.endpoints.available[0]; // In the case of multi-host connections, we want sane\n        // defaults for each endpoint in the list, in order to\n        // require less verbosity from the user.\n\n        const nodeSocket = Net.connect({\n          host: endpoint.host || 'localhost',\n          port: endpoint.port || 33060,\n          path: endpoint.socket\n        });\n        nodeSocket.setTimeout(connectTimeout); // Actions to perform after a connection is successfully\n        // established (including server session).\n\n        const postConnect = connection => {\n          // We need to \"remove\" the timeout because we do not want\n          // the event to be triggered after the connection is\n          // effectively established.\n          // For now, we consider \"connectTimeout\" to be the maximum\n          // time it can take for a client socket (TLS or not) to\n          // successfully connect to the server.\n          nodeSocket.setTimeout(0);\n          return resolve(connection);\n        }; // Actions to perform when there is an error in the connection\n        // stage.\n\n\n        const postDisconnect = err => {\n          // We should cleanup the connection state.\n          this.reset(); // If there isn't an error, it means the socket has been\n          // closed by the server and the client was expecting it.\n          // There's nothing to do, the workflow is just finished\n          // by this point.\n\n          if (!err) {\n            return resolve();\n          } // If there is an error, it means the socket has been\n          // closed with an error and we need to report it back\n          // to the application.\n\n\n          return reject(err);\n        }; // For now, we consider every error to happen at the\n        // connection stage, to be fatal, and thus, we should stop and\n        // close/destroy the connection.\n\n\n        nodeSocket.once('ready', () => {\n          // We can start creating the client instance, which will\n          // hold the given connection. This is important because\n          // we do not need to keep the raw socket available\n          // everywhere but we still want to decouple the TLS logic.\n          state.client = new Client(nodeSocket); // We can now start the process of creating a server-side\n          // X Protocol session.\n\n          return this.start().then(postConnect).catch(err => nodeSocket.destroy(err));\n        });\n        nodeSocket.once('error', err => {\n          // The \"close\" event will automatically be triggered.\n          state.error = err;\n        });\n        nodeSocket.once('timeout', () => {\n          const error = new Error();\n          error.name = 'ETIMEDOUT'; // The error message depends on whether the connection is\n          // multi-host or not.\n\n          if (!this.hasMultipleEndpoints()) {\n            error.message = util.format(errors.MESSAGES.ER_DEVAPI_CONNECTION_TIMEOUT, connectTimeout);\n          } else {\n            error.message = util.format(errors.MESSAGES.ER_DEVAPI_MULTI_HOST_CONNECTION_TIMEOUT, connectTimeout);\n          } // The connection must be manually closed.\n          // https://nodejs.org/docs/latest/api/net.html#net_event_timeout\n\n\n          nodeSocket.destroy(error);\n        });\n        nodeSocket.on('data', data => {\n          state.client.handleNetworkFragment(data);\n        });\n        nodeSocket.once('close', hasError => {\n          // When the endpoint becomes unvailable in the middle of\n          // some work load, we should delegate error handling to\n          // the specific worker.\n          if (!hasError && this.isOpen() && this.isActive()) {\n            // We are already past the connection stage.\n            return state.client.handleServerClose();\n          } // When a fatal error happens in the server, it will close\n          // the connection, but since it is not a network error,\n          // \"hasError\" will be \"false\", so we need to account for\n          // that cenario. In that case, we can check if the\n          // connection is already active or not.\n\n\n          if (!hasError && this.isOpen()) {\n            // It means the connection was legitimately closed.\n            return postDisconnect();\n          } // If we cannot retry, the current connection should\n          // become unavailable. One reason to retry the current\n          // connection is if the server is available but refused\n          // the connection with a non-fatal error (such as when\n          // a capability is not known).\n\n\n          if (!state.retry) {\n            // When a connection becomes unavailable, it should\n            // include the timestamp of when it was last tried.\n            const unavailable = Object.assign({}, state.endpoints.available.shift(), {\n              unavailableAt: Date.now()\n            });\n            state.endpoints.unavailable.push(unavailable);\n          } // If we are retrying now, we should prevent duplicate\n          // retries.\n\n\n          state.retry = false; // By this point, there should be an error available in\n          // \"state.error\", which is updated for each error event in\n          // the socket (but also includes other kinds of errors).\n\n          const error = this.getError(); // We want to know if the the timeout has been reached for\n          // all the endpoints, or if there was a different issue.\n\n          if (!this.hasMoreEndpointsAvailable() && (!this.hasMultipleEndpoints() || error.name === 'ETIMEDOUT')) {\n            return postDisconnect(error);\n          } // If we are in a multi-host setup and there are no more\n          // endpoints available, we want to raise a custom error\n          // as well.\n\n\n          if (!this.hasMoreEndpointsAvailable() && this.hasMultipleEndpoints()) {\n            error.name = 'ENOMOREHOSTS';\n            error.errno = errors.ER_DEVAPI_MULTI_HOST_CONNECTION_FAILED;\n            error.message = errors.MESSAGES.ER_DEVAPI_MULTI_HOST_CONNECTION_FAILED;\n            return postDisconnect(error);\n          } // By this point, the list of available and unavailable\n          // endpoints is already up-to-date and if there are more\n          // endpoints available, we should try to connect to the\n          // next one in the list.\n\n\n          this.connect().then(postConnect).catch(postDisconnect);\n        });\n      });\n    },\n\n    /**\n     * Asks the server to gracefully close the underlying X Protocol\n     * connection.\n     * @private\n     * @function\n     * @name module:Connection#destroy\n     * @returns {Promise}\n     */\n    destroy() {\n      // This operation should be idempotent because there is a chance\n      // that the connection might already been closed by the server\n      // we should check first.\n      if (!this.isOpen() || state.isClosing) {\n        return Promise.resolve();\n      }\n\n      const socket = state.client.getConnection(); // Again, the operation should be idempotent, so, if the socket\n      // reference has already been destroyed, there is nothing to do.\n\n      if (socket.destroyed) {\n        return Promise.resolve();\n      } // Eventually, the socket is destroyed and a 'close' event is\n      // emmitted. This is here just to make sure the operation does\n      // not fail if the connection is, for some weird reason, manually\n      // closed again by the application.\n\n\n      state.isClosing = true; // The method is shared between this and \"PoolConnection\".\n      // We cannot re-use \"close()\" because it is overrided by \"PoolConnection\".\n\n      return state.client.connectionClose().then(() => {\n        // The server closes the socket on their end so we also\n        // need to destroy our reference.\n        // This will trigger a 'close' event whose handler is responsible\n        // for further cleanup.\n        socket.destroy(); // The connection has been safely closed by now.\n\n        state.isClosing = false;\n      });\n    },\n\n    /**\n     * Enables TLS on the underlying network socket.\n     * @private\n     * @function\n     * @name module:Connection#enableTLS\n     * @returns {Promise}\n     */\n    enableTLS() {\n      return new Promise(resolve => {\n        const secureContextOptions = Object.assign({}, state.tls); // We already know TLS should be enabled.\n\n        delete secureContextOptions.enabled; // We need to create a secure socket by providing the existing\n        // socket and the proper security context.\n\n        const nodeSocket = TLS.connect(Object.assign({}, {\n          socket: state.client.getConnection()\n        }, secureContext.create(secureContextOptions)));\n        nodeSocket.once('secureConnect', () => {\n          state.isSecure = true; // Once a TLS session is established, we need to\n          // update the socket reference.\n\n          state.client.setConnection(nodeSocket); // Then we are done and can move along.\n\n          resolve();\n        }); // We need to re-attach the event listener in order to\n        // be able to handle OpenSSL errors.\n\n        nodeSocket.once('error', err => {\n          state.error = err;\n        }); // The stream is paused when a secure connection is\n        // established in the socket, so we need to resume the\n        // flow. The handler should be the same.\n\n        nodeSocket.on('data', data => {\n          state.client.handleNetworkFragment(data);\n        });\n      });\n    },\n\n    /**\n     * Checks if there is any ongoing workload in the connection.\n     * @private\n     * @function\n     * @name module:Connection#isActive\n     * @returns {boolean}\n     */\n    isActive() {\n      return !!state.client && state.client.isRunning();\n    },\n\n    /**\n     * Checks of the connection is being closed.\n     * @private\n     * @function module:Connection#isClosing\n     * @returns {boolean}\n     */\n    isClosing() {\n      return state.isClosing;\n    },\n\n    /**\n     * Checks if the connection was created by a pool, which is never the\n     * case for this API.\n     * This method is overriden by {@link module:PoolConnection|PoolConnection}.\n     * @private\n     * @function\n     * @name module:Connection#isFromPool\n     * @returns {boolean} Returns false.\n     */\n    isFromPool() {\n      return false;\n    },\n\n    /**\n     * Checks if the connection is idle, which is never the case for this\n     * API.\n     * This method is overriden by {@link module:PoolConnection|PoolConnection}.\n     * @private\n     * @function\n     * @name module:Connection#isIdle\n     * @returns {boolean} Returns false.\n     */\n    isIdle() {\n      // Standalone connections never become idle on the client side.\n      return false;\n    },\n\n    /**\n     * Checks if a server-side X Protocol connecion has been sucessfuly\n     * established.\n     * @private\n     * @function\n     * @name module:Connection#isOpen\n     * @returns {boolean}\n     */\n    isOpen() {\n      return state.client !== null && state.serverId !== null;\n    },\n\n    /**\n     * Checks if we are in a middle of a connection retry.\n     * @private\n     * @function\n     * @name module:Connection#isReconnecting\n     * @returns {boolean}\n     */\n    isReconnecting() {\n      return state.retry;\n    },\n\n    /**\n     * Checks if the connection is using TLS.\n     * @private\n     * @function\n     * @name module:Connection#isSecure\n     * @returns {boolean}\n     */\n    isSecure() {\n      return state.isSecure;\n    },\n\n    /**\n     * Retrieves the name of the authentication mechanism that was\n     * negotiated with the server.\n     * @private\n     * @function\n     * @name module:Connection#getAuth\n     * @returns {string}\n     */\n    getAuth() {\n      // If an authentication mechanism is specified, we should try to\n      // use it.\n      if (state.auth) {\n        return state.auth;\n      } // If one is not specified and the connection is not secure, we\n      // should use a mechanism that works with most widespread plugin:\n      // \"mysql_native_password\".\n\n\n      if (!state.endpoints.available[0].socket && !state.tls.enabled) {\n        return 'MYSQL41';\n      } // If the connection is secure, we should opt for the fastest\n      // alternative which is sending credentials as clear text.\n\n\n      return 'PLAIN';\n    },\n\n    /**\n     * Retrieves the underlying X Protocol client instance.\n     * @private\n     * @function\n     * @name module:Connection#getClient\n     * @returns {Client}\n     */\n    getClient() {\n      return state.client;\n    },\n\n    /**\n     * Retrieves any error generated by the connection.\n     * @private\n     * @function\n     * @name module:Connection#getError\n     * @returns {Error}\n     */\n    getError() {\n      // It does not make sense to have a default error value as part of\n      // the connection state.\n      return state.error || new Error(errors.MESSAGES.ER_DEVAPI_CONNECTION_CLOSED);\n    },\n\n    /**\n     * Retrieves the list of client-side ids associated to server-side\n     * prepared statements created in the scope of the underlying X\n     * Protocol session.\n     * @private\n     * @function\n     * @name module:Connection#getPreparedStatements\n     * @returns {number[]}\n     */\n    getPreparedStatements() {\n      return state.statements;\n    },\n\n    /**\n     * Toggles the a flag to indicate the connection does not support\n     * server-side prepared statements.\n     * @private\n     * @function\n     * @name module:Connection#disablePreparedStatements\n     * @returns {module:Connection}\n     */\n    disablePreparedStatements() {\n      state.canPrepareStatements = false;\n      return this;\n    },\n\n    /**\n     * Removes a deallocated prepared statement for the list of statements\n     * associated to the X Protocol session.\n     * @private\n     * @function\n     * @name module:Connection#removePreparedStatement\n     * @param {number} id - the client-side prepared statement id\n     * @returns {module:Connection}\n     */\n    removePreparedStatement(id) {\n      state.statements[id - 1] = undefined;\n      return this;\n    },\n\n    /**\n     * Retrieves the hostname or IP (v4 or v6) address of the machine\n     * where the MySQL server is hosted.\n     * @private\n     * @function\n     * @name module:Connection#getServerHostname\n     * @returns {string}\n     */\n    getServerHostname() {\n      const endpoint = state.endpoints.available[0]; // Local socket file paths have precedence over host:port combos\n      // in the core Node.js APIs used to create a network socket.\n      // So, we want to make it clear that a Unix socket is being used\n      // in this case.\n\n      if (endpoint.socket) {\n        return;\n      }\n\n      return endpoint.host;\n    },\n\n    /**\n     * Retrieves the server-side connection id.\n     * @private\n     * @function\n     * @name module:Connection#getServerId\n     * @returns {number}\n     */\n    getServerId() {\n      return state.serverId;\n    },\n\n    /**\n     * Retrieves the port number where the server is listening for\n     * connections.\n     * @private\n     * @function\n     * @name module:Connection#getServerPort\n     * @returns {number}\n     */\n    getServerPort() {\n      const endpoint = state.endpoints.available[0]; // Local socket file paths have precedence over host:port combos\n      // in the core Node.js APIs used to create a network socket.\n      // So, we want to make it clear that a Unix socket is being used\n      // in this case.\n\n      if (endpoint.socket) {\n        return;\n      }\n\n      return endpoint.port;\n    },\n\n    /**\n     * Retrieves the path to the local Unix socket file used for\n     * connecting to the server.\n     * @private\n     * @function\n     * @name module:Connection#getServerSocketPath\n     * @returns {string}\n     */\n    getServerSocketPath() {\n      return state.endpoints.available[0].socket;\n    },\n\n    /**\n     * Retrieves the name of the default schema associated to the\n     * connection.\n     * @private\n     * @function\n     * @name module:Connection#getSchemaName\n     * @returns {string}\n     */\n    getSchemaName() {\n      return schema;\n    },\n\n    /**\n     * Retrieves the list of capabilities that are not known by the server.\n     * @private\n     * @function\n     * @name module:Connection#getUnknownCapabilities\n     * @returns {string[]}\n     */\n    getUnknownCapabilities() {\n      return state.unknownCapabilities;\n    },\n\n    /**\n     * Retrieves the MySQL account user associated to the connection.\n     * @private\n     * @function\n     * @name module:Connection#getUser\n     * @returns {string}\n     */\n    getUser() {\n      // TODO(Rui): \"dbUser\" is deprecated.\n      return user || dbUser || '';\n    },\n\n    /**\n     * Checks if the connection is using a custom authentication mechanism\n     * provided by the application.\n     * @private\n     * @function\n     * @name module:Connection#hasCustomAuthenticationMechanism\n     * @returns {boolean}\n     */\n    hasCustomAuthenticationMechanism() {\n      return !!auth;\n    },\n\n    /**\n     * Checks if there are endpoints available.\n     * @private\n     * @function\n     * @name module:Connection#hasMoreEndpointsAvailable\n     * @returns {boolean}\n     */\n    hasMoreEndpointsAvailable() {\n      // Make sure the list of available endpoints is up-to-date.\n      this.update(); // If there are available endpoints, we can perform a failover.\n\n      return state.endpoints.available.length > 0;\n    },\n\n    /**\n     * Checks if the connection was configured with multiple endpoints.\n     * @private\n     * @function\n     * @name module:Connection#hasMultipleEndpoints\n     * @returns {boolean}\n     */\n    hasMultipleEndpoints() {\n      return state.endpoints.available.length + state.endpoints.unavailable.length > 1;\n    },\n\n    /**\n     * Creates a new connection to a MySQL endpoint.\n     * @private\n     * @function\n     * @name module:Connection#open\n     * @returns {Promise<module:Connection>}\n     */\n    open() {\n      // Make sure the list of available endpoints is up-to-date.\n      this.update(); // If \"resolveSrv\" is disabled, it means we already have an\n      // ordered list of endpoints and we can try to connect to the\n      // first one.\n\n      if (!resolveSrv) {\n        // We sort the list of endpoints (one or more) according to\n        // the set of multi-host rules.\n        state.endpoints.available = multiHost.sort(state.endpoints.available);\n        return this.connect();\n      } // If \"resolveSrv\" is enabled, it means we need to retrieve the\n      // ordered list of endpoints from a discovery service potentially\n      // available at that host.\n\n\n      return srv.lookup(state.endpoints.available[0].host).then(endpoints => {\n        // We now have the effective ordered list of endpoints\n        // which we use to update the previous one.\n        state.endpoints.available = srv.sort(endpoints);\n        return this.connect();\n      });\n    },\n\n    /**\n     * Resets and re-uses the underlying X Protocol connection.\n     * @private\n     * @function\n     * @name module:Connection#override\n     * @returns {Promise<module:Connection>}\n     */\n    override() {\n      // A connection pool calls this method when it wants to re-use an\n      // existing connection.\n      return state.client.sessionReset().then(() => {\n        return this;\n      });\n    },\n\n    /**\n     * Resets the internal state of the connection.\n     * @private\n     * @function\n     * @name module:Connection#reset\n     * @returns {Promise<module:Connection>}\n     */\n    reset() {\n      // The connection capabilities will no longer be up-to-date.\n      state.capabilities = {}; // The client instance contains the work queue, which might not be\n      // empty, and needs to be dereferenced anyway.\n\n      state.client = null; // The connection is not closing anymore.\n\n      state.isClosing = false; // An existing server connection id is what tells if a connection\n      // has been successfully established, so we need to deference it\n      // as well, since the connection is closed by this point.\n\n      state.serverId = null; // Any existing references to prepared statements associated to\n      // the connection should be removed.\n\n      state.statements = []; // Any unknown capabilities are also no longer valid.\n\n      state.unknownCapabilities = []; // The connection has closed, so there are no retries left.\n\n      state.retry = false;\n      return this;\n    },\n\n    /**\n     * Updates the underlying X Protocol client instance.\n     * @private\n     * @function\n     * @name module:Connection#setClient\n     * @returns {Promise<module:Connection>}\n     */\n    setClient(client) {\n      state.client = client;\n      return this;\n    },\n\n    /**\n     * Executes the pipeline for creating a server-side X Protocol session.\n     * @private\n     * @function\n     * @name module:Connection#start\n     * @returns {Promise<module:Connection>}\n     */\n    start() {\n      // Start the pipeline to create a new MySQL server session.\n      return this.capabilitiesSet().then(capabilities => {\n        // If TLS should be disabled, there is nothing else to do\n        // and we can proceed with the next pipeline stage.\n        if (!capabilities.tls) {\n          return;\n        } // Otherwise, we need to create a secure socket.\n\n\n        return this.enableTLS();\n      }).then(() => {\n        return this.capabilitiesGet();\n      }).then(capabilities => {\n        // We should save the effective list of capabilities\n        // negotiated with the server.\n        return this.addCapabilities(capabilities);\n      }).then(() => {\n        // Then we proceed to authenticate the user.\n        return this.authenticate();\n      });\n    },\n\n    /**\n     * Updates the availability of the possible MySQL endpoints specified\n     * for the connection.\n     * @private\n     * @function\n     * @name module:Connection#update\n     * @returns {module:Connection}\n     */\n    update() {\n      const now = Date.now(); // Check which unavailable endpoints can be re-tried.\n      // If the current element in the list is not \"retryable\", neither\n      // are the remaining. A retryable endpoint is any endpoint that has\n      // been unavailable since at least the time interval defined by\n      // state.retryAfter.\n\n      while (state.endpoints.unavailable.length && now - state.endpoints.unavailable[0].unavailableAt > state.retryAfter) {\n        // If an endpoint can be re-tried we need to move it back to\n        // the list of available endpoints.\n        state.endpoints.available.push(state.endpoints.unavailable.shift());\n      }\n\n      return this;\n    }\n\n  };\n}\n\nConnection.validate = function (_ref2) {\n  let {\n    connectionAttributes,\n    connectTimeout,\n    dbUser,\n    dbPassword,\n    endpoints,\n    host,\n    port,\n    resolveSrv,\n    socket,\n    ssl,\n    sslOptions,\n    tls\n  } = _ref2;\n  // TODO(Rui): Remove after deprecation period (undetermined).\n  deprecate({\n    dbUser,\n    dbPassword,\n    ssl,\n    sslOptions\n  });\n  const ports = endpoints && endpoints.length ? endpoints.map(e => e.port) : [port]; // The port must be an integer between 0 and 65536.\n\n  if (ports.some(p => !isValidInteger({\n    value: p,\n    min: 0,\n    max: 65536\n  }))) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_CONNECTION_PORT_RANGE);\n  } // We delegate validation of the TLS-related options to the secureContext\n  // module.\n\n\n  secureContext.validate({\n    tls,\n    ssl,\n    sslOptions\n  }); // The value of \"connectTimeout\" should be used to set the TCP\n  // socket timeout and must be a positive integer (including 0).\n\n  if (!isValidInteger({\n    value: connectTimeout,\n    min: 0\n  })) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_CONNECTION_TIMEOUT);\n  } // If the custom application attributes are \"undefined\", we still\n  // need to send the default client attributes to the server.\n  // Otherwise, the custom application attributes must be defined\n  // using a plain JavaScript object, false if they are to be\n  // disabled or true, if they are to be ignored.\n\n\n  if (!isValidBoolean({\n    value: connectionAttributes\n  }) && !isValidPlainObject({\n    value: connectionAttributes\n  })) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_SESSION_ATTRIBUTES_DEFINITION);\n  } // If there are custom application attributes we need to validate their\n  // name. Before doing that, we need to make sure we are not bothered by \"undefined\".\n\n\n  if (Object.keys(Object.assign({}, connectionAttributes)).some(key => key.startsWith('_'))) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_SESSION_ATTRIBUTE_NAME);\n  } // We delegate validation of the SRV-related options to the srv module.\n\n\n  srv.validate({\n    resolveSrv,\n    endpoints,\n    host,\n    port,\n    socket\n  });\n  return true;\n};\n\nConnection.VALID_OPTIONS = VALID_OPTIONS;\nConnection.CLIENT_SESSION_ATTRIBUTES = CLIENT_SESSION_ATTRIBUTES;\nmodule.exports = Connection;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/DevAPI/Connection.js"],"names":["Client","require","Net","TLS","authenticationManager","errors","logger","multiHost","pkg","secureContext","srv","system","util","warnings","isValidBoolean","isValidInteger","isValidPlainObject","VALID_OPTIONS","CLIENT_SESSION_ATTRIBUTES","_pid","pid","_platform","platform","_os","brand","_source_host","hostname","_client_name","name","_client_version","version","_client_license","license","stringifyValues","obj","root","JSON","stringify","k","v","deprecate","dbPassword","dbUser","ssl","sslOptions","log","warning","MESSAGES","WARN_DEPRECATED_DB_PASSWORD","type","TYPES","DEPRECATION","code","CODES","WARN_DEPRECATED_DB_USER","WARN_DEPRECATED_SSL_OPTION","WARN_DEPRECATED_SSL_ADDITIONAL_OPTIONS","Connection","auth","connectionAttributes","connectTimeout","endpoints","host","password","port","schema","socket","resolveSrv","tls","user","state","canPrepareStatements","capabilities","client","available","length","unavailable","isClosing","isSecure","retry","retryAfter","serverId","statements","Object","assign","enabled","unknownCapabilities","addCapabilities","allowsAuthenticationRetry","hasCustomAuthenticationMechanism","allowsAuthenticationWith","mechanism","serverSupportedMechanisms","concat","indexOf","authenticate","getAuth","message","format","ER_DEVAPI_AUTH_UNSUPPORTED_SERVER","error","Error","info","ER_ACCESS_DENIED_ERROR","msg","Promise","reject","authenticateWith","catch","err","ER_DEVAPI_AUTH_MORE_INFO","plugin","getPlugin","theUser","getUser","thePassword","run","then","session","connectionId","capabilitiesGet","capabilitiesSet","attributes","session_connect_attrs","parse","ER_X_CAPABILITIES_PREPARE_FAILED","failedCapability","match","ER_DEVAPI_NO_SERVER_TLS","ER_X_CAPABILITY_NOT_FOUND","unknownCapability","push","getConnection","destroy","close","connect","resolve","endpoint","nodeSocket","path","setTimeout","postConnect","connection","postDisconnect","reset","once","start","hasMultipleEndpoints","ER_DEVAPI_CONNECTION_TIMEOUT","ER_DEVAPI_MULTI_HOST_CONNECTION_TIMEOUT","on","data","handleNetworkFragment","hasError","isOpen","isActive","handleServerClose","shift","unavailableAt","Date","now","getError","hasMoreEndpointsAvailable","errno","ER_DEVAPI_MULTI_HOST_CONNECTION_FAILED","destroyed","connectionClose","enableTLS","secureContextOptions","create","setConnection","isRunning","isFromPool","isIdle","isReconnecting","getClient","ER_DEVAPI_CONNECTION_CLOSED","getPreparedStatements","disablePreparedStatements","removePreparedStatement","id","undefined","getServerHostname","getServerId","getServerPort","getServerSocketPath","getSchemaName","getUnknownCapabilities","update","open","sort","lookup","override","sessionReset","setClient","validate","ports","map","e","some","p","value","min","max","ER_DEVAPI_BAD_CONNECTION_PORT_RANGE","ER_DEVAPI_BAD_CONNECTION_TIMEOUT","ER_DEVAPI_BAD_SESSION_ATTRIBUTES_DEFINITION","keys","key","startsWith","ER_DEVAPI_BAD_SESSION_ATTRIBUTE_NAME","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,KAAD,CAAnB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,KAAD,CAAnB;;AACA,MAAMG,qBAAqB,GAAGH,OAAO,CAAC,yCAAD,CAArC;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,qBAAD,CAAtB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,wBAAD,CAAzB;;AACA,MAAMO,GAAG,GAAGP,OAAO,CAAC,YAAD,CAAnB;;AACA,MAAMQ,aAAa,GAAGR,OAAO,CAAC,uBAAD,CAA7B;;AACA,MAAMS,GAAG,GAAGT,OAAO,CAAC,qBAAD,CAAnB;;AACA,MAAMU,MAAM,GAAGV,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMW,IAAI,GAAGX,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMY,QAAQ,GAAGZ,OAAO,CAAC,uBAAD,CAAxB;;AACA,MAAM;AAAEa,EAAAA,cAAF;AAAkBC,EAAAA,cAAlB;AAAkCC,EAAAA;AAAlC,IAAyDf,OAAO,CAAC,cAAD,CAAtE;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMgB,aAAa,GAAG,CAClB,MADkB,EAElB,gBAFkB,EAGlB,sBAHkB,EAIlB,YAJkB,EAIJ;AACd,QALkB,EAKR;AACV,WANkB,EAOlB,MAPkB,EAQlB,UARkB,EASlB,MATkB,EAUlB,YAVkB,EAWlB,QAXkB,EAYlB,QAZkB,EAalB,KAbkB,EAaX;AACP,YAdkB,EAcJ;AACd,KAfkB,EAgBlB,MAhBkB,CAAtB;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,yBAAyB,GAAG;AAC9BC,EAAAA,IAAI,EAAER,MAAM,CAACS,GAAP,EADwB;AAE9BC,EAAAA,SAAS,EAAEV,MAAM,CAACW,QAAP,EAFmB;AAG9BC,EAAAA,GAAG,EAAEZ,MAAM,CAACa,KAAP,EAHyB;AAI9BC,EAAAA,YAAY,EAAEd,MAAM,CAACe,QAAP,EAJgB;AAK9BC,EAAAA,YAAY,EAAEnB,GAAG,CAACoB,IAAJ,EALgB;AAM9BC,EAAAA,eAAe,EAAErB,GAAG,CAACsB,OAAJ,EANa;AAO9BC,EAAAA,eAAe,EAAEvB,GAAG,CAACwB,OAAJ;AAPa,CAAlC;AAUA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,eAAT,GAAoC;AAAA,MAAVC,GAAU,uEAAJ,EAAI;AAChC,MAAIC,IAAI,GAAG,IAAX;AAEA,SAAOC,IAAI,CAACC,SAAL,CAAeH,GAAf,EAAoB,CAACI,CAAD,EAAIC,CAAJ,KAAU;AACjC;AACA,QAAIJ,IAAJ,EAAU;AACNA,MAAAA,IAAI,GAAG,KAAP;AACA,aAAOI,CAAP;AACH,KALgC,CAOjC;AACA;AACA;AACA;AACA;;;AACA,QAAI,OAAOA,CAAP,KAAa,WAAb,IAA4BA,CAAC,KAAK,IAAtC,EAA4C;AACxC,aAAO,EAAP;AACH,KAdgC,CAgBjC;;;AACA,QAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACvB,aAAOA,CAAP;AACH,KAnBgC,CAqBjC;AACA;;;AACA,QAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACvB,aAAOH,IAAI,CAACC,SAAL,CAAeE,CAAf,CAAP;AACH,KAzBgC,CA2BjC;;;AACA,WAAON,eAAe,CAACM,CAAD,CAAtB;AACH,GA7BM,CAAP;AA8BH;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,SAAT,OAA6D;AAAA,MAAzC;AAAEC,IAAAA,UAAF;AAAcC,IAAAA,MAAd;AAAsBC,IAAAA,GAAtB;AAA2BC,IAAAA;AAA3B,GAAyC;AACzD,QAAMC,GAAG,GAAGvC,MAAM,CAAC,oBAAD,CAAlB,CADyD,CAGzD;;AACA,MAAI,OAAOmC,UAAP,KAAsB,WAA1B,EAAuC;AACnCI,IAAAA,GAAG,CAACC,OAAJ,CAAY,YAAZ,EAA0BjC,QAAQ,CAACkC,QAAT,CAAkBC,2BAA5C,EAAyE;AACrEC,MAAAA,IAAI,EAAEpC,QAAQ,CAACqC,KAAT,CAAeC,WADgD;AAErEC,MAAAA,IAAI,EAAEvC,QAAQ,CAACwC,KAAT,CAAeF;AAFgD,KAAzE;AAIH,GATwD,CAWzD;;;AACA,MAAI,OAAOT,MAAP,KAAkB,WAAtB,EAAmC;AAC/BG,IAAAA,GAAG,CAACC,OAAJ,CAAY,QAAZ,EAAsBjC,QAAQ,CAACkC,QAAT,CAAkBO,uBAAxC,EAAiE;AAC7DL,MAAAA,IAAI,EAAEpC,QAAQ,CAACqC,KAAT,CAAeC,WADwC;AAE7DC,MAAAA,IAAI,EAAEvC,QAAQ,CAACwC,KAAT,CAAeF;AAFwC,KAAjE;AAIH,GAjBwD,CAmBzD;;;AACA,MAAI,OAAOR,GAAP,KAAe,WAAnB,EAAgC;AAC5BE,IAAAA,GAAG,CAACC,OAAJ,CAAY,KAAZ,EAAmBjC,QAAQ,CAACkC,QAAT,CAAkBQ,0BAArC,EAAiE;AAC7DN,MAAAA,IAAI,EAAEpC,QAAQ,CAACqC,KAAT,CAAeC,WADwC;AAE7DC,MAAAA,IAAI,EAAEvC,QAAQ,CAACwC,KAAT,CAAeF;AAFwC,KAAjE;AAIH;;AAED,MAAI,OAAOP,UAAP,KAAsB,WAA1B,EAAuC;AACnCC,IAAAA,GAAG,CAACC,OAAJ,CAAY,YAAZ,EAA0BjC,QAAQ,CAACkC,QAAT,CAAkBS,sCAA5C,EAAoF;AAChFP,MAAAA,IAAI,EAAEpC,QAAQ,CAACqC,KAAT,CAAeC,WAD2D;AAEhFC,MAAAA,IAAI,EAAEvC,QAAQ,CAACwC,KAAT,CAAeF;AAF2D,KAApF;AAIH;;AAED,SAAO,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASM,UAAT,GAAsP;AAAA,MAAjO;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,oBAAoB,GAAG,EAA/B;AAAmCC,IAAAA,cAAc,GAAG,KAApD;AAA2DnB,IAAAA,UAA3D;AAAuEC,IAAAA,MAAvE;AAA+EmB,IAAAA,SAAS,GAAG,EAA3F;AAA+FC,IAAAA,IAAI,GAAG,WAAtG;AAAmHC,IAAAA,QAAQ,GAAG,EAA9H;AAAkIC,IAAAA,IAAI,GAAG,KAAzI;AAAgJC,IAAAA,MAAhJ;AAAwJC,IAAAA,MAAxJ;AAAgKC,IAAAA,UAAU,GAAG,KAA7K;AAAoLxB,IAAAA,GAApL;AAAyLC,IAAAA,UAAzL;AAAqMwB,IAAAA,GAAG,GAAG,EAA3M;AAA+MC,IAAAA,IAAI,GAAG;AAAtN,GAAiO,uEAAJ,EAAI;AAClP;AACA,QAAMC,KAAK,GAAG;AACV;AACA;AACAZ,IAAAA,IAHU;AAIV;AACA;AACAa,IAAAA,oBAAoB,EAAE,IANZ;AAOV;AACA;AACAC,IAAAA,YAAY,EAAE,EATJ;AAUV;AACAC,IAAAA,MAAM,EAAE,IAXE;AAYV;AACA;AACAZ,IAAAA,SAAS,EAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACAa,MAAAA,SAAS,EAAEb,SAAS,CAACc,MAAV,GAAmBd,SAAnB,GAA+B,CAAC;AAAEC,QAAAA,IAAF;AAAQE,QAAAA,IAAR;AAAcE,QAAAA;AAAd,OAAD,CARnC;AASPU,MAAAA,WAAW,EAAE;AATN,KAdD;AAyBV;AACAC,IAAAA,SAAS,EAAE,KA1BD;AA2BV;AACA;AACAC,IAAAA,QAAQ,EAAE,KA7BA;AA8BV;AACAC,IAAAA,KAAK,EAAE,KA/BG;AAgCV;AACA;AACAC,IAAAA,UAAU,EAAE,KAlCF;AAmCV;AACAC,IAAAA,QAAQ,EAAE,IApCA;AAqCV;AACA;AACAC,IAAAA,UAAU,EAAE,EAvCF;AAwCV;AACA;AACA;AACA;AACA;AACA;AACAd,IAAAA,GAAG,EAAEe,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB;AAAEC,MAAAA,OAAO,EAAE1C,GAAG,KAAK,KAAR,GAAgBA,GAAhB,GAAsB;AAAjC,KAAlB,EAA2DC,UAA3D,EAAuEwB,GAAvE,CA9CK;AA+CV;AACAkB,IAAAA,mBAAmB,EAAE;AAhDX,GAAd;AAmDA,SAAO;AACH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQC,IAAAA,eAAe,CAAEf,YAAF,EAAgB;AAC3BF,MAAAA,KAAK,CAACE,YAAN,GAAqBW,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBd,KAAK,CAACE,YAAxB,EAAsCA,YAAtC,CAArB;AAEA,aAAO,IAAP;AACH,KAbE;;AAeH;AACR;AACA;AACA;AACA;AACA;AACA;AACQgB,IAAAA,yBAAyB,GAAI;AACzB;AACA;AACA,UAAI,KAAKC,gCAAL,EAAJ,EAA6C;AACzC,eAAO,KAAP;AACH,OALwB,CAOzB;AACA;AACA;;;AACA,UAAInB,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0B,CAA1B,EAA6BR,MAA7B,IAAuCI,KAAK,CAACF,GAAN,CAAUiB,OAArD,EAA8D;AAC1D,eAAO,KAAP;AACH,OAZwB,CAczB;AACA;;;AACA,aAAO,KAAKK,wBAAL,CAA8B,eAA9B,CAAP;AACH,KAvCE;;AAyCH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQA,IAAAA,wBAAwB,CAAEC,SAAF,EAAa;AACjC;AACA;AACA;AACA,YAAMC,yBAAyB,GAAG,CAACtB,KAAK,CAACE,YAAN,CAAmB,2BAAnB,KAAmD,EAApD,EAAwDqB,MAAxD,CAA+D,OAA/D,CAAlC;AAEA,aAAOD,yBAAyB,CAACE,OAA1B,CAAkCH,SAAlC,IAA+C,CAAC,CAAvD;AACH,KAzDE;;AA2DH;AACR;AACA;AACA;AACA;AACA;AACA;AACQI,IAAAA,YAAY,GAAI;AACZ;AACA;AACA,YAAMJ,SAAS,GAAG,KAAKK,OAAL,EAAlB;;AAEA,UAAI,CAAC,KAAKN,wBAAL,CAA8BC,SAA9B,CAAL,EAA+C;AAC3C,cAAMM,OAAO,GAAGrF,IAAI,CAACsF,MAAL,CAAY7F,MAAM,CAAC0C,QAAP,CAAgBoD,iCAA5B,EAA+DR,SAA/D,CAAhB;AACA,cAAMS,KAAK,GAAG,IAAIC,KAAJ,CAAUJ,OAAV,CAAd;AACAG,QAAAA,KAAK,CAACE,IAAN,GAAa;AAAElD,UAAAA,IAAI,EAAE/C,MAAM,CAACkG,sBAAf;AAAuCC,UAAAA,GAAG,EAAEP;AAA5C,SAAb;AAEA,eAAOQ,OAAO,CAACC,MAAR,CAAeN,KAAf,CAAP;AACH;;AAED,aAAO,KAAKO,gBAAL,CAAsBhB,SAAtB,EACFiB,KADE,CACIC,GAAG,IAAI;AACV;AACA;AACA;AACA,YAAI,CAAC,KAAKrB,yBAAL,EAAD,IAAsCqB,GAAG,CAACP,IAAJ,IAAYO,GAAG,CAACP,IAAJ,CAASlD,IAAT,KAAkB/C,MAAM,CAACkG,sBAA/E,EAAwG;AACpG,gBAAMM,GAAN;AACH,SANS,CAQV;AACA;;;AACA,eAAO,KAAKF,gBAAL,CAAsB,eAAtB,EACFC,KADE,CACIC,GAAG,IAAI;AACV;AACA;AACA,cAAIA,GAAG,CAACP,IAAJ,IAAYO,GAAG,CAACP,IAAJ,CAASlD,IAAT,KAAkB/C,MAAM,CAACkG,sBAAzC,EAAiE;AAC7D,kBAAMM,GAAN;AACH,WALS,CAOV;;;AACAA,UAAAA,GAAG,CAACZ,OAAJ,GAAcY,GAAG,CAACP,IAAJ,CAASE,GAAT,GAAenG,MAAM,CAAC0C,QAAP,CAAgB+D,wBAA7C;AAEA,gBAAMD,GAAN;AACH,SAZE,CAAP;AAaH,OAxBE,CAAP;AAyBH,KAxGE;;AA0GH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQF,IAAAA,gBAAgB,CAAEhB,SAAF,EAAa;AACzB,YAAMoB,MAAM,GAAG3G,qBAAqB,CAAC4G,SAAtB,CAAgCrB,SAAhC,CAAf;AACA,YAAMsB,OAAO,GAAG,KAAKC,OAAL,EAAhB,CAFyB,CAGzB;AACA;;AACA,YAAMC,WAAW,GAAGpD,QAAQ,IAAItB,UAAZ,IAA0B,EAA9C;AAEA,aAAOsE,MAAM,CAAC;AAAEhD,QAAAA,QAAQ,EAAEoD,WAAZ;AAAyBlD,QAAAA,MAAzB;AAAiCI,QAAAA,IAAI,EAAE4C;AAAvC,OAAD,CAAN,CAAyDG,GAAzD,CAA6D9C,KAAK,CAACG,MAAnE,EACF4C,IADE,CACGC,OAAO,IAAI;AACbhD,QAAAA,KAAK,CAACZ,IAAN,GAAaiC,SAAb;AACArB,QAAAA,KAAK,CAACW,QAAN,GAAiBqC,OAAO,CAACC,YAAzB;AAEA,eAAO,IAAP;AACH,OANE,CAAP;AAOH,KAjIE;;AAmIH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQC,IAAAA,eAAe,GAAI;AACf,aAAOlD,KAAK,CAACG,MAAN,CAAa+C,eAAb,EAAP;AACH,KA7IE;;AA+IH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQC,IAAAA,eAAe,GAAI;AACf;AACA;AACA,YAAMjD,YAAY,GAAG,EAArB,CAHe,CAKf;AACA;;AACA,UAAIF,KAAK,CAACF,GAAN,CAAUiB,OAAV,KAAsB,IAAtB,IAA8B,CAACf,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0B,CAA1B,EAA6BR,MAAhE,EAAwE;AACpE;AACAM,QAAAA,YAAY,CAACJ,GAAb,GAAmB,IAAnB;AACH,OAVc,CAYf;AACA;AACA;AACA;;;AACA,UAAIT,oBAAoB,KAAK,KAAzB,IAAkCW,KAAK,CAACgB,mBAAN,CAA0BQ,OAA1B,CAAkC,uBAAlC,MAA+D,CAAC,CAAtG,EAAyG;AACrG,cAAM4B,UAAU,GAAGvC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBlE,yBAAlB,EAA6CyC,oBAA7C,CAAnB,CADqG,CAErG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAa,QAAAA,YAAY,CAACmD,qBAAb,GAAqCvF,IAAI,CAACwF,KAAL,CAAW3F,eAAe,CAACyF,UAAD,CAA1B,CAArC;AACH;;AAED,aAAOpD,KAAK,CAACG,MAAN,CAAagD,eAAb,CAA6BjD,YAA7B,EACF6C,IADE,CACG,MAAM;AACR;AACA;AACA,eAAO7C,YAAP;AACH,OALE,EAMFoC,KANE,CAMIC,GAAG,IAAI;AACV;AACA;AACA,YAAIA,GAAG,CAACP,IAAJ,IAAYO,GAAG,CAACP,IAAJ,CAASlD,IAAT,KAAkB/C,MAAM,CAACwH,gCAAzC,EAA2E;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAMC,gBAAgB,GAAGjB,GAAG,CAACZ,OAAJ,CAAY8B,KAAZ,CAAkB,2CAAlB,EAA+D,CAA/D,CAAzB,CARuE,CASvE;AACA;;AAEA,cAAID,gBAAgB,KAAK,KAAzB,EAAgC;AAC5B,kBAAMjB,GAAN;AACH,WAdsE,CAgBvE;;;AACA,gBAAMZ,OAAO,GAAG5F,MAAM,CAAC0C,QAAP,CAAgBiF,uBAAhC;AACAnB,UAAAA,GAAG,CAACZ,OAAJ,GAAcA,OAAd;AACAY,UAAAA,GAAG,CAACP,IAAJ,CAASE,GAAT,GAAeP,OAAf;AAEA,gBAAMY,GAAN;AACH,SAzBS,CA2BV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,YAAI,CAACA,GAAG,CAACP,IAAL,IAAaO,GAAG,CAACP,IAAJ,CAASlD,IAAT,KAAkB/C,MAAM,CAAC4H,yBAA1C,EAAqE;AACjE,gBAAMpB,GAAN;AACH,SAtCS,CAwCV;AACA;AACA;AACA;AACA;AACA;;;AACA,cAAMqB,iBAAiB,GAAGrB,GAAG,CAACZ,OAAJ,CAAY8B,KAAZ,CAAkB,wBAAlB,EAA4C,CAA5C,CAA1B;AACAzD,QAAAA,KAAK,CAACgB,mBAAN,CAA0B6C,IAA1B,CAA+BD,iBAA/B,EA/CU,CAiDV;AACA;AACA;AACA;;AACA5D,QAAAA,KAAK,CAACS,KAAN,GAAc,IAAd;AAEA,cAAMb,MAAM,GAAGI,KAAK,CAACG,MAAN,CAAa2D,aAAb,EAAf;AACAlE,QAAAA,MAAM,CAACmE,OAAP,CAAexB,GAAf;AACH,OA/DE,CAAP;AAgEH,KApPE;;AAsPH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQyB,IAAAA,KAAK,GAAI;AACL,aAAO,KAAKD,OAAL,EAAP;AACH,KAjQE;;AAmQH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQE,IAAAA,OAAO,GAAI;AACP,aAAO,IAAI9B,OAAJ,CAAY,CAAC+B,OAAD,EAAU9B,MAAV,KAAqB;AACpC;AACA,cAAM+B,QAAQ,GAAGnE,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0B,CAA1B,CAAjB,CAFoC,CAGpC;AACA;AACA;;AACA,cAAMgE,UAAU,GAAGxI,GAAG,CAACqI,OAAJ,CAAY;AAAEzE,UAAAA,IAAI,EAAE2E,QAAQ,CAAC3E,IAAT,IAAiB,WAAzB;AAAsCE,UAAAA,IAAI,EAAEyE,QAAQ,CAACzE,IAAT,IAAiB,KAA7D;AAAoE2E,UAAAA,IAAI,EAAEF,QAAQ,CAACvE;AAAnF,SAAZ,CAAnB;AAEAwE,QAAAA,UAAU,CAACE,UAAX,CAAsBhF,cAAtB,EARoC,CAUpC;AACA;;AACA,cAAMiF,WAAW,GAAGC,UAAU,IAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACAJ,UAAAA,UAAU,CAACE,UAAX,CAAsB,CAAtB;AACA,iBAAOJ,OAAO,CAACM,UAAD,CAAd;AACH,SATD,CAZoC,CAuBpC;AACA;;;AACA,cAAMC,cAAc,GAAGlC,GAAG,IAAI;AAC1B;AACA,eAAKmC,KAAL,GAF0B,CAI1B;AACA;AACA;AACA;;AACA,cAAI,CAACnC,GAAL,EAAU;AACN,mBAAO2B,OAAO,EAAd;AACH,WAVyB,CAY1B;AACA;AACA;;;AACA,iBAAO9B,MAAM,CAACG,GAAD,CAAb;AACH,SAhBD,CAzBoC,CA2CpC;AACA;AACA;;;AACA6B,QAAAA,UAAU,CAACO,IAAX,CAAgB,OAAhB,EAAyB,MAAM;AAC3B;AACA;AACA;AACA;AACA3E,UAAAA,KAAK,CAACG,MAAN,GAAe,IAAIzE,MAAJ,CAAW0I,UAAX,CAAf,CAL2B,CAO3B;AACA;;AACA,iBAAO,KAAKQ,KAAL,GAAa7B,IAAb,CAAkBwB,WAAlB,EAA+BjC,KAA/B,CAAqCC,GAAG,IAAI6B,UAAU,CAACL,OAAX,CAAmBxB,GAAnB,CAA5C,CAAP;AACH,SAVD;AAYA6B,QAAAA,UAAU,CAACO,IAAX,CAAgB,OAAhB,EAAyBpC,GAAG,IAAI;AAC5B;AACAvC,UAAAA,KAAK,CAAC8B,KAAN,GAAcS,GAAd;AACH,SAHD;AAKA6B,QAAAA,UAAU,CAACO,IAAX,CAAgB,SAAhB,EAA2B,MAAM;AAC7B,gBAAM7C,KAAK,GAAG,IAAIC,KAAJ,EAAd;AACAD,UAAAA,KAAK,CAACxE,IAAN,GAAa,WAAb,CAF6B,CAI7B;AACA;;AACA,cAAI,CAAC,KAAKuH,oBAAL,EAAL,EAAkC;AAC9B/C,YAAAA,KAAK,CAACH,OAAN,GAAgBrF,IAAI,CAACsF,MAAL,CAAY7F,MAAM,CAAC0C,QAAP,CAAgBqG,4BAA5B,EAA0DxF,cAA1D,CAAhB;AACH,WAFD,MAEO;AACHwC,YAAAA,KAAK,CAACH,OAAN,GAAgBrF,IAAI,CAACsF,MAAL,CAAY7F,MAAM,CAAC0C,QAAP,CAAgBsG,uCAA5B,EAAqEzF,cAArE,CAAhB;AACH,WAV4B,CAY7B;AACA;;;AACA8E,UAAAA,UAAU,CAACL,OAAX,CAAmBjC,KAAnB;AACH,SAfD;AAiBAsC,QAAAA,UAAU,CAACY,EAAX,CAAc,MAAd,EAAsBC,IAAI,IAAI;AAC1BjF,UAAAA,KAAK,CAACG,MAAN,CAAa+E,qBAAb,CAAmCD,IAAnC;AACH,SAFD;AAIAb,QAAAA,UAAU,CAACO,IAAX,CAAgB,OAAhB,EAAyBQ,QAAQ,IAAI;AACjC;AACA;AACA;AACA,cAAI,CAACA,QAAD,IAAa,KAAKC,MAAL,EAAb,IAA8B,KAAKC,QAAL,EAAlC,EAAmD;AAC/C;AACA,mBAAOrF,KAAK,CAACG,MAAN,CAAamF,iBAAb,EAAP;AACH,WAPgC,CASjC;AACA;AACA;AACA;AACA;;;AACA,cAAI,CAACH,QAAD,IAAa,KAAKC,MAAL,EAAjB,EAAgC;AAC5B;AACA,mBAAOX,cAAc,EAArB;AACH,WAjBgC,CAmBjC;AACA;AACA;AACA;AACA;;;AACA,cAAI,CAACzE,KAAK,CAACS,KAAX,EAAkB;AACd;AACA;AACA,kBAAMH,WAAW,GAAGO,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBd,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0BmF,KAA1B,EAAlB,EAAqD;AACrEC,cAAAA,aAAa,EAAEC,IAAI,CAACC,GAAL;AADsD,aAArD,CAApB;AAIA1F,YAAAA,KAAK,CAACT,SAAN,CAAgBe,WAAhB,CAA4BuD,IAA5B,CAAiCvD,WAAjC;AACH,WAhCgC,CAkCjC;AACA;;;AACAN,UAAAA,KAAK,CAACS,KAAN,GAAc,KAAd,CApCiC,CAsCjC;AACA;AACA;;AACA,gBAAMqB,KAAK,GAAG,KAAK6D,QAAL,EAAd,CAzCiC,CA2CjC;AACA;;AACA,cAAI,CAAC,KAAKC,yBAAL,EAAD,KAAsC,CAAC,KAAKf,oBAAL,EAAD,IAAgC/C,KAAK,CAACxE,IAAN,KAAe,WAArF,CAAJ,EAAuG;AACnG,mBAAOmH,cAAc,CAAC3C,KAAD,CAArB;AACH,WA/CgC,CAiDjC;AACA;AACA;;;AACA,cAAI,CAAC,KAAK8D,yBAAL,EAAD,IAAqC,KAAKf,oBAAL,EAAzC,EAAsE;AAClE/C,YAAAA,KAAK,CAACxE,IAAN,GAAa,cAAb;AACAwE,YAAAA,KAAK,CAAC+D,KAAN,GAAc9J,MAAM,CAAC+J,sCAArB;AACAhE,YAAAA,KAAK,CAACH,OAAN,GAAgB5F,MAAM,CAAC0C,QAAP,CAAgBqH,sCAAhC;AAEA,mBAAOrB,cAAc,CAAC3C,KAAD,CAArB;AACH,WA1DgC,CA4DjC;AACA;AACA;AACA;;;AACA,eAAKmC,OAAL,GAAelB,IAAf,CAAoBwB,WAApB,EAAiCjC,KAAjC,CAAuCmC,cAAvC;AACH,SAjED;AAkEH,OAtJM,CAAP;AAuJH,KAnaE;;AAqaH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQV,IAAAA,OAAO,GAAI;AACP;AACA;AACA;AACA,UAAI,CAAC,KAAKqB,MAAL,EAAD,IAAkBpF,KAAK,CAACO,SAA5B,EAAuC;AACnC,eAAO4B,OAAO,CAAC+B,OAAR,EAAP;AACH;;AAED,YAAMtE,MAAM,GAAGI,KAAK,CAACG,MAAN,CAAa2D,aAAb,EAAf,CARO,CAUP;AACA;;AACA,UAAIlE,MAAM,CAACmG,SAAX,EAAsB;AAClB,eAAO5D,OAAO,CAAC+B,OAAR,EAAP;AACH,OAdM,CAgBP;AACA;AACA;AACA;;;AACAlE,MAAAA,KAAK,CAACO,SAAN,GAAkB,IAAlB,CApBO,CAsBP;AACA;;AACA,aAAOP,KAAK,CAACG,MAAN,CAAa6F,eAAb,GACFjD,IADE,CACG,MAAM;AACR;AACA;AACA;AACA;AACAnD,QAAAA,MAAM,CAACmE,OAAP,GALQ,CAOR;;AACA/D,QAAAA,KAAK,CAACO,SAAN,GAAkB,KAAlB;AACH,OAVE,CAAP;AAWH,KAhdE;;AAkdH;AACR;AACA;AACA;AACA;AACA;AACA;AACQ0F,IAAAA,SAAS,GAAI;AACT,aAAO,IAAI9D,OAAJ,CAAY+B,OAAO,IAAI;AAC1B,cAAMgC,oBAAoB,GAAGrF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBd,KAAK,CAACF,GAAxB,CAA7B,CAD0B,CAE1B;;AACA,eAAOoG,oBAAoB,CAACnF,OAA5B,CAH0B,CAI1B;AACA;;AACA,cAAMqD,UAAU,GAAGvI,GAAG,CAACoI,OAAJ,CAAYpD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB;AAAElB,UAAAA,MAAM,EAAEI,KAAK,CAACG,MAAN,CAAa2D,aAAb;AAAV,SAAlB,EAA4D3H,aAAa,CAACgK,MAAd,CAAqBD,oBAArB,CAA5D,CAAZ,CAAnB;AAEA9B,QAAAA,UAAU,CAACO,IAAX,CAAgB,eAAhB,EAAiC,MAAM;AACnC3E,UAAAA,KAAK,CAACQ,QAAN,GAAiB,IAAjB,CADmC,CAEnC;AACA;;AACAR,UAAAA,KAAK,CAACG,MAAN,CAAaiG,aAAb,CAA2BhC,UAA3B,EAJmC,CAKnC;;AACAF,UAAAA,OAAO;AACV,SAPD,EAR0B,CAiB1B;AACA;;AACAE,QAAAA,UAAU,CAACO,IAAX,CAAgB,OAAhB,EAAyBpC,GAAG,IAAI;AAC5BvC,UAAAA,KAAK,CAAC8B,KAAN,GAAcS,GAAd;AACH,SAFD,EAnB0B,CAuB1B;AACA;AACA;;AACA6B,QAAAA,UAAU,CAACY,EAAX,CAAc,MAAd,EAAsBC,IAAI,IAAI;AAC1BjF,UAAAA,KAAK,CAACG,MAAN,CAAa+E,qBAAb,CAAmCD,IAAnC;AACH,SAFD;AAGH,OA7BM,CAAP;AA8BH,KAxfE;;AA0fH;AACR;AACA;AACA;AACA;AACA;AACA;AACQI,IAAAA,QAAQ,GAAI;AACR,aAAO,CAAC,CAACrF,KAAK,CAACG,MAAR,IAAkBH,KAAK,CAACG,MAAN,CAAakG,SAAb,EAAzB;AACH,KAngBE;;AAqgBH;AACR;AACA;AACA;AACA;AACA;AACQ9F,IAAAA,SAAS,GAAI;AACT,aAAOP,KAAK,CAACO,SAAb;AACH,KA7gBE;;AA+gBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ+F,IAAAA,UAAU,GAAI;AACV,aAAO,KAAP;AACH,KA1hBE;;AA4hBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQC,IAAAA,MAAM,GAAI;AACN;AACA,aAAO,KAAP;AACH,KAxiBE;;AA0iBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQnB,IAAAA,MAAM,GAAI;AACN,aAAOpF,KAAK,CAACG,MAAN,KAAiB,IAAjB,IAAyBH,KAAK,CAACW,QAAN,KAAmB,IAAnD;AACH,KApjBE;;AAsjBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQ6F,IAAAA,cAAc,GAAI;AACd,aAAOxG,KAAK,CAACS,KAAb;AACH,KA/jBE;;AAikBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQD,IAAAA,QAAQ,GAAI;AACR,aAAOR,KAAK,CAACQ,QAAb;AACH,KA1kBE;;AA4kBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQkB,IAAAA,OAAO,GAAI;AACP;AACA;AACA,UAAI1B,KAAK,CAACZ,IAAV,EAAgB;AACZ,eAAOY,KAAK,CAACZ,IAAb;AACH,OALM,CAOP;AACA;AACA;;;AACA,UAAI,CAACY,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0B,CAA1B,EAA6BR,MAA9B,IAAwC,CAACI,KAAK,CAACF,GAAN,CAAUiB,OAAvD,EAAgE;AAC5D,eAAO,SAAP;AACH,OAZM,CAcP;AACA;;;AACA,aAAO,OAAP;AACH,KArmBE;;AAumBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQ0F,IAAAA,SAAS,GAAI;AACT,aAAOzG,KAAK,CAACG,MAAb;AACH,KAhnBE;;AAknBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQwF,IAAAA,QAAQ,GAAI;AACR;AACA;AACA,aAAO3F,KAAK,CAAC8B,KAAN,IAAe,IAAIC,KAAJ,CAAUhG,MAAM,CAAC0C,QAAP,CAAgBiI,2BAA1B,CAAtB;AACH,KA7nBE;;AA+nBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQC,IAAAA,qBAAqB,GAAI;AACrB,aAAO3G,KAAK,CAACY,UAAb;AACH,KA1oBE;;AA4oBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQgG,IAAAA,yBAAyB,GAAI;AACzB5G,MAAAA,KAAK,CAACC,oBAAN,GAA6B,KAA7B;AAEA,aAAO,IAAP;AACH,KAxpBE;;AA0pBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ4G,IAAAA,uBAAuB,CAAEC,EAAF,EAAM;AACzB9G,MAAAA,KAAK,CAACY,UAAN,CAAiBkG,EAAE,GAAG,CAAtB,IAA2BC,SAA3B;AAEA,aAAO,IAAP;AACH,KAvqBE;;AAyqBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQC,IAAAA,iBAAiB,GAAI;AACjB,YAAM7C,QAAQ,GAAGnE,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0B,CAA1B,CAAjB,CADiB,CAGjB;AACA;AACA;AACA;;AACA,UAAI+D,QAAQ,CAACvE,MAAb,EAAqB;AACjB;AACH;;AAED,aAAOuE,QAAQ,CAAC3E,IAAhB;AACH,KA7rBE;;AA+rBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQyH,IAAAA,WAAW,GAAI;AACX,aAAOjH,KAAK,CAACW,QAAb;AACH,KAxsBE;;AA0sBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQuG,IAAAA,aAAa,GAAI;AACb,YAAM/C,QAAQ,GAAGnE,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0B,CAA1B,CAAjB,CADa,CAGb;AACA;AACA;AACA;;AACA,UAAI+D,QAAQ,CAACvE,MAAb,EAAqB;AACjB;AACH;;AAED,aAAOuE,QAAQ,CAACzE,IAAhB;AACH,KA9tBE;;AAguBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQyH,IAAAA,mBAAmB,GAAI;AACnB,aAAOnH,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0B,CAA1B,EAA6BR,MAApC;AACH,KA1uBE;;AA4uBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQwH,IAAAA,aAAa,GAAI;AACb,aAAOzH,MAAP;AACH,KAtvBE;;AAwvBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQ0H,IAAAA,sBAAsB,GAAI;AACtB,aAAOrH,KAAK,CAACgB,mBAAb;AACH,KAjwBE;;AAmwBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQ4B,IAAAA,OAAO,GAAI;AACP;AACA,aAAO7C,IAAI,IAAI3B,MAAR,IAAkB,EAAzB;AACH,KA7wBE;;AA+wBH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQ+C,IAAAA,gCAAgC,GAAI;AAChC,aAAO,CAAC,CAAC/B,IAAT;AACH,KAzxBE;;AA2xBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQwG,IAAAA,yBAAyB,GAAI;AACzB;AACA,WAAK0B,MAAL,GAFyB,CAGzB;;AACA,aAAOtH,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0BC,MAA1B,GAAmC,CAA1C;AACH,KAvyBE;;AAyyBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQwE,IAAAA,oBAAoB,GAAI;AACpB,aAAO7E,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0BC,MAA1B,GAAmCL,KAAK,CAACT,SAAN,CAAgBe,WAAhB,CAA4BD,MAA/D,GAAwE,CAA/E;AACH,KAlzBE;;AAozBH;AACR;AACA;AACA;AACA;AACA;AACA;AACQkH,IAAAA,IAAI,GAAI;AACJ;AACA,WAAKD,MAAL,GAFI,CAIJ;AACA;AACA;;AACA,UAAI,CAACzH,UAAL,EAAiB;AACb;AACA;AACAG,QAAAA,KAAK,CAACT,SAAN,CAAgBa,SAAhB,GAA4BnE,SAAS,CAACuL,IAAV,CAAexH,KAAK,CAACT,SAAN,CAAgBa,SAA/B,CAA5B;AAEA,eAAO,KAAK6D,OAAL,EAAP;AACH,OAbG,CAeJ;AACA;AACA;;;AACA,aAAO7H,GAAG,CAACqL,MAAJ,CAAWzH,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0B,CAA1B,EAA6BZ,IAAxC,EACFuD,IADE,CACGxD,SAAS,IAAI;AACf;AACA;AACAS,QAAAA,KAAK,CAACT,SAAN,CAAgBa,SAAhB,GAA4BhE,GAAG,CAACoL,IAAJ,CAASjI,SAAT,CAA5B;AAEA,eAAO,KAAK0E,OAAL,EAAP;AACH,OAPE,CAAP;AAQH,KAr1BE;;AAu1BH;AACR;AACA;AACA;AACA;AACA;AACA;AACQyD,IAAAA,QAAQ,GAAI;AACR;AACA;AACA,aAAO1H,KAAK,CAACG,MAAN,CAAawH,YAAb,GACF5E,IADE,CACG,MAAM;AACR,eAAO,IAAP;AACH,OAHE,CAAP;AAIH,KAr2BE;;AAu2BH;AACR;AACA;AACA;AACA;AACA;AACA;AACQ2B,IAAAA,KAAK,GAAI;AACL;AACA1E,MAAAA,KAAK,CAACE,YAAN,GAAqB,EAArB,CAFK,CAGL;AACA;;AACAF,MAAAA,KAAK,CAACG,MAAN,GAAe,IAAf,CALK,CAML;;AACAH,MAAAA,KAAK,CAACO,SAAN,GAAkB,KAAlB,CAPK,CAQL;AACA;AACA;;AACAP,MAAAA,KAAK,CAACW,QAAN,GAAiB,IAAjB,CAXK,CAYL;AACA;;AACAX,MAAAA,KAAK,CAACY,UAAN,GAAmB,EAAnB,CAdK,CAeL;;AACAZ,MAAAA,KAAK,CAACgB,mBAAN,GAA4B,EAA5B,CAhBK,CAiBL;;AACAhB,MAAAA,KAAK,CAACS,KAAN,GAAc,KAAd;AAEA,aAAO,IAAP;AACH,KAn4BE;;AAq4BH;AACR;AACA;AACA;AACA;AACA;AACA;AACQmH,IAAAA,SAAS,CAAEzH,MAAF,EAAU;AACfH,MAAAA,KAAK,CAACG,MAAN,GAAeA,MAAf;AAEA,aAAO,IAAP;AACH,KAh5BE;;AAk5BH;AACR;AACA;AACA;AACA;AACA;AACA;AACQyE,IAAAA,KAAK,GAAI;AACL;AACA,aAAO,KAAKzB,eAAL,GACFJ,IADE,CACG7C,YAAY,IAAI;AAClB;AACA;AACA,YAAI,CAACA,YAAY,CAACJ,GAAlB,EAAuB;AACnB;AACH,SALiB,CAOlB;;;AACA,eAAO,KAAKmG,SAAL,EAAP;AACH,OAVE,EAWFlD,IAXE,CAWG,MAAM;AACR,eAAO,KAAKG,eAAL,EAAP;AACH,OAbE,EAcFH,IAdE,CAcG7C,YAAY,IAAI;AAClB;AACA;AACA,eAAO,KAAKe,eAAL,CAAqBf,YAArB,CAAP;AACH,OAlBE,EAmBF6C,IAnBE,CAmBG,MAAM;AACR;AACA,eAAO,KAAKtB,YAAL,EAAP;AACH,OAtBE,CAAP;AAuBH,KAl7BE;;AAo7BH;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQ6F,IAAAA,MAAM,GAAI;AACN,YAAM5B,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ,CADM,CAEN;AACA;AACA;AACA;AACA;;AACA,aAAO1F,KAAK,CAACT,SAAN,CAAgBe,WAAhB,CAA4BD,MAA5B,IAAsCqF,GAAG,GAAG1F,KAAK,CAACT,SAAN,CAAgBe,WAAhB,CAA4B,CAA5B,EAA+BkF,aAArC,GAAqDxF,KAAK,CAACU,UAAxG,EAAoH;AAChH;AACA;AACAV,QAAAA,KAAK,CAACT,SAAN,CAAgBa,SAAhB,CAA0ByD,IAA1B,CAA+B7D,KAAK,CAACT,SAAN,CAAgBe,WAAhB,CAA4BiF,KAA5B,EAA/B;AACH;;AAED,aAAO,IAAP;AACH;;AA18BE,GAAP;AA48BH;;AAEDpG,UAAU,CAAC0I,QAAX,GAAsB,iBAAyI;AAAA,MAA/H;AAAExI,IAAAA,oBAAF;AAAwBC,IAAAA,cAAxB;AAAwClB,IAAAA,MAAxC;AAAgDD,IAAAA,UAAhD;AAA4DoB,IAAAA,SAA5D;AAAuEC,IAAAA,IAAvE;AAA6EE,IAAAA,IAA7E;AAAmFG,IAAAA,UAAnF;AAA+FD,IAAAA,MAA/F;AAAuGvB,IAAAA,GAAvG;AAA4GC,IAAAA,UAA5G;AAAwHwB,IAAAA;AAAxH,GAA+H;AAC3J;AACA5B,EAAAA,SAAS,CAAC;AAAEE,IAAAA,MAAF;AAAUD,IAAAA,UAAV;AAAsBE,IAAAA,GAAtB;AAA2BC,IAAAA;AAA3B,GAAD,CAAT;AAEA,QAAMwJ,KAAK,GAAGvI,SAAS,IAAIA,SAAS,CAACc,MAAvB,GAAgCd,SAAS,CAACwI,GAAV,CAAcC,CAAC,IAAIA,CAAC,CAACtI,IAArB,CAAhC,GAA6D,CAACA,IAAD,CAA3E,CAJ2J,CAM3J;;AACA,MAAIoI,KAAK,CAACG,IAAN,CAAWC,CAAC,IAAI,CAACzL,cAAc,CAAC;AAAE0L,IAAAA,KAAK,EAAED,CAAT;AAAYE,IAAAA,GAAG,EAAE,CAAjB;AAAoBC,IAAAA,GAAG,EAAE;AAAzB,GAAD,CAA/B,CAAJ,EAAwE;AACpE,UAAM,IAAItG,KAAJ,CAAUhG,MAAM,CAAC0C,QAAP,CAAgB6J,mCAA1B,CAAN;AACH,GAT0J,CAW3J;AACA;;;AACAnM,EAAAA,aAAa,CAAC0L,QAAd,CAAuB;AAAE/H,IAAAA,GAAF;AAAOzB,IAAAA,GAAP;AAAYC,IAAAA;AAAZ,GAAvB,EAb2J,CAe3J;AACA;;AACA,MAAI,CAAC7B,cAAc,CAAC;AAAE0L,IAAAA,KAAK,EAAE7I,cAAT;AAAyB8I,IAAAA,GAAG,EAAE;AAA9B,GAAD,CAAnB,EAAwD;AACpD,UAAM,IAAIrG,KAAJ,CAAUhG,MAAM,CAAC0C,QAAP,CAAgB8J,gCAA1B,CAAN;AACH,GAnB0J,CAqB3J;AACA;AACA;AACA;AACA;;;AACA,MAAI,CAAC/L,cAAc,CAAC;AAAE2L,IAAAA,KAAK,EAAE9I;AAAT,GAAD,CAAf,IAAoD,CAAC3C,kBAAkB,CAAC;AAAEyL,IAAAA,KAAK,EAAE9I;AAAT,GAAD,CAA3E,EAA8G;AAC1G,UAAM,IAAI0C,KAAJ,CAAUhG,MAAM,CAAC0C,QAAP,CAAgB+J,2CAA1B,CAAN;AACH,GA5B0J,CA8B3J;AACA;;;AACA,MAAI3H,MAAM,CAAC4H,IAAP,CAAY5H,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBzB,oBAAlB,CAAZ,EAAqD4I,IAArD,CAA0DS,GAAG,IAAIA,GAAG,CAACC,UAAJ,CAAe,GAAf,CAAjE,CAAJ,EAA2F;AACvF,UAAM,IAAI5G,KAAJ,CAAUhG,MAAM,CAAC0C,QAAP,CAAgBmK,oCAA1B,CAAN;AACH,GAlC0J,CAoC3J;;;AACAxM,EAAAA,GAAG,CAACyL,QAAJ,CAAa;AAAEhI,IAAAA,UAAF;AAAcN,IAAAA,SAAd;AAAyBC,IAAAA,IAAzB;AAA+BE,IAAAA,IAA/B;AAAqCE,IAAAA;AAArC,GAAb;AAEA,SAAO,IAAP;AACH,CAxCD;;AA0CAT,UAAU,CAACxC,aAAX,GAA2BA,aAA3B;AACAwC,UAAU,CAACvC,yBAAX,GAAuCA,yBAAvC;AAEAiM,MAAM,CAACC,OAAP,GAAiB3J,UAAjB","sourcesContent":["/*\n * Copyright (c) 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst Client = require('../Protocol/Client');\nconst Net = require('net');\nconst TLS = require('tls');\nconst authenticationManager = require('../Authentication/AuthenticationManager');\nconst errors = require('../constants/errors');\nconst logger = require('../logger');\nconst multiHost = require('../topology/multi-host');\nconst pkg = require('../package');\nconst secureContext = require('../tls/secure-context');\nconst srv = require('../topology/dns-srv');\nconst system = require('../system');\nconst util = require('util');\nconst warnings = require('../constants/warnings');\nconst { isValidBoolean, isValidInteger, isValidPlainObject } = require('../validator');\n\n/**\n * Connection factory.\n * @module Connection\n */\n\n/**\n * MySQL server endpoint details.\n * @typedef {Object} Endpoint\n * @prop {string} [host=localhost] - hostname or IP (v4 or v6) of a MySQL server instance\n * @prop {number} [port=33060] - X Plugin port on the MySQL server instance\n * @prop {number} [priority] - priority of an endpoint relative to the others (endpoints with higher priority are picked first)\n * @prop {string} [socket] - relative or absolute path of a local Unix socket file\n */\n\n/**\n * Connection TLS-specific properties.\n * @typedef {Object} TLS\n * @prop {boolean} [enabled=true] - enables or disables TLS\n * @prop {string} [ca] - path of a file containing a certificate authority chain used to verify the server certificate\n * @prop {string} [crl] - path of a file containing a certificate revocation list used, alongside a certificate authority, to verify the server certificate\n * @prop {string[]} [versions=TLSv1.2, TLSv1.3] - restrict the list of allowed TLS versions (TLSv1.2, TLSv1.3)\n * @prop {string[]} [ciphershuites] - list of ciphersuites to allow (IANA syntax)\n */\n\n/**\n * Connection configuration properties.\n * @typedef {Object} Properties\n * @prop {string} [auth] - name of the client-side authentication mechanism to use\n * @prop {number} [connectTimeout=10000] - maximum ammount of time (ms) to wait for a server connection to be opened\n * @prop {Object} [connectionAttributes={}] - key-value object containing names and values of session attributes\n * @prop {module:Connection~Endpoint[]} [endpoints=[]] - list of endpoints to connect to\n * @prop {string} [host=localhost] - hostname or IP (v4 or v6) of a MySQL server instance\n * @prop {string} [password] - password for the MySQL account (defaults to '')\n * @prop {number} [port=33060] - X Plugin port on the MySQL server instance\n * @prop {boolean} [resolveSrv=false] - enable or disable DNS SRV resolution\n * @prop {string} [schema] - default database to connect to (defaults to '')\n * @prop {string} [socket] - relative or absolute path of a local Unix socket file\n * @prop {boolean} [resolveSrv=false] - use the host to perform a DNS SRV lookup and obtain the list of endpoints\n * @prop {module:Connection~TLS} [tls] - TLS options\n * @prop {string} [user] - user of the MySQL account (defaults to '')\n */\nconst VALID_OPTIONS = [\n    'auth',\n    'connectTimeout',\n    'connectionAttributes',\n    'dbPassword', // deprecated\n    'dbUser', // deprecated\n    'endpoints',\n    'host',\n    'password',\n    'port',\n    'resolveSrv',\n    'schema',\n    'socket',\n    'ssl', // deprecated\n    'sslOptions', // deprecated\n    'tls',\n    'user'\n];\n\n/**\n * @private\n * @typedef {Object} DefaultSessionAttributes Default set of session\n * attributes created by the client when connecting to a MySQL server that\n * supports session attributes.\n * @prop {string} _pid - client process id\n * @prop {string} _platform - platform name of the processor architecture\n * @prop {string} _os - name and version of the operating system\n * @prop {string} _client_name - name of the client product\n * @prop {string} _client_version - version of the client product\n * @prop {string} _client_license - license name of the client product\n */\nconst CLIENT_SESSION_ATTRIBUTES = {\n    _pid: system.pid(),\n    _platform: system.platform(),\n    _os: system.brand(),\n    _source_host: system.hostname(),\n    _client_name: pkg.name(),\n    _client_version: pkg.version(),\n    _client_license: pkg.license()\n};\n\n/**\n * Stringifies all the values in a given object.\n * @private\n * @param {Object} obj\n * @returns {Object}\n */\nfunction stringifyValues (obj = {}) {\n    let root = true;\n\n    return JSON.stringify(obj, (k, v) => {\n        // The replacer should skip the root node to avoid a stack overflow.\n        if (root) {\n            root = false;\n            return v;\n        }\n\n        // If the value is undefined, in order to keep consistency between\n        // connection strings and configuration objects, we coerce it to\n        // an empty string. If the value is null (only possible with a\n        // configuration object), we also coerce to an empty string in order\n        // to avoid saving 'null'.\n        if (typeof v === 'undefined' || v === null) {\n            return '';\n        }\n\n        // If the value is already a string, we should not do anything.\n        if (typeof v === 'string') {\n            return v;\n        }\n\n        // If the value is neither an object nor an array, we return its\n        // stringified version.\n        if (typeof v !== 'object') {\n            return JSON.stringify(v);\n        }\n\n        // Otherwise we need to recursively do the same for the values in \"v\".\n        return stringifyValues(v);\n    });\n}\n\n/**\n * @private\n * @typedef {Object} DeprecatedSSLOptions\n * @prop {string} [ca] - deprecated connection property for providing a path to a certificate authority file\n * @prop {string} [crl] - deprecated connection property for providing a path to a certificate revocation list file\n */\n\n/**\n * Toggle deprecation warnings for deprecated connection properties.\n * @private\n * @param {Object} params\n * @param {string} [params.dbPassword] - deprecate connection property for the MySQL account password\n * @param {string} [params.dbUser] - deprecated connection property for the MySQL account user\n * @param {boolean} [params.ssl] - deprecated connection property for enabling or disabling TLS\n * @param {DeprecatedSSLOptions} [params.dbUser] - deprecated connection property for additional SSL options\n * @returns {boolean}\n */\nfunction deprecate ({ dbPassword, dbUser, ssl, sslOptions }) {\n    const log = logger('connection:options');\n\n    // The \"dbPassword\" property is deprecated.\n    if (typeof dbPassword !== 'undefined') {\n        log.warning('dbPassword', warnings.MESSAGES.WARN_DEPRECATED_DB_PASSWORD, {\n            type: warnings.TYPES.DEPRECATION,\n            code: warnings.CODES.DEPRECATION\n        });\n    }\n\n    // The \"dbUser\" property is deprecated.\n    if (typeof dbUser !== 'undefined') {\n        log.warning('dbUser', warnings.MESSAGES.WARN_DEPRECATED_DB_USER, {\n            type: warnings.TYPES.DEPRECATION,\n            code: warnings.CODES.DEPRECATION\n        });\n    }\n\n    // The \"ssl\" and \"sslOptions\" properties are deprecated.\n    if (typeof ssl !== 'undefined') {\n        log.warning('ssl', warnings.MESSAGES.WARN_DEPRECATED_SSL_OPTION, {\n            type: warnings.TYPES.DEPRECATION,\n            code: warnings.CODES.DEPRECATION\n        });\n    }\n\n    if (typeof sslOptions !== 'undefined') {\n        log.warning('sslOptions', warnings.MESSAGES.WARN_DEPRECATED_SSL_ADDITIONAL_OPTIONS, {\n            type: warnings.TYPES.DEPRECATION,\n            code: warnings.CODES.DEPRECATION\n        });\n    }\n\n    return true;\n}\n\n/**\n * @alias module:Connection\n * @param {Properties} - connection properties\n * @returns {module:Connection}\n */\nfunction Connection ({ auth, connectionAttributes = {}, connectTimeout = 10000, dbPassword, dbUser, endpoints = [], host = 'localhost', password = '', port = 33060, schema, socket, resolveSrv = false, ssl, sslOptions, tls = {}, user = '' } = {}) {\n    // Internal connection state.\n    const state = {\n        // Contains the name of the authentication mechanism that is\n        // effectively negotiated with the server.\n        auth,\n        // Indicates if the connection supports prepared statements (MySQL\n        // 8.0.16 or higher).\n        canPrepareStatements: true,\n        // Contains the list of connection capabilities that were effectively\n        // negotiated with the server.\n        capabilities: {},\n        // Tracks an internal X Protocol client instance.\n        client: null,\n        // We keep a list of available and unavailable endpoints for\n        // connection failover.\n        endpoints: {\n            // If there is a list of endpoints, we should use it.\n            // If not, it should only include an endpoint with the details\n            // specified by the \"host\", \"port\" and/or \"socket\" properties or\n            // by the first and only element in that list.\n            // When a connection is first opened, all endpoints should be\n            // available. This can change if a socket cannot be created for\n            // a given endpoint.\n            available: endpoints.length ? endpoints : [{ host, port, socket }],\n            unavailable: []\n        },\n        // Indicates the connection is being closed.\n        isClosing: false,\n        // Indicates if the connection established with the server\n        // is using TLS.\n        isSecure: false,\n        // Indicates if the connection should be retried to the same endpoint.\n        retry: false,\n        // Indicates the number of milliseconds to wait before retrying a\n        // specific endpoint.\n        retryAfter: 20000,\n        // Contains the connection id assigned by the server.\n        serverId: null,\n        // Contains the list of statements that were prepared and exist in the\n        // scope of the associated server session.\n        statements: [],\n        // Merges any contents of the deprecated \"ssl\" and \"sslOptions\"\n        // properties with the content of the \"tls\" property.\n        // For tls.enable = true, we need to ensure that ssl !== false.\n        // Additional options are merged with precedence for those defined\n        // using the \"tls\" property, except for \"ciphersuites\" and \"versions\"\n        // which we want to override given the validation constraints.\n        tls: Object.assign({}, { enabled: ssl === false ? ssl : true }, sslOptions, tls),\n        // Tracks the list of capabilities that the server does not know.\n        unknownCapabilities: []\n    };\n\n    return {\n        /**\n         * Adds a set of connection capabilities to the existing ones.\n         * @private\n         * @function\n         * @name module:Connection#addCapabilities\n         * @param {Object} capabilities - set of capabilities\n         * @returns {module:Connection} The connection instance\n         */\n        addCapabilities (capabilities) {\n            state.capabilities = Object.assign({}, state.capabilities, capabilities);\n\n            return this;\n        },\n\n        /**\n         * Checks if the connection setup allows to retry authentication.\n         * @private\n         * @function\n         * @name module:Connection:allowsAuthenticationRetry\n         * @returns {boolean}\n         */\n        allowsAuthenticationRetry () {\n            // If the application provides its own authentication mechanism,\n            // there is no reason to retry.\n            if (this.hasCustomAuthenticationMechanism()) {\n                return false;\n            }\n\n            // If the connection is secure, it means the authentication\n            // failed because the credentials did not match, so we should\n            // not allow a retry.\n            if (state.endpoints.available[0].socket || state.tls.enabled) {\n                return false;\n            }\n\n            // Which leaves us with checking if the server supports or not\n            // the fallback authentication mechanism.\n            return this.allowsAuthenticationWith('SHA256_MEMORY');\n        },\n\n        /**\n         * Checks if a given authentication mechanism can be used with the\n         * connection.\n         * @private\n         * @function\n         * @name module:Connection#allowsAuthenticationWith\n         * @param {string} mechanism - name of the authentication mechanism\n         * @returns {boolean}\n         */\n        allowsAuthenticationWith (mechanism) {\n            // This is a workaround because on MySQL 5.7.x, calling\n            // Mysqlx.Connection::CapabilitiesGet over a unix socket does not\n            // return `PLAIN` while is in fact supported.\n            const serverSupportedMechanisms = (state.capabilities['authentication.mechanisms'] || []).concat('PLAIN');\n\n            return serverSupportedMechanisms.indexOf(mechanism) > -1;\n        },\n\n        /**\n         * Negotiates the proper authentication mechanism for the connection user.\n         * @private\n         * @function\n         * @name module:Connection#authenticate\n         * @returns {module:Connection} The connection instance\n         */\n        authenticate () {\n            // Try the custom authentication mechanism, if it is provided,\n            // PLAIN, if the connection is secure, or MYSQL41, if not.\n            const mechanism = this.getAuth();\n\n            if (!this.allowsAuthenticationWith(mechanism)) {\n                const message = util.format(errors.MESSAGES.ER_DEVAPI_AUTH_UNSUPPORTED_SERVER, mechanism);\n                const error = new Error(message);\n                error.info = { code: errors.ER_ACCESS_DENIED_ERROR, msg: message };\n\n                return Promise.reject(error);\n            }\n\n            return this.authenticateWith(mechanism)\n                .catch(err => {\n                    // If the setup does not allow to retry the authentication\n                    // or if the error is not related to authentication we\n                    // should report it.\n                    if (!this.allowsAuthenticationRetry() || (err.info && err.info.code !== errors.ER_ACCESS_DENIED_ERROR)) {\n                        throw err;\n                    }\n\n                    // Otherwise we should perform the fallback strategy and\n                    // try with SHA256_MEMORY.\n                    return this.authenticateWith('SHA256_MEMORY')\n                        .catch(err => {\n                            // If it is not an authentication error, we should bubble that\n                            // error instead.\n                            if (err.info && err.info.code !== errors.ER_ACCESS_DENIED_ERROR) {\n                                throw err;\n                            }\n\n                            // Otherwise, we improve the existing error message.\n                            err.message = err.info.msg = errors.MESSAGES.ER_DEVAPI_AUTH_MORE_INFO;\n\n                            throw err;\n                        });\n                });\n        },\n\n        /**\n         * Authenticates the connection user with a given mechanism.\n         * @private\n         * @function\n         * @name module:Connection#authenticateWith\n         * @param {string} mechanism - name of the authentication mechanism\n         * @returns {Promise<module:Connection>} A Promise that resolves to the\n         * connection instance.\n         */\n        authenticateWith (mechanism) {\n            const plugin = authenticationManager.getPlugin(mechanism);\n            const theUser = this.getUser();\n            // We don't expose a getPassword() method because, the connection\n            // is publicly available with session._getConnection()\n            const thePassword = password || dbPassword || '';\n\n            return plugin({ password: thePassword, schema, user: theUser }).run(state.client)\n                .then(session => {\n                    state.auth = mechanism;\n                    state.serverId = session.connectionId;\n\n                    return this;\n                });\n        },\n\n        /**\n         * Retrieves the server-side connection capabilities that have been\n         * effectively negotiated.\n         * @private\n         * @function\n         * @name module:Connection#capabilitiesGet\n         * @returns {Promise}\n         */\n        capabilitiesGet () {\n            return state.client.capabilitiesGet();\n        },\n\n        /**\n         * Negotiates a set of connection capabilities with the server\n         * (X Plugin).\n         * @private\n         * @function\n         * @name module:Connection#capabilitiesSet\n         * @returns {Promise}\n         */\n        capabilitiesSet () {\n            // TODO(Rui): any additional capability, such as compression, can\n            // be negotiated in this pipeline.\n            const capabilities = {};\n\n            // If TLS is enabled and the connection is not using a local Unix socket,\n            // we need to enable TLS in the X Plugin.\n            if (state.tls.enabled === true && !state.endpoints.available[0].socket) {\n                // The X Protocol capability name is \"tls\".\n                capabilities.tls = true;\n            }\n\n            // If connection attributes are to be sent, we need to merge the\n            // default client attributes. Additionally, if the server does\n            // not support session attributes, the connection is re-tried and\n            // we should disable them in the second attempt.\n            if (connectionAttributes !== false && state.unknownCapabilities.indexOf('session_connect_attrs') === -1) {\n                const attributes = Object.assign({}, CLIENT_SESSION_ATTRIBUTES, connectionAttributes);\n                // The X Plugin requires all connection attributes to be\n                // encoded as strings. The client attributes are already\n                // expected to be strings. However, custom application\n                // attributes that are not strings need to be coerced.\n                // If they are not able to be coerced (e.g. null or\n                // undefined), we should propagate the error reported by the\n                // plugin.\n                // The X Protocol capability name is \"session_connect_attrs\".\n                capabilities.session_connect_attrs = JSON.parse(stringifyValues(attributes));\n            }\n\n            return state.client.capabilitiesSet(capabilities)\n                .then(() => {\n                    // Must return the client capabilities for further\n                    // processing.\n                    return capabilities;\n                })\n                .catch(err => {\n                    // When TLS is not enabled in the server, we want\n                    // to report back a custom message.\n                    if (err.info && err.info.code === errors.ER_X_CAPABILITIES_PREPARE_FAILED) {\n                        // By TLS not being enabled, it means that the X\n                        // Plugin will report an error stating that the \"tls\"\n                        // capability failed. This is a generic error that can\n                        // mean any other capability is invalid, so we need to\n                        // ensure we are dealing with TLS. Currently the only\n                        // way to retrieve the capability name is to parse the\n                        // error message.\n                        const failedCapability = err.message.match(/Capability prepare failed for '([^']+)'.*/)[1];\n                        // If the failure is not related to TLS, we should\n                        // report the error as is.\n\n                        if (failedCapability !== 'tls') {\n                            throw err;\n                        }\n\n                        // Otherwise, we want to report a custom message.\n                        const message = errors.MESSAGES.ER_DEVAPI_NO_SERVER_TLS;\n                        err.message = message;\n                        err.info.msg = message;\n\n                        throw err;\n                    }\n\n                    // When a new capability is introduced, it will be unknown\n                    // to older server versions. In that case, the server will\n                    // report an error and will close the connection. However,\n                    // since there is no way to ensure the capability is\n                    // supported beforehand, we have to try and send it anyway\n                    // asking for forgiveness instead of permission. Thus, in\n                    // order to make it seamless to the application, we need\n                    // to destroy the network socket and re-create the\n                    // connection without the unknown capabilities.\n                    if (!err.info || err.info.code !== errors.ER_X_CAPABILITY_NOT_FOUND) {\n                        throw err;\n                    }\n\n                    // By this point, the server has sent back an\n                    // ER_X_CAPABILITY_NOT_FOUND error and has closed the\n                    // connection.\n                    // So, the first thing we need to do is to track the\n                    // unknown capability. Currently the only way to retrieve\n                    // the capability name is to parse the error message.\n                    const unknownCapability = err.message.match(/Capability '([^']+)'.*/)[1];\n                    state.unknownCapabilities.push(unknownCapability);\n\n                    // And we need to ensure that we re-create a connection to\n                    // the same endpoint. Since we are now tracking unknown\n                    // capabilities, any new connection will not try to\n                    // negotiate those.\n                    state.retry = true;\n\n                    const socket = state.client.getConnection();\n                    socket.destroy(err);\n                });\n        },\n\n        /**\n         * Closes the X Protocol connection and the underlying connection\n         * socket.\n         * This method is overriden by PoolConnection\n         * @private\n         * @function\n         * @name module:Connection#close\n         * @returns {Promise}\n         */\n        close () {\n            return this.destroy();\n        },\n\n        /**\n         * Creates a network socket to the most appropriate MySQL server\n         * endpoint.\n         * @private\n         * @function\n         * @name module:Connection#connect\n         * @returns {Promise<module:Connection>}\n         */\n        connect () {\n            return new Promise((resolve, reject) => {\n                // We want to connect to the first endpoint that is available.\n                const endpoint = state.endpoints.available[0];\n                // In the case of multi-host connections, we want sane\n                // defaults for each endpoint in the list, in order to\n                // require less verbosity from the user.\n                const nodeSocket = Net.connect({ host: endpoint.host || 'localhost', port: endpoint.port || 33060, path: endpoint.socket });\n\n                nodeSocket.setTimeout(connectTimeout);\n\n                // Actions to perform after a connection is successfully\n                // established (including server session).\n                const postConnect = connection => {\n                    // We need to \"remove\" the timeout because we do not want\n                    // the event to be triggered after the connection is\n                    // effectively established.\n                    // For now, we consider \"connectTimeout\" to be the maximum\n                    // time it can take for a client socket (TLS or not) to\n                    // successfully connect to the server.\n                    nodeSocket.setTimeout(0);\n                    return resolve(connection);\n                };\n\n                // Actions to perform when there is an error in the connection\n                // stage.\n                const postDisconnect = err => {\n                    // We should cleanup the connection state.\n                    this.reset();\n\n                    // If there isn't an error, it means the socket has been\n                    // closed by the server and the client was expecting it.\n                    // There's nothing to do, the workflow is just finished\n                    // by this point.\n                    if (!err) {\n                        return resolve();\n                    }\n\n                    // If there is an error, it means the socket has been\n                    // closed with an error and we need to report it back\n                    // to the application.\n                    return reject(err);\n                };\n\n                // For now, we consider every error to happen at the\n                // connection stage, to be fatal, and thus, we should stop and\n                // close/destroy the connection.\n                nodeSocket.once('ready', () => {\n                    // We can start creating the client instance, which will\n                    // hold the given connection. This is important because\n                    // we do not need to keep the raw socket available\n                    // everywhere but we still want to decouple the TLS logic.\n                    state.client = new Client(nodeSocket);\n\n                    // We can now start the process of creating a server-side\n                    // X Protocol session.\n                    return this.start().then(postConnect).catch(err => nodeSocket.destroy(err));\n                });\n\n                nodeSocket.once('error', err => {\n                    // The \"close\" event will automatically be triggered.\n                    state.error = err;\n                });\n\n                nodeSocket.once('timeout', () => {\n                    const error = new Error();\n                    error.name = 'ETIMEDOUT';\n\n                    // The error message depends on whether the connection is\n                    // multi-host or not.\n                    if (!this.hasMultipleEndpoints()) {\n                        error.message = util.format(errors.MESSAGES.ER_DEVAPI_CONNECTION_TIMEOUT, connectTimeout);\n                    } else {\n                        error.message = util.format(errors.MESSAGES.ER_DEVAPI_MULTI_HOST_CONNECTION_TIMEOUT, connectTimeout);\n                    }\n\n                    // The connection must be manually closed.\n                    // https://nodejs.org/docs/latest/api/net.html#net_event_timeout\n                    nodeSocket.destroy(error);\n                });\n\n                nodeSocket.on('data', data => {\n                    state.client.handleNetworkFragment(data);\n                });\n\n                nodeSocket.once('close', hasError => {\n                    // When the endpoint becomes unvailable in the middle of\n                    // some work load, we should delegate error handling to\n                    // the specific worker.\n                    if (!hasError && this.isOpen() && this.isActive()) {\n                        // We are already past the connection stage.\n                        return state.client.handleServerClose();\n                    }\n\n                    // When a fatal error happens in the server, it will close\n                    // the connection, but since it is not a network error,\n                    // \"hasError\" will be \"false\", so we need to account for\n                    // that cenario. In that case, we can check if the\n                    // connection is already active or not.\n                    if (!hasError && this.isOpen()) {\n                        // It means the connection was legitimately closed.\n                        return postDisconnect();\n                    }\n\n                    // If we cannot retry, the current connection should\n                    // become unavailable. One reason to retry the current\n                    // connection is if the server is available but refused\n                    // the connection with a non-fatal error (such as when\n                    // a capability is not known).\n                    if (!state.retry) {\n                        // When a connection becomes unavailable, it should\n                        // include the timestamp of when it was last tried.\n                        const unavailable = Object.assign({}, state.endpoints.available.shift(), {\n                            unavailableAt: Date.now()\n                        });\n\n                        state.endpoints.unavailable.push(unavailable);\n                    }\n\n                    // If we are retrying now, we should prevent duplicate\n                    // retries.\n                    state.retry = false;\n\n                    // By this point, there should be an error available in\n                    // \"state.error\", which is updated for each error event in\n                    // the socket (but also includes other kinds of errors).\n                    const error = this.getError();\n\n                    // We want to know if the the timeout has been reached for\n                    // all the endpoints, or if there was a different issue.\n                    if (!this.hasMoreEndpointsAvailable() && (!this.hasMultipleEndpoints() || error.name === 'ETIMEDOUT')) {\n                        return postDisconnect(error);\n                    }\n\n                    // If we are in a multi-host setup and there are no more\n                    // endpoints available, we want to raise a custom error\n                    // as well.\n                    if (!this.hasMoreEndpointsAvailable() && this.hasMultipleEndpoints()) {\n                        error.name = 'ENOMOREHOSTS';\n                        error.errno = errors.ER_DEVAPI_MULTI_HOST_CONNECTION_FAILED;\n                        error.message = errors.MESSAGES.ER_DEVAPI_MULTI_HOST_CONNECTION_FAILED;\n\n                        return postDisconnect(error);\n                    }\n\n                    // By this point, the list of available and unavailable\n                    // endpoints is already up-to-date and if there are more\n                    // endpoints available, we should try to connect to the\n                    // next one in the list.\n                    this.connect().then(postConnect).catch(postDisconnect);\n                });\n            });\n        },\n\n        /**\n         * Asks the server to gracefully close the underlying X Protocol\n         * connection.\n         * @private\n         * @function\n         * @name module:Connection#destroy\n         * @returns {Promise}\n         */\n        destroy () {\n            // This operation should be idempotent because there is a chance\n            // that the connection might already been closed by the server\n            // we should check first.\n            if (!this.isOpen() || state.isClosing) {\n                return Promise.resolve();\n            }\n\n            const socket = state.client.getConnection();\n\n            // Again, the operation should be idempotent, so, if the socket\n            // reference has already been destroyed, there is nothing to do.\n            if (socket.destroyed) {\n                return Promise.resolve();\n            }\n\n            // Eventually, the socket is destroyed and a 'close' event is\n            // emmitted. This is here just to make sure the operation does\n            // not fail if the connection is, for some weird reason, manually\n            // closed again by the application.\n            state.isClosing = true;\n\n            // The method is shared between this and \"PoolConnection\".\n            // We cannot re-use \"close()\" because it is overrided by \"PoolConnection\".\n            return state.client.connectionClose()\n                .then(() => {\n                    // The server closes the socket on their end so we also\n                    // need to destroy our reference.\n                    // This will trigger a 'close' event whose handler is responsible\n                    // for further cleanup.\n                    socket.destroy();\n\n                    // The connection has been safely closed by now.\n                    state.isClosing = false;\n                });\n        },\n\n        /**\n         * Enables TLS on the underlying network socket.\n         * @private\n         * @function\n         * @name module:Connection#enableTLS\n         * @returns {Promise}\n         */\n        enableTLS () {\n            return new Promise(resolve => {\n                const secureContextOptions = Object.assign({}, state.tls);\n                // We already know TLS should be enabled.\n                delete secureContextOptions.enabled;\n                // We need to create a secure socket by providing the existing\n                // socket and the proper security context.\n                const nodeSocket = TLS.connect(Object.assign({}, { socket: state.client.getConnection() }, secureContext.create(secureContextOptions)));\n\n                nodeSocket.once('secureConnect', () => {\n                    state.isSecure = true;\n                    // Once a TLS session is established, we need to\n                    // update the socket reference.\n                    state.client.setConnection(nodeSocket);\n                    // Then we are done and can move along.\n                    resolve();\n                });\n\n                // We need to re-attach the event listener in order to\n                // be able to handle OpenSSL errors.\n                nodeSocket.once('error', err => {\n                    state.error = err;\n                });\n\n                // The stream is paused when a secure connection is\n                // established in the socket, so we need to resume the\n                // flow. The handler should be the same.\n                nodeSocket.on('data', data => {\n                    state.client.handleNetworkFragment(data);\n                });\n            });\n        },\n\n        /**\n         * Checks if there is any ongoing workload in the connection.\n         * @private\n         * @function\n         * @name module:Connection#isActive\n         * @returns {boolean}\n         */\n        isActive () {\n            return !!state.client && state.client.isRunning();\n        },\n\n        /**\n         * Checks of the connection is being closed.\n         * @private\n         * @function module:Connection#isClosing\n         * @returns {boolean}\n         */\n        isClosing () {\n            return state.isClosing;\n        },\n\n        /**\n         * Checks if the connection was created by a pool, which is never the\n         * case for this API.\n         * This method is overriden by {@link module:PoolConnection|PoolConnection}.\n         * @private\n         * @function\n         * @name module:Connection#isFromPool\n         * @returns {boolean} Returns false.\n         */\n        isFromPool () {\n            return false;\n        },\n\n        /**\n         * Checks if the connection is idle, which is never the case for this\n         * API.\n         * This method is overriden by {@link module:PoolConnection|PoolConnection}.\n         * @private\n         * @function\n         * @name module:Connection#isIdle\n         * @returns {boolean} Returns false.\n         */\n        isIdle () {\n            // Standalone connections never become idle on the client side.\n            return false;\n        },\n\n        /**\n         * Checks if a server-side X Protocol connecion has been sucessfuly\n         * established.\n         * @private\n         * @function\n         * @name module:Connection#isOpen\n         * @returns {boolean}\n         */\n        isOpen () {\n            return state.client !== null && state.serverId !== null;\n        },\n\n        /**\n         * Checks if we are in a middle of a connection retry.\n         * @private\n         * @function\n         * @name module:Connection#isReconnecting\n         * @returns {boolean}\n         */\n        isReconnecting () {\n            return state.retry;\n        },\n\n        /**\n         * Checks if the connection is using TLS.\n         * @private\n         * @function\n         * @name module:Connection#isSecure\n         * @returns {boolean}\n         */\n        isSecure () {\n            return state.isSecure;\n        },\n\n        /**\n         * Retrieves the name of the authentication mechanism that was\n         * negotiated with the server.\n         * @private\n         * @function\n         * @name module:Connection#getAuth\n         * @returns {string}\n         */\n        getAuth () {\n            // If an authentication mechanism is specified, we should try to\n            // use it.\n            if (state.auth) {\n                return state.auth;\n            }\n\n            // If one is not specified and the connection is not secure, we\n            // should use a mechanism that works with most widespread plugin:\n            // \"mysql_native_password\".\n            if (!state.endpoints.available[0].socket && !state.tls.enabled) {\n                return 'MYSQL41';\n            }\n\n            // If the connection is secure, we should opt for the fastest\n            // alternative which is sending credentials as clear text.\n            return 'PLAIN';\n        },\n\n        /**\n         * Retrieves the underlying X Protocol client instance.\n         * @private\n         * @function\n         * @name module:Connection#getClient\n         * @returns {Client}\n         */\n        getClient () {\n            return state.client;\n        },\n\n        /**\n         * Retrieves any error generated by the connection.\n         * @private\n         * @function\n         * @name module:Connection#getError\n         * @returns {Error}\n         */\n        getError () {\n            // It does not make sense to have a default error value as part of\n            // the connection state.\n            return state.error || new Error(errors.MESSAGES.ER_DEVAPI_CONNECTION_CLOSED);\n        },\n\n        /**\n         * Retrieves the list of client-side ids associated to server-side\n         * prepared statements created in the scope of the underlying X\n         * Protocol session.\n         * @private\n         * @function\n         * @name module:Connection#getPreparedStatements\n         * @returns {number[]}\n         */\n        getPreparedStatements () {\n            return state.statements;\n        },\n\n        /**\n         * Toggles the a flag to indicate the connection does not support\n         * server-side prepared statements.\n         * @private\n         * @function\n         * @name module:Connection#disablePreparedStatements\n         * @returns {module:Connection}\n         */\n        disablePreparedStatements () {\n            state.canPrepareStatements = false;\n\n            return this;\n        },\n\n        /**\n         * Removes a deallocated prepared statement for the list of statements\n         * associated to the X Protocol session.\n         * @private\n         * @function\n         * @name module:Connection#removePreparedStatement\n         * @param {number} id - the client-side prepared statement id\n         * @returns {module:Connection}\n         */\n        removePreparedStatement (id) {\n            state.statements[id - 1] = undefined;\n\n            return this;\n        },\n\n        /**\n         * Retrieves the hostname or IP (v4 or v6) address of the machine\n         * where the MySQL server is hosted.\n         * @private\n         * @function\n         * @name module:Connection#getServerHostname\n         * @returns {string}\n         */\n        getServerHostname () {\n            const endpoint = state.endpoints.available[0];\n\n            // Local socket file paths have precedence over host:port combos\n            // in the core Node.js APIs used to create a network socket.\n            // So, we want to make it clear that a Unix socket is being used\n            // in this case.\n            if (endpoint.socket) {\n                return;\n            }\n\n            return endpoint.host;\n        },\n\n        /**\n         * Retrieves the server-side connection id.\n         * @private\n         * @function\n         * @name module:Connection#getServerId\n         * @returns {number}\n         */\n        getServerId () {\n            return state.serverId;\n        },\n\n        /**\n         * Retrieves the port number where the server is listening for\n         * connections.\n         * @private\n         * @function\n         * @name module:Connection#getServerPort\n         * @returns {number}\n         */\n        getServerPort () {\n            const endpoint = state.endpoints.available[0];\n\n            // Local socket file paths have precedence over host:port combos\n            // in the core Node.js APIs used to create a network socket.\n            // So, we want to make it clear that a Unix socket is being used\n            // in this case.\n            if (endpoint.socket) {\n                return;\n            }\n\n            return endpoint.port;\n        },\n\n        /**\n         * Retrieves the path to the local Unix socket file used for\n         * connecting to the server.\n         * @private\n         * @function\n         * @name module:Connection#getServerSocketPath\n         * @returns {string}\n         */\n        getServerSocketPath () {\n            return state.endpoints.available[0].socket;\n        },\n\n        /**\n         * Retrieves the name of the default schema associated to the\n         * connection.\n         * @private\n         * @function\n         * @name module:Connection#getSchemaName\n         * @returns {string}\n         */\n        getSchemaName () {\n            return schema;\n        },\n\n        /**\n         * Retrieves the list of capabilities that are not known by the server.\n         * @private\n         * @function\n         * @name module:Connection#getUnknownCapabilities\n         * @returns {string[]}\n         */\n        getUnknownCapabilities () {\n            return state.unknownCapabilities;\n        },\n\n        /**\n         * Retrieves the MySQL account user associated to the connection.\n         * @private\n         * @function\n         * @name module:Connection#getUser\n         * @returns {string}\n         */\n        getUser () {\n            // TODO(Rui): \"dbUser\" is deprecated.\n            return user || dbUser || '';\n        },\n\n        /**\n         * Checks if the connection is using a custom authentication mechanism\n         * provided by the application.\n         * @private\n         * @function\n         * @name module:Connection#hasCustomAuthenticationMechanism\n         * @returns {boolean}\n         */\n        hasCustomAuthenticationMechanism () {\n            return !!auth;\n        },\n\n        /**\n         * Checks if there are endpoints available.\n         * @private\n         * @function\n         * @name module:Connection#hasMoreEndpointsAvailable\n         * @returns {boolean}\n         */\n        hasMoreEndpointsAvailable () {\n            // Make sure the list of available endpoints is up-to-date.\n            this.update();\n            // If there are available endpoints, we can perform a failover.\n            return state.endpoints.available.length > 0;\n        },\n\n        /**\n         * Checks if the connection was configured with multiple endpoints.\n         * @private\n         * @function\n         * @name module:Connection#hasMultipleEndpoints\n         * @returns {boolean}\n         */\n        hasMultipleEndpoints () {\n            return state.endpoints.available.length + state.endpoints.unavailable.length > 1;\n        },\n\n        /**\n         * Creates a new connection to a MySQL endpoint.\n         * @private\n         * @function\n         * @name module:Connection#open\n         * @returns {Promise<module:Connection>}\n         */\n        open () {\n            // Make sure the list of available endpoints is up-to-date.\n            this.update();\n\n            // If \"resolveSrv\" is disabled, it means we already have an\n            // ordered list of endpoints and we can try to connect to the\n            // first one.\n            if (!resolveSrv) {\n                // We sort the list of endpoints (one or more) according to\n                // the set of multi-host rules.\n                state.endpoints.available = multiHost.sort(state.endpoints.available);\n\n                return this.connect();\n            }\n\n            // If \"resolveSrv\" is enabled, it means we need to retrieve the\n            // ordered list of endpoints from a discovery service potentially\n            // available at that host.\n            return srv.lookup(state.endpoints.available[0].host)\n                .then(endpoints => {\n                    // We now have the effective ordered list of endpoints\n                    // which we use to update the previous one.\n                    state.endpoints.available = srv.sort(endpoints);\n\n                    return this.connect();\n                });\n        },\n\n        /**\n         * Resets and re-uses the underlying X Protocol connection.\n         * @private\n         * @function\n         * @name module:Connection#override\n         * @returns {Promise<module:Connection>}\n         */\n        override () {\n            // A connection pool calls this method when it wants to re-use an\n            // existing connection.\n            return state.client.sessionReset()\n                .then(() => {\n                    return this;\n                });\n        },\n\n        /**\n         * Resets the internal state of the connection.\n         * @private\n         * @function\n         * @name module:Connection#reset\n         * @returns {Promise<module:Connection>}\n         */\n        reset () {\n            // The connection capabilities will no longer be up-to-date.\n            state.capabilities = {};\n            // The client instance contains the work queue, which might not be\n            // empty, and needs to be dereferenced anyway.\n            state.client = null;\n            // The connection is not closing anymore.\n            state.isClosing = false;\n            // An existing server connection id is what tells if a connection\n            // has been successfully established, so we need to deference it\n            // as well, since the connection is closed by this point.\n            state.serverId = null;\n            // Any existing references to prepared statements associated to\n            // the connection should be removed.\n            state.statements = [];\n            // Any unknown capabilities are also no longer valid.\n            state.unknownCapabilities = [];\n            // The connection has closed, so there are no retries left.\n            state.retry = false;\n\n            return this;\n        },\n\n        /**\n         * Updates the underlying X Protocol client instance.\n         * @private\n         * @function\n         * @name module:Connection#setClient\n         * @returns {Promise<module:Connection>}\n         */\n        setClient (client) {\n            state.client = client;\n\n            return this;\n        },\n\n        /**\n         * Executes the pipeline for creating a server-side X Protocol session.\n         * @private\n         * @function\n         * @name module:Connection#start\n         * @returns {Promise<module:Connection>}\n         */\n        start () {\n            // Start the pipeline to create a new MySQL server session.\n            return this.capabilitiesSet()\n                .then(capabilities => {\n                    // If TLS should be disabled, there is nothing else to do\n                    // and we can proceed with the next pipeline stage.\n                    if (!capabilities.tls) {\n                        return;\n                    }\n\n                    // Otherwise, we need to create a secure socket.\n                    return this.enableTLS();\n                })\n                .then(() => {\n                    return this.capabilitiesGet();\n                })\n                .then(capabilities => {\n                    // We should save the effective list of capabilities\n                    // negotiated with the server.\n                    return this.addCapabilities(capabilities);\n                })\n                .then(() => {\n                    // Then we proceed to authenticate the user.\n                    return this.authenticate();\n                });\n        },\n\n        /**\n         * Updates the availability of the possible MySQL endpoints specified\n         * for the connection.\n         * @private\n         * @function\n         * @name module:Connection#update\n         * @returns {module:Connection}\n         */\n        update () {\n            const now = Date.now();\n            // Check which unavailable endpoints can be re-tried.\n            // If the current element in the list is not \"retryable\", neither\n            // are the remaining. A retryable endpoint is any endpoint that has\n            // been unavailable since at least the time interval defined by\n            // state.retryAfter.\n            while (state.endpoints.unavailable.length && now - state.endpoints.unavailable[0].unavailableAt > state.retryAfter) {\n                // If an endpoint can be re-tried we need to move it back to\n                // the list of available endpoints.\n                state.endpoints.available.push(state.endpoints.unavailable.shift());\n            }\n\n            return this;\n        }\n    };\n}\n\nConnection.validate = function ({ connectionAttributes, connectTimeout, dbUser, dbPassword, endpoints, host, port, resolveSrv, socket, ssl, sslOptions, tls }) {\n    // TODO(Rui): Remove after deprecation period (undetermined).\n    deprecate({ dbUser, dbPassword, ssl, sslOptions });\n\n    const ports = endpoints && endpoints.length ? endpoints.map(e => e.port) : [port];\n\n    // The port must be an integer between 0 and 65536.\n    if (ports.some(p => !isValidInteger({ value: p, min: 0, max: 65536 }))) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_CONNECTION_PORT_RANGE);\n    }\n\n    // We delegate validation of the TLS-related options to the secureContext\n    // module.\n    secureContext.validate({ tls, ssl, sslOptions });\n\n    // The value of \"connectTimeout\" should be used to set the TCP\n    // socket timeout and must be a positive integer (including 0).\n    if (!isValidInteger({ value: connectTimeout, min: 0 })) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_CONNECTION_TIMEOUT);\n    }\n\n    // If the custom application attributes are \"undefined\", we still\n    // need to send the default client attributes to the server.\n    // Otherwise, the custom application attributes must be defined\n    // using a plain JavaScript object, false if they are to be\n    // disabled or true, if they are to be ignored.\n    if (!isValidBoolean({ value: connectionAttributes }) && !isValidPlainObject({ value: connectionAttributes })) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_SESSION_ATTRIBUTES_DEFINITION);\n    }\n\n    // If there are custom application attributes we need to validate their\n    // name. Before doing that, we need to make sure we are not bothered by \"undefined\".\n    if (Object.keys(Object.assign({}, connectionAttributes)).some(key => key.startsWith('_'))) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_SESSION_ATTRIBUTE_NAME);\n    }\n\n    // We delegate validation of the SRV-related options to the srv module.\n    srv.validate({ resolveSrv, endpoints, host, port, socket });\n\n    return true;\n};\n\nConnection.VALID_OPTIONS = VALID_OPTIONS;\nConnection.CLIENT_SESSION_ATTRIBUTES = CLIENT_SESSION_ATTRIBUTES;\n\nmodule.exports = Connection;\n"]},"metadata":{},"sourceType":"script"}