{"ast":null,"code":"/*\n * Copyright (c) 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst crypto = require('crypto');\n\nconst errors = require('./constants/errors');\n/**\n * Utitlity wrapper for the core `crypto` module.\n * @private\n */\n\n/**\n * Create an hash composed of a given set of values and options.\n * @private\n * @name module:crypto#createHash\n * @param {string[]} components - hash components\n * @param {Object} [options] - hash function options\n * @returns {Buffer} The resulting Node.js buffer.\n */\n\n\nfunction createHash(components, options) {\n  options = Object.assign({\n    algorithm: 'sha256'\n  }, options);\n  const hash = crypto.createHash(options.algorithm);\n  components.forEach(component => hash.update(component));\n  return hash.digest();\n}\n\n;\n/**\n * Generate a SHA256 hash with an arbitrary number of parameters.\n * @function\n * @name module:crypto#sha256\n * @returns {Buffer} The resulting Node.js buffer.\n */\n\nexports.sha256 = function () {\n  return createHash(Array.prototype.slice.call(arguments));\n};\n/**\n * Generate a SHA1 hash with an arbitrary number of parameters.\n * @function\n * @name module:crypto#sha1\n * @returns {Buffer} The resulting Node.js buffer.\n */\n\n\nexports.sha1 = function () {\n  return createHash(Array.prototype.slice.call(arguments), {\n    algorithm: 'sha1'\n  });\n};\n/**\n * Apply a bitwise xor to the data of two buffers.\n * @function\n * @name module:crypto#xor\n * @param {Buffer} bufferA - a buffer\n * @param {Buffer} bufferB - a buffer\n * @returns {Buffer} The resulting Node.js buffer.\n */\n\n\nexports.xor = function (bufferA, bufferB) {\n  if (bufferA.length !== bufferB.length) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_AUTH_SCRAMBLE_BUFFER_SIZE);\n  } // Since the entire buffer will be written, we should use\n  // \"Buffer.allocUnsafe()\" instead of \"Buffer.alloc()\" because it is faster.\n  // https://nodejs.org/docs/v12.0.0/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe\n\n\n  const output = Buffer.allocUnsafe(bufferA.length);\n\n  for (let i = 0; i < bufferA.length; ++i) {\n    output[i] = bufferA[i] ^ bufferB[i];\n  }\n\n  return output;\n};","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/crypto.js"],"names":["crypto","require","errors","createHash","components","options","Object","assign","algorithm","hash","forEach","component","update","digest","exports","sha256","Array","prototype","slice","call","arguments","sha1","xor","bufferA","bufferB","length","Error","MESSAGES","ER_DEVAPI_BAD_AUTH_SCRAMBLE_BUFFER_SIZE","output","Buffer","allocUnsafe","i"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,oBAAD,CAAtB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,UAAT,CAAqBC,UAArB,EAAiCC,OAAjC,EAA0C;AACtCA,EAAAA,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc;AAAEC,IAAAA,SAAS,EAAE;AAAb,GAAd,EAAuCH,OAAvC,CAAV;AAEA,QAAMI,IAAI,GAAGT,MAAM,CAACG,UAAP,CAAkBE,OAAO,CAACG,SAA1B,CAAb;AACAJ,EAAAA,UAAU,CAACM,OAAX,CAAmBC,SAAS,IAAIF,IAAI,CAACG,MAAL,CAAYD,SAAZ,CAAhC;AAEA,SAAOF,IAAI,CAACI,MAAL,EAAP;AACH;;AAAA;AAED;AACA;AACA;AACA;AACA;AACA;;AACAC,OAAO,CAACC,MAAR,GAAiB,YAAY;AACzB,SAAOZ,UAAU,CAACa,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAD,CAAjB;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACAN,OAAO,CAACO,IAAR,GAAe,YAAY;AACvB,SAAOlB,UAAU,CAACa,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAD,EAAwC;AAAEZ,IAAAA,SAAS,EAAE;AAAb,GAAxC,CAAjB;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAM,OAAO,CAACQ,GAAR,GAAc,UAAUC,OAAV,EAAmBC,OAAnB,EAA4B;AACtC,MAAID,OAAO,CAACE,MAAR,KAAmBD,OAAO,CAACC,MAA/B,EAAuC;AACnC,UAAM,IAAIC,KAAJ,CAAUxB,MAAM,CAACyB,QAAP,CAAgBC,uCAA1B,CAAN;AACH,GAHqC,CAKtC;AACA;AACA;;;AACA,QAAMC,MAAM,GAAGC,MAAM,CAACC,WAAP,CAAmBR,OAAO,CAACE,MAA3B,CAAf;;AAEA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,OAAO,CAACE,MAA5B,EAAoC,EAAEO,CAAtC,EAAyC;AACrCH,IAAAA,MAAM,CAACG,CAAD,CAAN,GAAYT,OAAO,CAACS,CAAD,CAAP,GAAaR,OAAO,CAACQ,CAAD,CAAhC;AACH;;AAED,SAAOH,MAAP;AACH,CAfD","sourcesContent":["/*\n * Copyright (c) 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst errors = require('./constants/errors');\n\n/**\n * Utitlity wrapper for the core `crypto` module.\n * @private\n */\n\n/**\n * Create an hash composed of a given set of values and options.\n * @private\n * @name module:crypto#createHash\n * @param {string[]} components - hash components\n * @param {Object} [options] - hash function options\n * @returns {Buffer} The resulting Node.js buffer.\n */\nfunction createHash (components, options) {\n    options = Object.assign({ algorithm: 'sha256' }, options);\n\n    const hash = crypto.createHash(options.algorithm);\n    components.forEach(component => hash.update(component));\n\n    return hash.digest();\n};\n\n/**\n * Generate a SHA256 hash with an arbitrary number of parameters.\n * @function\n * @name module:crypto#sha256\n * @returns {Buffer} The resulting Node.js buffer.\n */\nexports.sha256 = function () {\n    return createHash(Array.prototype.slice.call(arguments));\n};\n\n/**\n * Generate a SHA1 hash with an arbitrary number of parameters.\n * @function\n * @name module:crypto#sha1\n * @returns {Buffer} The resulting Node.js buffer.\n */\nexports.sha1 = function () {\n    return createHash(Array.prototype.slice.call(arguments), { algorithm: 'sha1' });\n};\n\n/**\n * Apply a bitwise xor to the data of two buffers.\n * @function\n * @name module:crypto#xor\n * @param {Buffer} bufferA - a buffer\n * @param {Buffer} bufferB - a buffer\n * @returns {Buffer} The resulting Node.js buffer.\n */\nexports.xor = function (bufferA, bufferB) {\n    if (bufferA.length !== bufferB.length) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_AUTH_SCRAMBLE_BUFFER_SIZE);\n    }\n\n    // Since the entire buffer will be written, we should use\n    // \"Buffer.allocUnsafe()\" instead of \"Buffer.alloc()\" because it is faster.\n    // https://nodejs.org/docs/v12.0.0/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe\n    const output = Buffer.allocUnsafe(bufferA.length);\n\n    for (let i = 0; i < bufferA.length; ++i) {\n        output[i] = bufferA[i] ^ bufferB[i];\n    }\n\n    return output;\n};\n"]},"metadata":{},"sourceType":"script"}