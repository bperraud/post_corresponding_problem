{"ast":null,"code":"/*\n * Copyright (c) 2020, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst BaseHandler = require('./BaseHandler');\n\nconst NoticeStub = require('../Stubs/mysqlx_notice_pb');\n\nconst columnMetadata = require('../Wrappers/Messages/Resultset/ColumnMetadata');\n\nconst fetchDone = require('../Wrappers/Messages/Resultset/FetchDone');\n\nconst fetchDoneMoreResultsets = require('../Wrappers/Messages/Resultset/FetchDoneMoreResultsets');\n\nconst logger = require('../../logger');\n\nconst notice = require('../Wrappers/Messages/Notice/Frame');\n\nconst row = require('../Wrappers/Messages/Resultset/Row');\n\nconst stmtExecuteOk = require('../Wrappers/Messages/Sql/StmtExecuteOk');\n\nconst util = require('util');\n\nconst log = logger('protocol:inbound:Mysqlx');\n/**\n * @private\n * @param rowcb Callback invoked for each row with an array of fields as single argument\n * @param metacb Optional callback involved when meta data received\n * @constructor\n */\n\nfunction SqlResultHandler(rowcb, metacb) {\n  BaseHandler.call(this);\n  this._currentResultsetMetadata = [];\n  this._metadataForAllResultsets = [];\n  this._metadataHandler = metacb;\n  this._dataHandler = rowcb;\n  this._resultIndex = 0;\n  this._metadataHandlerCalled = false;\n  this._warnings = [];\n  this._generated_insert_id = undefined;\n  this._rows_affected = 0;\n  this._generated_document_ids = [];\n  this._messages = [];\n  this._results = [];\n  this._unhandled_notices = [];\n}\n\nmodule.exports = SqlResultHandler;\nutil.inherits(SqlResultHandler, BaseHandler);\n\nSqlResultHandler.prototype[columnMetadata.MESSAGE_ID] = function (payload) {\n  // The row metadata contains the metadata of each column that is part of\n  // the result set.\n  const inboundColumnMetadata = columnMetadata.deserialize(payload);\n  log.info('Resultset.ColumnMetaData', inboundColumnMetadata); // There is more metadata available (probably a new result set) so we need\n  // to ensure the handler is called again.\n\n  this._metadataHandlerCalled = false; // And save it until the result set is entirely processed.\n\n  this._currentResultsetMetadata.push(inboundColumnMetadata);\n};\n\nSqlResultHandler.prototype[row.MESSAGE_ID] = function (payload) {\n  const metadata = this._currentResultsetMetadata;\n  const inboundRow = row.deserialize(payload).setColumnMetadata(metadata);\n  log.info('Resultset.Row', inboundRow); // If there are no handlers to call, it means the data should be buffered\n  // (but not decoded).\n\n  if (typeof this._metadataHandler !== 'function' && typeof this._dataHandler !== 'function') {\n    this._results[this._resultIndex] = this._results[this._resultIndex] || [];\n\n    this._results[this._resultIndex].push(inboundRow);\n\n    return;\n  } // Otherwise, any handler that is OPTIONALLY provided should be called and\n  // the data properly decoded. Metadata should still be decoded on-demand.\n  // However, column metadata only changes when there is a new result set,\n  // which means the handler should only be called once for each result set.\n\n\n  if (typeof this._metadataHandler === 'function' && !this._metadataHandlerCalled) {\n    this._metadataHandler(metadata); // The metadata for each column of any existing row in the current\n    // result set should have been processed by this point, so, we need to\n    // signal it in order to avoid additional calls to the handler.\n\n\n    this._metadataHandlerCalled = true;\n  } // The data handler should always be a function by this point.\n\n\n  this._dataHandler(inboundRow.toArray());\n};\n\nSqlResultHandler.prototype[fetchDone.MESSAGE_ID] = function (payload) {\n  log.info('Resultset.FetchDone', fetchDone.deserialize(payload)); // although this is the case where there's only one result set, we should build the final list containting it\n\n  this._metadataForAllResultsets.push(this._currentResultsetMetadata); // free up some memory by resetting the unreferenced result set metadata\n\n\n  this._currentResultsetMetadata = [];\n};\n\nSqlResultHandler.prototype[stmtExecuteOk.MESSAGE_ID] = function (payload, queueDone) {\n  log.info('Sql.StmtExecuteOk', stmtExecuteOk.deserialize(payload)); // the entire result set has been consumed, so we need to reset the internal\n\n  this._resultIndex = 0; // we're done with processing the current job in the queue\n\n  queueDone();\n\n  this._resolve({\n    results: this._results,\n    generatedDocumentIds: this._generated_document_ids,\n    generatedInsertId: this._generated_insert_id,\n    messages: this._messages,\n    metadata: this._metadataForAllResultsets,\n    rowsAffected: this._rows_affected,\n    warnings: this._warnings\n  });\n};\n\nSqlResultHandler.prototype[fetchDoneMoreResultsets.MESSAGE_ID] = function (payload) {\n  log.info('Resultset.FetchDoneMoreResultsets', fetchDoneMoreResultsets.deserialize(payload)); // append the current result set metadata to the list containting the metadata of all result sets\n\n  this._metadataForAllResultsets.push(this._currentResultsetMetadata); // free up some memory by resetting the unreferenced result set metadata\n\n\n  this._currentResultsetMetadata = []; // make sure the current result set is properly initialized in case it comes empty from the server\n\n  if (!this._results[this._resultIndex]) {\n    this._results[this._resultIndex] = [];\n  } // there are more result sets to consume, so we need to increment the global result set iterator\n\n\n  this._resultIndex += 1;\n};\n\nSqlResultHandler.prototype[notice.MESSAGE_ID] = function (payload) {\n  const inboundNotice = notice.deserialize(payload);\n  log.info('Notice.Frame', inboundNotice);\n  const frame = inboundNotice.toObject();\n\n  switch (frame.type) {\n    case NoticeStub.Frame.Type.WARNING:\n      return this._warnings.push(frame.warning);\n\n    case NoticeStub.Frame.Type.SESSION_STATE_CHANGED:\n      switch (frame.state.type) {\n        case NoticeStub.SessionStateChanged.Parameter.GENERATED_DOCUMENT_IDS:\n          // document ids are encoded as V_OCTETS but they should only be decoded on demand\n          // see module:Result#getGeneratedIds\n          this._generated_document_ids = this._generated_document_ids.concat(frame.state.values);\n          return;\n\n        case NoticeStub.SessionStateChanged.Parameter.GENERATED_INSERT_ID:\n          this._generated_insert_id = frame.state.values[0];\n          return;\n\n        case NoticeStub.SessionStateChanged.Parameter.ROWS_AFFECTED:\n          this._rows_affected = frame.state.values[0];\n          return;\n\n        case NoticeStub.SessionStateChanged.Parameter.PRODUCED_MESSAGE:\n          this._messages = this._messages.concat(frame.state.values);\n          return;\n\n        default:\n          break;\n      }\n\n      break;\n\n    default:\n      return this._unhandled_notices.push(frame.variable);\n  }\n\n  ;\n};","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/Protocol/InboundHandlers/SqlResultHandler.js"],"names":["BaseHandler","require","NoticeStub","columnMetadata","fetchDone","fetchDoneMoreResultsets","logger","notice","row","stmtExecuteOk","util","log","SqlResultHandler","rowcb","metacb","call","_currentResultsetMetadata","_metadataForAllResultsets","_metadataHandler","_dataHandler","_resultIndex","_metadataHandlerCalled","_warnings","_generated_insert_id","undefined","_rows_affected","_generated_document_ids","_messages","_results","_unhandled_notices","module","exports","inherits","prototype","MESSAGE_ID","payload","inboundColumnMetadata","deserialize","info","push","metadata","inboundRow","setColumnMetadata","toArray","queueDone","_resolve","results","generatedDocumentIds","generatedInsertId","messages","rowsAffected","warnings","inboundNotice","frame","toObject","type","Frame","Type","WARNING","warning","SESSION_STATE_CHANGED","state","SessionStateChanged","Parameter","GENERATED_DOCUMENT_IDS","concat","values","GENERATED_INSERT_ID","ROWS_AFFECTED","PRODUCED_MESSAGE","variable"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2020, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst BaseHandler = require('./BaseHandler');\nconst NoticeStub = require('../Stubs/mysqlx_notice_pb');\nconst columnMetadata = require('../Wrappers/Messages/Resultset/ColumnMetadata');\nconst fetchDone = require('../Wrappers/Messages/Resultset/FetchDone');\nconst fetchDoneMoreResultsets = require('../Wrappers/Messages/Resultset/FetchDoneMoreResultsets');\nconst logger = require('../../logger');\nconst notice = require('../Wrappers/Messages/Notice/Frame');\nconst row = require('../Wrappers/Messages/Resultset/Row');\nconst stmtExecuteOk = require('../Wrappers/Messages/Sql/StmtExecuteOk');\nconst util = require('util');\n\nconst log = logger('protocol:inbound:Mysqlx');\n\n/**\n * @private\n * @param rowcb Callback invoked for each row with an array of fields as single argument\n * @param metacb Optional callback involved when meta data received\n * @constructor\n */\nfunction SqlResultHandler (rowcb, metacb) {\n    BaseHandler.call(this);\n\n    this._currentResultsetMetadata = [];\n    this._metadataForAllResultsets = [];\n\n    this._metadataHandler = metacb;\n    this._dataHandler = rowcb;\n\n    this._resultIndex = 0;\n    this._metadataHandlerCalled = false;\n\n    this._warnings = [];\n    this._generated_insert_id = undefined;\n    this._rows_affected = 0;\n    this._generated_document_ids = [];\n    this._messages = [];\n    this._results = [];\n\n    this._unhandled_notices = [];\n}\n\nmodule.exports = SqlResultHandler;\n\nutil.inherits(SqlResultHandler, BaseHandler);\n\nSqlResultHandler.prototype[columnMetadata.MESSAGE_ID] = function (payload) {\n    // The row metadata contains the metadata of each column that is part of\n    // the result set.\n    const inboundColumnMetadata = columnMetadata.deserialize(payload);\n    log.info('Resultset.ColumnMetaData', inboundColumnMetadata);\n\n    // There is more metadata available (probably a new result set) so we need\n    // to ensure the handler is called again.\n    this._metadataHandlerCalled = false;\n\n    // And save it until the result set is entirely processed.\n    this._currentResultsetMetadata.push(inboundColumnMetadata);\n};\n\nSqlResultHandler.prototype[row.MESSAGE_ID] = function (payload) {\n    const metadata = this._currentResultsetMetadata;\n\n    const inboundRow = row.deserialize(payload).setColumnMetadata(metadata);\n    log.info('Resultset.Row', inboundRow);\n\n    // If there are no handlers to call, it means the data should be buffered\n    // (but not decoded).\n    if (typeof this._metadataHandler !== 'function' && typeof this._dataHandler !== 'function') {\n        this._results[this._resultIndex] = this._results[this._resultIndex] || [];\n        this._results[this._resultIndex].push(inboundRow);\n\n        return;\n    }\n\n    // Otherwise, any handler that is OPTIONALLY provided should be called and\n    // the data properly decoded. Metadata should still be decoded on-demand.\n    // However, column metadata only changes when there is a new result set,\n    // which means the handler should only be called once for each result set.\n    if (typeof this._metadataHandler === 'function' && !this._metadataHandlerCalled) {\n        this._metadataHandler(metadata);\n        // The metadata for each column of any existing row in the current\n        // result set should have been processed by this point, so, we need to\n        // signal it in order to avoid additional calls to the handler.\n        this._metadataHandlerCalled = true;\n    }\n\n    // The data handler should always be a function by this point.\n    this._dataHandler(inboundRow.toArray());\n};\n\nSqlResultHandler.prototype[fetchDone.MESSAGE_ID] = function (payload) {\n    log.info('Resultset.FetchDone', fetchDone.deserialize(payload));\n\n    // although this is the case where there's only one result set, we should build the final list containting it\n    this._metadataForAllResultsets.push(this._currentResultsetMetadata);\n    // free up some memory by resetting the unreferenced result set metadata\n    this._currentResultsetMetadata = [];\n};\n\nSqlResultHandler.prototype[stmtExecuteOk.MESSAGE_ID] = function (payload, queueDone) {\n    log.info('Sql.StmtExecuteOk', stmtExecuteOk.deserialize(payload));\n\n    // the entire result set has been consumed, so we need to reset the internal\n    this._resultIndex = 0;\n\n    // we're done with processing the current job in the queue\n    queueDone();\n\n    this._resolve({\n        results: this._results,\n        generatedDocumentIds: this._generated_document_ids,\n        generatedInsertId: this._generated_insert_id,\n        messages: this._messages,\n        metadata: this._metadataForAllResultsets,\n        rowsAffected: this._rows_affected,\n        warnings: this._warnings\n    });\n};\n\nSqlResultHandler.prototype[fetchDoneMoreResultsets.MESSAGE_ID] = function (payload) {\n    log.info('Resultset.FetchDoneMoreResultsets', fetchDoneMoreResultsets.deserialize(payload));\n\n    // append the current result set metadata to the list containting the metadata of all result sets\n    this._metadataForAllResultsets.push(this._currentResultsetMetadata);\n    // free up some memory by resetting the unreferenced result set metadata\n    this._currentResultsetMetadata = [];\n\n    // make sure the current result set is properly initialized in case it comes empty from the server\n    if (!this._results[this._resultIndex]) {\n        this._results[this._resultIndex] = [];\n    }\n\n    // there are more result sets to consume, so we need to increment the global result set iterator\n    this._resultIndex += 1;\n};\n\nSqlResultHandler.prototype[notice.MESSAGE_ID] = function (payload) {\n    const inboundNotice = notice.deserialize(payload);\n    log.info('Notice.Frame', inboundNotice);\n\n    const frame = inboundNotice.toObject();\n\n    switch (frame.type) {\n    case NoticeStub.Frame.Type.WARNING:\n        return this._warnings.push(frame.warning);\n    case NoticeStub.Frame.Type.SESSION_STATE_CHANGED:\n        switch (frame.state.type) {\n        case NoticeStub.SessionStateChanged.Parameter.GENERATED_DOCUMENT_IDS:\n            // document ids are encoded as V_OCTETS but they should only be decoded on demand\n            // see module:Result#getGeneratedIds\n            this._generated_document_ids = this._generated_document_ids.concat(frame.state.values);\n            return;\n        case NoticeStub.SessionStateChanged.Parameter.GENERATED_INSERT_ID:\n            this._generated_insert_id = frame.state.values[0];\n            return;\n        case NoticeStub.SessionStateChanged.Parameter.ROWS_AFFECTED:\n            this._rows_affected = frame.state.values[0];\n            return;\n        case NoticeStub.SessionStateChanged.Parameter.PRODUCED_MESSAGE:\n            this._messages = this._messages.concat(frame.state.values);\n            return;\n        default:\n            break;\n        }\n        break;\n    default:\n        return this._unhandled_notices.push(frame.variable);\n    };\n};\n"]},"metadata":{},"sourceType":"script"}