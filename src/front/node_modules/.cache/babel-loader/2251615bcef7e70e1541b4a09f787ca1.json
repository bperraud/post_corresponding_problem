{"ast":null,"code":"/*\n * Copyright (c) 2020, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst ExprStub = require('../../../Stubs/mysqlx_expr_pb');\n\nconst columnIdentifier = require('./ColumnIdentifier');\n\nconst optionalString = require('../../Traits/OptionalString');\n\nconst parser = require('../../../../ExprParser');\n\nconst scalar = require('../Datatypes/Scalar');\n\nconst wraps = require('../../Traits/Wraps');\n/**\n * Parse an X DevAPI expression.\n * @private\n * @param {string} value - the expression string\n * @param {Object} [options] - parsing options\n */\n\n\nfunction parseExpression(value, options) {\n  options = Object.assign({}, {\n    toPrepare: false\n  }, options);\n  const parsedExpression = parser.parse(value, options);\n  const expr = Expr(parsedExpression.output); // placeholder values should be assigned only if the statement\n  // is not being prepared\n\n  if (!options.toPrepare) {\n    expr.setPlaceholders(parsedExpression.placeholders);\n  }\n\n  return expr;\n}\n\n;\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Array\n * @param {proto.Mysqlx.Expr.Array} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Array}\n */\n\nfunction pArray(proto) {\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Array#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      return {\n        value: proto.getValueList().map(val => Expr(val).toJSON())\n      };\n    }\n\n  });\n}\n/**\n * Checks if a value can be encoded as a Mysqlx.Expr.Array.\n * @private\n * @returns {boolean}\n */\n\n\npArray.canEncode = function (value) {\n  return Array.isArray(value);\n};\n/**\n * Creates a wrapper of a generic Mysqlx.Expr.Array instance given a list of values.\n * @private\n * @returns {module:adapters.Mysqlx.Expr.Array}\n */\n\n\npArray.create = function (values) {\n  const proto = new ExprStub.Array();\n  proto.setValueList(values.map(v => Expr.create(v).valueOf()));\n  return pArray(proto);\n};\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Identifier\n * @param {proto.Mysqlx.Expr.Identifier} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Identifier}\n */\n\n\nfunction pIdentifier(proto) {\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Identifier#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      return {\n        name: proto.getName(),\n        schema_name: optionalString(proto.getSchemaName()).toJSON()\n      };\n    }\n\n  });\n}\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.FunctionCall\n * @param {proto.Mysqlx.Expr.FunctionCall} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.FunctionCall}\n */\n\n\nfunction pFunctionCall(proto) {\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.FunctionCall#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      return {\n        name: pIdentifier(proto.getName()).toJSON(),\n        param: proto.getParamList().map(p => Expr(p).toJSON())\n      };\n    }\n\n  });\n}\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Object\n * @param {proto.Mysqlx.Expr.Object} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Object}\n */\n\n\nfunction pObject(proto) {\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Object#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      return {\n        fld: proto.getFldList().map(field => pObjectField(field).toJSON())\n      };\n    }\n\n  });\n}\n/**\n * Creates a wrapper of a generic Mysqlx.Expr.Object instance give the field mapping.\n * @private\n * @returns {module:adapters.Mysqlx.Expr.Object}\n */\n\n\npObject.create = function (fields) {\n  const proto = new ExprStub.Object();\n  proto.setFldList(Object.keys(fields).map(k => pObjectField.create(k, fields[k]).valueOf()));\n  return pObject(proto);\n};\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Object.ObjectField\n * @param {proto.Mysqlx.Expr.Object.ObjectField} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Object.ObjectField}\n */\n\n\nfunction pObjectField(proto) {\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Object.ObjectField#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      return {\n        key: proto.getKey(),\n        value: Expr(proto.getValue()).toJSON()\n      };\n    }\n\n  });\n}\n/**\n * Creates a wrapper of a generic Mysqlx.Expr.Object.ObjectField instance given a key and value.\n * @private\n * @returns {module:adapters.Mysqlx.Expr.Object.ObjectField}\n */\n\n\npObjectField.create = function (key, value) {\n  const proto = new ExprStub.Object.ObjectField();\n  proto.setKey(key);\n  proto.setValue(Expr.create(value).valueOf());\n  return pObjectField(proto);\n};\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Operator\n * @param {proto.Mysqlx.Expr.Operator} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Operator}\n */\n\n\nfunction pOperator(proto) {\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Operator#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      return {\n        name: proto.getName(),\n        param: proto.getParamList().map(p => Expr(p).toJSON())\n      };\n    }\n\n  });\n}\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Expr\n * @param {proto.Mysqlx.Expr.Expr} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Expr}\n */\n\n\nfunction Expr(proto) {\n  const state = {\n    placeholders: []\n  };\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Retrieve the ordered list of arguments to assign to the existing placeholders.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Expr#getPlaceholderArgs\n     * @returns {Array<proto.Mysqlx.Datatypes.Scalar>} The list of protobuf instances.\n     */\n    getPlaceholderArgs(bindings) {\n      return state.placeholders.map(p => scalar.create(bindings[p]).valueOf());\n    },\n\n    /**\n     * Retrieve the expression type name.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Expr#getType\n     * @returns {string}\n     */\n    getType() {\n      return Object.keys(ExprStub.Expr.Type).filter(k => ExprStub.Expr.Type[k] === proto.getType())[0];\n    },\n\n    /**\n     * Set the ordered list of placeholder names used in the expression.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Expr#setPlaceholders\n     * @returns {module:adapters.Mysqlx.Expr.Expr} The expression wrapper instance\n     */\n    setPlaceholders(placeholders) {\n      state.placeholders = placeholders;\n      return this;\n    },\n\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @function\n     * @name module:adapters.Mysqlx.Expr.Expr#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      // since stub instances get assigned a default type, the exit\n      // criteria should be the case where \"proto\" is not defined\n      if (typeof proto === 'undefined') {\n        // we want the field to be ignored in the parent object\n        return;\n      }\n\n      const type = this.getType();\n\n      switch (proto.getType()) {\n        case ExprStub.Expr.Type.IDENT:\n          return {\n            type,\n            identifier: columnIdentifier(proto.getIdentifier()).toJSON()\n          };\n\n        case ExprStub.Expr.Type.LITERAL:\n          return {\n            type,\n            literal: scalar(proto.getLiteral()).toJSON()\n          };\n\n        case ExprStub.Expr.Type.VARIABLE:\n          return {\n            type,\n            variable: optionalString(proto.getVariable()).toJSON()\n          };\n\n        case ExprStub.Expr.Type.FUNC_CALL:\n          return {\n            type,\n            function_call: pFunctionCall(proto.getFunctionCall()).toJSON()\n          };\n\n        case ExprStub.Expr.Type.OPERATOR:\n          return {\n            type,\n            operator: pOperator(proto.getOperator()).toJSON()\n          };\n\n        case ExprStub.Expr.Type.PLACEHOLDER:\n          return {\n            type,\n            position: proto.getPosition()\n          };\n\n        case ExprStub.Expr.Type.OBJECT:\n          return {\n            type,\n            object: pObject(proto.getObject()).toJSON()\n          };\n\n        case ExprStub.Expr.Type.ARRAY:\n          return {\n            type,\n            array: pArray(proto.getArray()).toJSON()\n          };\n      }\n    }\n\n  });\n}\n/**\n * Creates a wrapper of a generic Mysqlx.Expr.Expr instance for a given value or expression.\n * @returns {module:adapters.Mysqlx.Expr.Expr}\n */\n\n\nExpr.create = function (value, options) {\n  options = Object.assign({}, {\n    toParse: false,\n    isPlaceholder: false\n  }, options); // if the value is a raw string expression, we should parse it\n\n  if (typeof value === 'string' && options.toParse) {\n    return parseExpression(value, options);\n  } // if it is not provided, there's nothing to do\n  // we can't create a wrapper with an empty stub instance because it gets\n  // assigned a default type and it would mess with the \"toJSON()\" logic\n\n\n  if (typeof value === 'undefined') {\n    return Expr();\n  } // if the value it's already an expression protobuf message, we can simply wrap it\n\n\n  if (value instanceof ExprStub.Expr) {\n    return Expr(value);\n  } // otherwise we need to create one\n\n\n  const proto = new ExprStub.Expr(); // if the value is a number, we first need to check if it represents a\n  // placeholder position\n\n  if (options.isPlaceholder) {\n    proto.setType(ExprStub.Expr.Type.PLACEHOLDER);\n    proto.setPosition(value);\n  } else if (scalar.canEncode(value)) {\n    // if the value is an object, we first need to check if it can be\n    // encoded as a Scalar (e.g. Buffer and Date)\n    proto.setType(ExprStub.Expr.Type.LITERAL);\n    proto.setLiteral(scalar.create(value).valueOf());\n  } else if (pArray.canEncode(value)) {\n    proto.setType(ExprStub.Expr.Type.ARRAY);\n    proto.setArray(pArray.create(value).valueOf());\n  } else {\n    // ultimately, in JavaScript everything else is an object\n    proto.setType(ExprStub.Expr.Type.OBJECT);\n    proto.setObject(pObject.create(value).valueOf());\n  }\n\n  return Expr(proto);\n};\n\nmodule.exports = Expr;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/Protocol/Wrappers/Messages/Expr/Expr.js"],"names":["ExprStub","require","columnIdentifier","optionalString","parser","scalar","wraps","parseExpression","value","options","Object","assign","toPrepare","parsedExpression","parse","expr","Expr","output","setPlaceholders","placeholders","pArray","proto","toJSON","getValueList","map","val","canEncode","Array","isArray","create","values","setValueList","v","valueOf","pIdentifier","name","getName","schema_name","getSchemaName","pFunctionCall","param","getParamList","p","pObject","fld","getFldList","field","pObjectField","fields","setFldList","keys","k","key","getKey","getValue","ObjectField","setKey","setValue","pOperator","state","getPlaceholderArgs","bindings","getType","Type","filter","type","IDENT","identifier","getIdentifier","LITERAL","literal","getLiteral","VARIABLE","variable","getVariable","FUNC_CALL","function_call","getFunctionCall","OPERATOR","operator","getOperator","PLACEHOLDER","position","getPosition","OBJECT","object","getObject","ARRAY","array","getArray","toParse","isPlaceholder","setType","setPosition","setLiteral","setArray","setObject","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,+BAAD,CAAxB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,oBAAD,CAAhC;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,6BAAD,CAA9B;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,wBAAD,CAAtB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,qBAAD,CAAtB;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,oBAAD,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,eAAT,CAA0BC,KAA1B,EAAiCC,OAAjC,EAA0C;AACtCA,EAAAA,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB;AAAEC,IAAAA,SAAS,EAAE;AAAb,GAAlB,EAAwCH,OAAxC,CAAV;AAEA,QAAMI,gBAAgB,GAAGT,MAAM,CAACU,KAAP,CAAaN,KAAb,EAAoBC,OAApB,CAAzB;AACA,QAAMM,IAAI,GAAGC,IAAI,CAACH,gBAAgB,CAACI,MAAlB,CAAjB,CAJsC,CAMtC;AACA;;AACA,MAAI,CAACR,OAAO,CAACG,SAAb,EAAwB;AACpBG,IAAAA,IAAI,CAACG,eAAL,CAAqBL,gBAAgB,CAACM,YAAtC;AACH;;AAED,SAAOJ,IAAP;AACH;;AAAA;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,SAASK,MAAT,CAAiBC,KAAjB,EAAwB;AACpB,SAAOX,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAK,CAACe,KAAD,CAAvB,EAAgC;AACnC;AACR;AACA;AACA;AACA;AACA;AACQC,IAAAA,MAAM,GAAI;AACN,aAAO;AACHd,QAAAA,KAAK,EAAEa,KAAK,CAACE,YAAN,GAAqBC,GAArB,CAAyBC,GAAG,IAAIT,IAAI,CAACS,GAAD,CAAJ,CAAUH,MAAV,EAAhC;AADJ,OAAP;AAGH;;AAXkC,GAAhC,CAAP;AAaH;AAED;AACA;AACA;AACA;AACA;;;AACAF,MAAM,CAACM,SAAP,GAAmB,UAAUlB,KAAV,EAAiB;AAChC,SAAOmB,KAAK,CAACC,OAAN,CAAcpB,KAAd,CAAP;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAY,MAAM,CAACS,MAAP,GAAgB,UAAUC,MAAV,EAAkB;AAC9B,QAAMT,KAAK,GAAG,IAAIrB,QAAQ,CAAC2B,KAAb,EAAd;AACAN,EAAAA,KAAK,CAACU,YAAN,CAAmBD,MAAM,CAACN,GAAP,CAAWQ,CAAC,IAAIhB,IAAI,CAACa,MAAL,CAAYG,CAAZ,EAAeC,OAAf,EAAhB,CAAnB;AAEA,SAAOb,MAAM,CAACC,KAAD,CAAb;AACH,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASa,WAAT,CAAsBb,KAAtB,EAA6B;AACzB,SAAOX,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAK,CAACe,KAAD,CAAvB,EAAgC;AACnC;AACR;AACA;AACA;AACA;AACA;AACQC,IAAAA,MAAM,GAAI;AACN,aAAO;AACHa,QAAAA,IAAI,EAAEd,KAAK,CAACe,OAAN,EADH;AAEHC,QAAAA,WAAW,EAAElC,cAAc,CAACkB,KAAK,CAACiB,aAAN,EAAD,CAAd,CAAsChB,MAAtC;AAFV,OAAP;AAIH;;AAZkC,GAAhC,CAAP;AAcH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiB,aAAT,CAAwBlB,KAAxB,EAA+B;AAC3B,SAAOX,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAK,CAACe,KAAD,CAAvB,EAAgC;AACnC;AACR;AACA;AACA;AACA;AACA;AACQC,IAAAA,MAAM,GAAI;AACN,aAAO;AACHa,QAAAA,IAAI,EAAED,WAAW,CAACb,KAAK,CAACe,OAAN,EAAD,CAAX,CAA6Bd,MAA7B,EADH;AAEHkB,QAAAA,KAAK,EAAEnB,KAAK,CAACoB,YAAN,GAAqBjB,GAArB,CAAyBkB,CAAC,IAAI1B,IAAI,CAAC0B,CAAD,CAAJ,CAAQpB,MAAR,EAA9B;AAFJ,OAAP;AAIH;;AAZkC,GAAhC,CAAP;AAcH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqB,OAAT,CAAkBtB,KAAlB,EAAyB;AACrB,SAAOX,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAK,CAACe,KAAD,CAAvB,EAAgC;AACnC;AACR;AACA;AACA;AACA;AACA;AACQC,IAAAA,MAAM,GAAI;AACN,aAAO;AACHsB,QAAAA,GAAG,EAAEvB,KAAK,CAACwB,UAAN,GAAmBrB,GAAnB,CAAuBsB,KAAK,IAAIC,YAAY,CAACD,KAAD,CAAZ,CAAoBxB,MAApB,EAAhC;AADF,OAAP;AAGH;;AAXkC,GAAhC,CAAP;AAaH;AAED;AACA;AACA;AACA;AACA;;;AACAqB,OAAO,CAACd,MAAR,GAAiB,UAAUmB,MAAV,EAAkB;AAC/B,QAAM3B,KAAK,GAAG,IAAIrB,QAAQ,CAACU,MAAb,EAAd;AACAW,EAAAA,KAAK,CAAC4B,UAAN,CAAiBvC,MAAM,CAACwC,IAAP,CAAYF,MAAZ,EAAoBxB,GAApB,CAAwB2B,CAAC,IAAIJ,YAAY,CAAClB,MAAb,CAAoBsB,CAApB,EAAuBH,MAAM,CAACG,CAAD,CAA7B,EAAkClB,OAAlC,EAA7B,CAAjB;AAEA,SAAOU,OAAO,CAACtB,KAAD,CAAd;AACH,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS0B,YAAT,CAAuB1B,KAAvB,EAA8B;AAC1B,SAAOX,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAK,CAACe,KAAD,CAAvB,EAAgC;AACnC;AACR;AACA;AACA;AACA;AACA;AACQC,IAAAA,MAAM,GAAI;AACN,aAAO;AACH8B,QAAAA,GAAG,EAAE/B,KAAK,CAACgC,MAAN,EADF;AAEH7C,QAAAA,KAAK,EAAEQ,IAAI,CAACK,KAAK,CAACiC,QAAN,EAAD,CAAJ,CAAuBhC,MAAvB;AAFJ,OAAP;AAIH;;AAZkC,GAAhC,CAAP;AAcH;AAED;AACA;AACA;AACA;AACA;;;AACAyB,YAAY,CAAClB,MAAb,GAAsB,UAAUuB,GAAV,EAAe5C,KAAf,EAAsB;AACxC,QAAMa,KAAK,GAAG,IAAIrB,QAAQ,CAACU,MAAT,CAAgB6C,WAApB,EAAd;AACAlC,EAAAA,KAAK,CAACmC,MAAN,CAAaJ,GAAb;AACA/B,EAAAA,KAAK,CAACoC,QAAN,CAAezC,IAAI,CAACa,MAAL,CAAYrB,KAAZ,EAAmByB,OAAnB,EAAf;AAEA,SAAOc,YAAY,CAAC1B,KAAD,CAAnB;AACH,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqC,SAAT,CAAoBrC,KAApB,EAA2B;AACvB,SAAOX,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAK,CAACe,KAAD,CAAvB,EAAgC;AACnC;AACR;AACA;AACA;AACA;AACA;AACQC,IAAAA,MAAM,GAAI;AACN,aAAO;AACHa,QAAAA,IAAI,EAAEd,KAAK,CAACe,OAAN,EADH;AAEHI,QAAAA,KAAK,EAAEnB,KAAK,CAACoB,YAAN,GAAqBjB,GAArB,CAAyBkB,CAAC,IAAI1B,IAAI,CAAC0B,CAAD,CAAJ,CAAQpB,MAAR,EAA9B;AAFJ,OAAP;AAIH;;AAZkC,GAAhC,CAAP;AAcH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASN,IAAT,CAAeK,KAAf,EAAsB;AAClB,QAAMsC,KAAK,GAAG;AAAExC,IAAAA,YAAY,EAAE;AAAhB,GAAd;AAEA,SAAOT,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAK,CAACe,KAAD,CAAvB,EAAgC;AACnC;AACR;AACA;AACA;AACA;AACA;AACQuC,IAAAA,kBAAkB,CAAEC,QAAF,EAAY;AAC1B,aAAOF,KAAK,CAACxC,YAAN,CAAmBK,GAAnB,CAAuBkB,CAAC,IAAIrC,MAAM,CAACwB,MAAP,CAAcgC,QAAQ,CAACnB,CAAD,CAAtB,EAA2BT,OAA3B,EAA5B,CAAP;AACH,KATkC;;AAWnC;AACR;AACA;AACA;AACA;AACA;AACQ6B,IAAAA,OAAO,GAAI;AACP,aAAOpD,MAAM,CAACwC,IAAP,CAAYlD,QAAQ,CAACgB,IAAT,CAAc+C,IAA1B,EACFC,MADE,CACKb,CAAC,IAAInD,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBZ,CAAnB,MAA0B9B,KAAK,CAACyC,OAAN,EADpC,EACqD,CADrD,CAAP;AAEH,KApBkC;;AAsBnC;AACR;AACA;AACA;AACA;AACA;AACQ5C,IAAAA,eAAe,CAAEC,YAAF,EAAgB;AAC3BwC,MAAAA,KAAK,CAACxC,YAAN,GAAqBA,YAArB;AAEA,aAAO,IAAP;AACH,KAhCkC;;AAkCnC;AACR;AACA;AACA;AACA;AACA;AACQG,IAAAA,MAAM,GAAI;AACN;AACA;AACA,UAAI,OAAOD,KAAP,KAAiB,WAArB,EAAkC;AAC9B;AACA;AACH;;AAED,YAAM4C,IAAI,GAAG,KAAKH,OAAL,EAAb;;AAEA,cAAQzC,KAAK,CAACyC,OAAN,EAAR;AACA,aAAK9D,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBG,KAAxB;AACI,iBAAO;AAAED,YAAAA,IAAF;AAAQE,YAAAA,UAAU,EAAEjE,gBAAgB,CAACmB,KAAK,CAAC+C,aAAN,EAAD,CAAhB,CAAwC9C,MAAxC;AAApB,WAAP;;AACJ,aAAKtB,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBM,OAAxB;AACI,iBAAO;AAAEJ,YAAAA,IAAF;AAAQK,YAAAA,OAAO,EAAEjE,MAAM,CAACgB,KAAK,CAACkD,UAAN,EAAD,CAAN,CAA2BjD,MAA3B;AAAjB,WAAP;;AACJ,aAAKtB,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBS,QAAxB;AACI,iBAAO;AAAEP,YAAAA,IAAF;AAAQQ,YAAAA,QAAQ,EAAEtE,cAAc,CAACkB,KAAK,CAACqD,WAAN,EAAD,CAAd,CAAoCpD,MAApC;AAAlB,WAAP;;AACJ,aAAKtB,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBY,SAAxB;AACI,iBAAO;AAAEV,YAAAA,IAAF;AAAQW,YAAAA,aAAa,EAAErC,aAAa,CAAClB,KAAK,CAACwD,eAAN,EAAD,CAAb,CAAuCvD,MAAvC;AAAvB,WAAP;;AACJ,aAAKtB,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBe,QAAxB;AACI,iBAAO;AAAEb,YAAAA,IAAF;AAAQc,YAAAA,QAAQ,EAAErB,SAAS,CAACrC,KAAK,CAAC2D,WAAN,EAAD,CAAT,CAA+B1D,MAA/B;AAAlB,WAAP;;AACJ,aAAKtB,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBkB,WAAxB;AACI,iBAAO;AAAEhB,YAAAA,IAAF;AAAQiB,YAAAA,QAAQ,EAAE7D,KAAK,CAAC8D,WAAN;AAAlB,WAAP;;AACJ,aAAKnF,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBqB,MAAxB;AACI,iBAAO;AAAEnB,YAAAA,IAAF;AAAQoB,YAAAA,MAAM,EAAE1C,OAAO,CAACtB,KAAK,CAACiE,SAAN,EAAD,CAAP,CAA2BhE,MAA3B;AAAhB,WAAP;;AACJ,aAAKtB,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBwB,KAAxB;AACI,iBAAO;AAAEtB,YAAAA,IAAF;AAAQuB,YAAAA,KAAK,EAAEpE,MAAM,CAACC,KAAK,CAACoE,QAAN,EAAD,CAAN,CAAyBnE,MAAzB;AAAf,WAAP;AAhBJ;AAkBH;;AApEkC,GAAhC,CAAP;AAsEH;AAED;AACA;AACA;AACA;;;AACAN,IAAI,CAACa,MAAL,GAAc,UAAUrB,KAAV,EAAiBC,OAAjB,EAA0B;AACpCA,EAAAA,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB;AAAE+E,IAAAA,OAAO,EAAE,KAAX;AAAkBC,IAAAA,aAAa,EAAE;AAAjC,GAAlB,EAA4DlF,OAA5D,CAAV,CADoC,CAGpC;;AACA,MAAI,OAAOD,KAAP,KAAiB,QAAjB,IAA6BC,OAAO,CAACiF,OAAzC,EAAkD;AAC9C,WAAOnF,eAAe,CAACC,KAAD,EAAQC,OAAR,CAAtB;AACH,GANmC,CAQpC;AACA;AACA;;;AACA,MAAI,OAAOD,KAAP,KAAiB,WAArB,EAAkC;AAC9B,WAAOQ,IAAI,EAAX;AACH,GAbmC,CAepC;;;AACA,MAAIR,KAAK,YAAYR,QAAQ,CAACgB,IAA9B,EAAoC;AAChC,WAAOA,IAAI,CAACR,KAAD,CAAX;AACH,GAlBmC,CAoBpC;;;AACA,QAAMa,KAAK,GAAG,IAAIrB,QAAQ,CAACgB,IAAb,EAAd,CArBoC,CAuBpC;AACA;;AACA,MAAIP,OAAO,CAACkF,aAAZ,EAA2B;AACvBtE,IAAAA,KAAK,CAACuE,OAAN,CAAc5F,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBkB,WAAjC;AACA5D,IAAAA,KAAK,CAACwE,WAAN,CAAkBrF,KAAlB;AACH,GAHD,MAGO,IAAIH,MAAM,CAACqB,SAAP,CAAiBlB,KAAjB,CAAJ,EAA6B;AAChC;AACA;AACAa,IAAAA,KAAK,CAACuE,OAAN,CAAc5F,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBM,OAAjC;AACAhD,IAAAA,KAAK,CAACyE,UAAN,CAAiBzF,MAAM,CAACwB,MAAP,CAAcrB,KAAd,EAAqByB,OAArB,EAAjB;AACH,GALM,MAKA,IAAIb,MAAM,CAACM,SAAP,CAAiBlB,KAAjB,CAAJ,EAA6B;AAChCa,IAAAA,KAAK,CAACuE,OAAN,CAAc5F,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBwB,KAAjC;AACAlE,IAAAA,KAAK,CAAC0E,QAAN,CAAe3E,MAAM,CAACS,MAAP,CAAcrB,KAAd,EAAqByB,OAArB,EAAf;AACH,GAHM,MAGA;AACH;AACAZ,IAAAA,KAAK,CAACuE,OAAN,CAAc5F,QAAQ,CAACgB,IAAT,CAAc+C,IAAd,CAAmBqB,MAAjC;AACA/D,IAAAA,KAAK,CAAC2E,SAAN,CAAgBrD,OAAO,CAACd,MAAR,CAAerB,KAAf,EAAsByB,OAAtB,EAAhB;AACH;;AAED,SAAOjB,IAAI,CAACK,KAAD,CAAX;AACH,CA3CD;;AA6CA4E,MAAM,CAACC,OAAP,GAAiBlF,IAAjB","sourcesContent":["/*\n * Copyright (c) 2020, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst ExprStub = require('../../../Stubs/mysqlx_expr_pb');\nconst columnIdentifier = require('./ColumnIdentifier');\nconst optionalString = require('../../Traits/OptionalString');\nconst parser = require('../../../../ExprParser');\nconst scalar = require('../Datatypes/Scalar');\nconst wraps = require('../../Traits/Wraps');\n\n/**\n * Parse an X DevAPI expression.\n * @private\n * @param {string} value - the expression string\n * @param {Object} [options] - parsing options\n */\nfunction parseExpression (value, options) {\n    options = Object.assign({}, { toPrepare: false }, options);\n\n    const parsedExpression = parser.parse(value, options);\n    const expr = Expr(parsedExpression.output);\n\n    // placeholder values should be assigned only if the statement\n    // is not being prepared\n    if (!options.toPrepare) {\n        expr.setPlaceholders(parsedExpression.placeholders);\n    }\n\n    return expr;\n};\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Array\n * @param {proto.Mysqlx.Expr.Array} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Array}\n */\nfunction pArray (proto) {\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Array#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            return {\n                value: proto.getValueList().map(val => Expr(val).toJSON())\n            };\n        }\n    });\n}\n\n/**\n * Checks if a value can be encoded as a Mysqlx.Expr.Array.\n * @private\n * @returns {boolean}\n */\npArray.canEncode = function (value) {\n    return Array.isArray(value);\n};\n\n/**\n * Creates a wrapper of a generic Mysqlx.Expr.Array instance given a list of values.\n * @private\n * @returns {module:adapters.Mysqlx.Expr.Array}\n */\npArray.create = function (values) {\n    const proto = new ExprStub.Array();\n    proto.setValueList(values.map(v => Expr.create(v).valueOf()));\n\n    return pArray(proto);\n};\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Identifier\n * @param {proto.Mysqlx.Expr.Identifier} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Identifier}\n */\nfunction pIdentifier (proto) {\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Identifier#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            return {\n                name: proto.getName(),\n                schema_name: optionalString(proto.getSchemaName()).toJSON()\n            };\n        }\n    });\n}\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.FunctionCall\n * @param {proto.Mysqlx.Expr.FunctionCall} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.FunctionCall}\n */\nfunction pFunctionCall (proto) {\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.FunctionCall#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            return {\n                name: pIdentifier(proto.getName()).toJSON(),\n                param: proto.getParamList().map(p => Expr(p).toJSON())\n            };\n        }\n    });\n}\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Object\n * @param {proto.Mysqlx.Expr.Object} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Object}\n */\nfunction pObject (proto) {\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Object#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            return {\n                fld: proto.getFldList().map(field => pObjectField(field).toJSON())\n            };\n        }\n    });\n}\n\n/**\n * Creates a wrapper of a generic Mysqlx.Expr.Object instance give the field mapping.\n * @private\n * @returns {module:adapters.Mysqlx.Expr.Object}\n */\npObject.create = function (fields) {\n    const proto = new ExprStub.Object();\n    proto.setFldList(Object.keys(fields).map(k => pObjectField.create(k, fields[k]).valueOf()));\n\n    return pObject(proto);\n};\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Object.ObjectField\n * @param {proto.Mysqlx.Expr.Object.ObjectField} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Object.ObjectField}\n */\nfunction pObjectField (proto) {\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Object.ObjectField#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            return {\n                key: proto.getKey(),\n                value: Expr(proto.getValue()).toJSON()\n            };\n        }\n    });\n}\n\n/**\n * Creates a wrapper of a generic Mysqlx.Expr.Object.ObjectField instance given a key and value.\n * @private\n * @returns {module:adapters.Mysqlx.Expr.Object.ObjectField}\n */\npObjectField.create = function (key, value) {\n    const proto = new ExprStub.Object.ObjectField();\n    proto.setKey(key);\n    proto.setValue(Expr.create(value).valueOf());\n\n    return pObjectField(proto);\n};\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Operator\n * @param {proto.Mysqlx.Expr.Operator} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Operator}\n */\nfunction pOperator (proto) {\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Operator#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            return {\n                name: proto.getName(),\n                param: proto.getParamList().map(p => Expr(p).toJSON())\n            };\n        }\n    });\n}\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Expr.Expr\n * @param {proto.Mysqlx.Expr.Expr} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Expr.Expr}\n */\nfunction Expr (proto) {\n    const state = { placeholders: [] };\n\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Retrieve the ordered list of arguments to assign to the existing placeholders.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Expr#getPlaceholderArgs\n         * @returns {Array<proto.Mysqlx.Datatypes.Scalar>} The list of protobuf instances.\n         */\n        getPlaceholderArgs (bindings) {\n            return state.placeholders.map(p => scalar.create(bindings[p]).valueOf());\n        },\n\n        /**\n         * Retrieve the expression type name.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Expr#getType\n         * @returns {string}\n         */\n        getType () {\n            return Object.keys(ExprStub.Expr.Type)\n                .filter(k => ExprStub.Expr.Type[k] === proto.getType())[0];\n        },\n\n        /**\n         * Set the ordered list of placeholder names used in the expression.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Expr#setPlaceholders\n         * @returns {module:adapters.Mysqlx.Expr.Expr} The expression wrapper instance\n         */\n        setPlaceholders (placeholders) {\n            state.placeholders = placeholders;\n\n            return this;\n        },\n\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @function\n         * @name module:adapters.Mysqlx.Expr.Expr#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            // since stub instances get assigned a default type, the exit\n            // criteria should be the case where \"proto\" is not defined\n            if (typeof proto === 'undefined') {\n                // we want the field to be ignored in the parent object\n                return;\n            }\n\n            const type = this.getType();\n\n            switch (proto.getType()) {\n            case ExprStub.Expr.Type.IDENT:\n                return { type, identifier: columnIdentifier(proto.getIdentifier()).toJSON() };\n            case ExprStub.Expr.Type.LITERAL:\n                return { type, literal: scalar(proto.getLiteral()).toJSON() };\n            case ExprStub.Expr.Type.VARIABLE:\n                return { type, variable: optionalString(proto.getVariable()).toJSON() };\n            case ExprStub.Expr.Type.FUNC_CALL:\n                return { type, function_call: pFunctionCall(proto.getFunctionCall()).toJSON() };\n            case ExprStub.Expr.Type.OPERATOR:\n                return { type, operator: pOperator(proto.getOperator()).toJSON() };\n            case ExprStub.Expr.Type.PLACEHOLDER:\n                return { type, position: proto.getPosition() };\n            case ExprStub.Expr.Type.OBJECT:\n                return { type, object: pObject(proto.getObject()).toJSON() };\n            case ExprStub.Expr.Type.ARRAY:\n                return { type, array: pArray(proto.getArray()).toJSON() };\n            }\n        }\n    });\n}\n\n/**\n * Creates a wrapper of a generic Mysqlx.Expr.Expr instance for a given value or expression.\n * @returns {module:adapters.Mysqlx.Expr.Expr}\n */\nExpr.create = function (value, options) {\n    options = Object.assign({}, { toParse: false, isPlaceholder: false }, options);\n\n    // if the value is a raw string expression, we should parse it\n    if (typeof value === 'string' && options.toParse) {\n        return parseExpression(value, options);\n    }\n\n    // if it is not provided, there's nothing to do\n    // we can't create a wrapper with an empty stub instance because it gets\n    // assigned a default type and it would mess with the \"toJSON()\" logic\n    if (typeof value === 'undefined') {\n        return Expr();\n    }\n\n    // if the value it's already an expression protobuf message, we can simply wrap it\n    if (value instanceof ExprStub.Expr) {\n        return Expr(value);\n    }\n\n    // otherwise we need to create one\n    const proto = new ExprStub.Expr();\n\n    // if the value is a number, we first need to check if it represents a\n    // placeholder position\n    if (options.isPlaceholder) {\n        proto.setType(ExprStub.Expr.Type.PLACEHOLDER);\n        proto.setPosition(value);\n    } else if (scalar.canEncode(value)) {\n        // if the value is an object, we first need to check if it can be\n        // encoded as a Scalar (e.g. Buffer and Date)\n        proto.setType(ExprStub.Expr.Type.LITERAL);\n        proto.setLiteral(scalar.create(value).valueOf());\n    } else if (pArray.canEncode(value)) {\n        proto.setType(ExprStub.Expr.Type.ARRAY);\n        proto.setArray(pArray.create(value).valueOf());\n    } else {\n        // ultimately, in JavaScript everything else is an object\n        proto.setType(ExprStub.Expr.Type.OBJECT);\n        proto.setObject(pObject.create(value).valueOf());\n    }\n\n    return Expr(proto);\n};\n\nmodule.exports = Expr;\n"]},"metadata":{},"sourceType":"script"}