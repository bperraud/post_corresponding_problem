{"ast":null,"code":"/*\n * Copyright (c) 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst dns = require('dns').promises;\n\nconst errors = require('../constants/errors');\n\nconst util = require('util');\n\nconst {\n  isValidBoolean\n} = require('../validator');\n/**\n * @typedef {Object} ServiceRecord\n * @prop {string} host - service hostname\n * @prop {number} priority - priority relative to other services\n * @prop {number} port - service port\n * @prop {number} weight - service preference under the same priority\n */\n\n/**\n * Perform a DNS SRV lookup.\n * @private\n * @param {string} serviceDefinition - service definition to lookup\n * @return {ServiceRecord[]}\n */\n\n\nexports.lookup = function (serviceDefinition) {\n  return dns.resolveSrv(serviceDefinition).then(endpoints => {\n    // We want to rename \"name\" to \"host\". Also, since DNS SRV does\n    // not work with local Unix sockets, we do not have to worry about\n    // the \"socket\" property.\n    return endpoints.map(_ref => {\n      let {\n        name,\n        port,\n        priority,\n        weight\n      } = _ref;\n      return {\n        host: name,\n        priority,\n        port,\n        weight\n      };\n    });\n  }).catch(err => {\n    // We want a custom error message in this case.\n    err.message = util.format(errors.MESSAGES.ER_DEVAPI_SRV_RECORDS_NOT_AVAILABLE, serviceDefinition);\n    throw err;\n  });\n};\n/**\n * Sort DNS SRV records.\n * @private\n * @param {Object[]} endpoints\n * @return {Object[]}\n */\n\n\nexports.sort = function () {\n  let endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return Array.from(endpoints).sort((a, b) => {\n    // In DNS SRV records, the lower the priority of an endpoint, the more\n    // important it is. There is a chance that a record does not have a\n    // priority (e.g. on Consul), but in that case, the core Node.js API\n    // simply returns a default value of 1, so we do not have to worry\n    // about the values being undefined.\n    if (a.priority !== b.priority) {\n      return a.priority - b.priority;\n    } // On the other hand, a higher weight means more importance.\n\n\n    if (a.weight !== b.weight) {\n      return b.weight - a.weight;\n    } // For endpoints with the same priority and weigth, the order\n    // is determined via random weighted selection.\n\n\n    return [-1, 1][Math.floor(Math.random() * 2)];\n  });\n};\n/**\n * Validate the DNS SRV property setup.\n * @private\n * @param {Object} params\n * @param {Array<Endpoint>} [endpoints] - any list of endpoints provided as a connection option\n * @param {string} [host] - the value of \"host\" property provided as a connection option\n * @param {number} [port] - the value of \"port\" provided as a connection option\n * @param {boolean} [resolveSrv] - wether the connection will be using DNS SRV or not\n * @param {string} [socket] - the value of \"socket\" provided as a connection option\n * @returns {boolean} Returns true if all options and values are valid.\n * @throws when \"resolveSrv\" is badly specified, when there are multiple endpoints\n * or when an endpoint definition contains a port or a socket.\n */\n\n\nexports.validate = function (_ref2) {\n  let {\n    endpoints,\n    host,\n    port,\n    resolveSrv,\n    socket\n  } = _ref2;\n\n  // Validate SRV and multi-host options.\n  if (!isValidBoolean({\n    value: resolveSrv\n  })) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_SRV_LOOKUP_OPTION);\n  } // DNS SRV and multi-host connections are two alternative solutions for\n  // the same problem. They are mutualy exclusive because the connection\n  // does specify DNS server addresses, only MySQL endpoints. In the case of\n  // DNS SRV, those endpoints are returned by the DNS server picked by the\n  // system where the application is running.\n  // resolveSrv should be true or false by this point.\n\n\n  if (resolveSrv && endpoints && endpoints.length > 1) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_SRV_LOOKUP_NO_MULTIPLE_ENDPOINTS);\n  } // If the endpoint list is not defined, we look at the plain\n  // endpoint properties.\n\n\n  const endpoint = endpoints && endpoints.length ? endpoints[0] : {\n    host,\n    port,\n    socket\n  }; // The lookup happens via port 53 (the default) using the DNS servers\n  // configured in the machine where the application is running.\n  // Additionally, it should only include the service, the protocol and the\n  // domain (e.g. _mysql._tcp.example.com).\n\n  if (resolveSrv && endpoint.port) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_SRV_LOOKUP_NO_PORT);\n  } // The DNS SRV RR also does not support local paths, so we should not\n  // allow local socket addresses.\n\n\n  if (resolveSrv && endpoint.socket) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_SRV_LOOKUP_NO_UNIX_SOCKET);\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/topology/dns-srv.js"],"names":["dns","require","promises","errors","util","isValidBoolean","exports","lookup","serviceDefinition","resolveSrv","then","endpoints","map","name","port","priority","weight","host","catch","err","message","format","MESSAGES","ER_DEVAPI_SRV_RECORDS_NOT_AVAILABLE","sort","Array","from","a","b","Math","floor","random","validate","socket","value","Error","ER_DEVAPI_BAD_SRV_LOOKUP_OPTION","length","ER_DEVAPI_SRV_LOOKUP_NO_MULTIPLE_ENDPOINTS","endpoint","ER_DEVAPI_SRV_LOOKUP_NO_PORT","ER_DEVAPI_SRV_LOOKUP_NO_UNIX_SOCKET"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst dns = require('dns').promises;\nconst errors = require('../constants/errors');\nconst util = require('util');\nconst { isValidBoolean } = require('../validator');\n\n/**\n * @typedef {Object} ServiceRecord\n * @prop {string} host - service hostname\n * @prop {number} priority - priority relative to other services\n * @prop {number} port - service port\n * @prop {number} weight - service preference under the same priority\n */\n\n/**\n * Perform a DNS SRV lookup.\n * @private\n * @param {string} serviceDefinition - service definition to lookup\n * @return {ServiceRecord[]}\n */\nexports.lookup = function (serviceDefinition) {\n    return dns.resolveSrv(serviceDefinition)\n        .then(endpoints => {\n            // We want to rename \"name\" to \"host\". Also, since DNS SRV does\n            // not work with local Unix sockets, we do not have to worry about\n            // the \"socket\" property.\n            return endpoints.map(({ name, port, priority, weight }) => ({ host: name, priority, port, weight }));\n        })\n        .catch(err => {\n            // We want a custom error message in this case.\n            err.message = util.format(errors.MESSAGES.ER_DEVAPI_SRV_RECORDS_NOT_AVAILABLE, serviceDefinition);\n            throw err;\n        });\n};\n\n/**\n * Sort DNS SRV records.\n * @private\n * @param {Object[]} endpoints\n * @return {Object[]}\n */\nexports.sort = function (endpoints = []) {\n    return Array.from(endpoints).sort((a, b) => {\n        // In DNS SRV records, the lower the priority of an endpoint, the more\n        // important it is. There is a chance that a record does not have a\n        // priority (e.g. on Consul), but in that case, the core Node.js API\n        // simply returns a default value of 1, so we do not have to worry\n        // about the values being undefined.\n        if (a.priority !== b.priority) {\n            return a.priority - b.priority;\n        }\n\n        // On the other hand, a higher weight means more importance.\n        if (a.weight !== b.weight) {\n            return b.weight - a.weight;\n        }\n\n        // For endpoints with the same priority and weigth, the order\n        // is determined via random weighted selection.\n        return [-1, 1][Math.floor(Math.random() * 2)];\n    });\n};\n\n/**\n * Validate the DNS SRV property setup.\n * @private\n * @param {Object} params\n * @param {Array<Endpoint>} [endpoints] - any list of endpoints provided as a connection option\n * @param {string} [host] - the value of \"host\" property provided as a connection option\n * @param {number} [port] - the value of \"port\" provided as a connection option\n * @param {boolean} [resolveSrv] - wether the connection will be using DNS SRV or not\n * @param {string} [socket] - the value of \"socket\" provided as a connection option\n * @returns {boolean} Returns true if all options and values are valid.\n * @throws when \"resolveSrv\" is badly specified, when there are multiple endpoints\n * or when an endpoint definition contains a port or a socket.\n */\nexports.validate = function ({ endpoints, host, port, resolveSrv, socket }) {\n    // Validate SRV and multi-host options.\n    if (!isValidBoolean({ value: resolveSrv })) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_SRV_LOOKUP_OPTION);\n    }\n\n    // DNS SRV and multi-host connections are two alternative solutions for\n    // the same problem. They are mutualy exclusive because the connection\n    // does specify DNS server addresses, only MySQL endpoints. In the case of\n    // DNS SRV, those endpoints are returned by the DNS server picked by the\n    // system where the application is running.\n    // resolveSrv should be true or false by this point.\n    if (resolveSrv && endpoints && endpoints.length > 1) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_SRV_LOOKUP_NO_MULTIPLE_ENDPOINTS);\n    }\n\n    // If the endpoint list is not defined, we look at the plain\n    // endpoint properties.\n    const endpoint = endpoints && endpoints.length ? endpoints[0] : { host, port, socket };\n\n    // The lookup happens via port 53 (the default) using the DNS servers\n    // configured in the machine where the application is running.\n    // Additionally, it should only include the service, the protocol and the\n    // domain (e.g. _mysql._tcp.example.com).\n    if (resolveSrv && endpoint.port) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_SRV_LOOKUP_NO_PORT);\n    }\n\n    // The DNS SRV RR also does not support local paths, so we should not\n    // allow local socket addresses.\n    if (resolveSrv && endpoint.socket) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_SRV_LOOKUP_NO_UNIX_SOCKET);\n    }\n\n    return true;\n};\n"]},"metadata":{},"sourceType":"script"}