{"ast":null,"code":"/*\n * Copyright (c) 2017, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst Scalar = require('../../../../Protocol/Stubs/mysqlx_datatypes_pb').Scalar;\n\nconst Pa = require('parsimmon');\n\nconst bytes = require('../../../../Protocol/Wrappers/ScalarValues/bytes');\n\nconst parser = options => r => Pa.alt(r.FLOAT.map(data => {\n  const scalar = new Scalar();\n  scalar.setType(Scalar.Type.V_DOUBLE);\n  scalar.setVDouble(data);\n  return scalar;\n}), r.INT.map(data => {\n  const int = parseInt(data, 10);\n  const scalar = new Scalar();\n\n  if (int > Number.MAX_SAFE_INTEGER || int < Number.MIN_SAFE_INTEGER) {\n    const str = new Scalar.String();\n    str.setValue(bytes.create(Buffer.from(`${int}`)).valueOf());\n    scalar.setType(Scalar.Type.V_STRING);\n    scalar.setVString(str);\n    return scalar;\n  }\n\n  if (int >= 0) {\n    scalar.setType(Scalar.Type.V_UINT);\n    scalar.setVUnsignedInt(int);\n    return scalar;\n  }\n\n  scalar.setType(Scalar.Type.V_SINT);\n  scalar.setVSignedInt(int);\n  return scalar;\n}), r.STRING_DQ.map(data => {\n  const str = new Scalar.String();\n  const unquoted = data.slice(1, data.length - 1);\n  str.setValue(bytes.create(Buffer.from(unquoted)).valueOf());\n  const scalar = new Scalar();\n  scalar.setType(Scalar.Type.V_STRING);\n  scalar.setVString(str);\n  return scalar;\n}), r.STRING_SQ.map(data => {\n  const str = new Scalar.String();\n  const unquoted = data.slice(1, data.length - 1);\n  str.setValue(bytes.create(Buffer.from(unquoted)).valueOf());\n  const scalar = new Scalar();\n  scalar.setType(Scalar.Type.V_STRING);\n  scalar.setVString(str);\n  return scalar;\n}), r.NULL.map(() => {\n  const scalar = new Scalar();\n  scalar.setType(Scalar.Type.V_NULL);\n  return scalar;\n}), r.FALSE.map(() => {\n  const scalar = new Scalar();\n  scalar.setType(Scalar.Type.V_BOOL);\n  scalar.setVBool(false);\n  return scalar;\n}), r.TRUE.map(() => {\n  const scalar = new Scalar();\n  scalar.setType(Scalar.Type.V_BOOL);\n  scalar.setVBool(true);\n  return scalar;\n})).map(data => ({\n  output: data\n}));\n\nmodule.exports = {\n  name: 'LITERAL',\n  parser\n};","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/ExprParser/lib/grammar/booleanExpressions/literal.js"],"names":["Scalar","require","Pa","bytes","parser","options","r","alt","FLOAT","map","data","scalar","setType","Type","V_DOUBLE","setVDouble","INT","int","parseInt","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","str","String","setValue","create","Buffer","from","valueOf","V_STRING","setVString","V_UINT","setVUnsignedInt","V_SINT","setVSignedInt","STRING_DQ","unquoted","slice","length","STRING_SQ","NULL","V_NULL","FALSE","V_BOOL","setVBool","TRUE","output","module","exports","name"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst Scalar = require('../../../../Protocol/Stubs/mysqlx_datatypes_pb').Scalar;\nconst Pa = require('parsimmon');\nconst bytes = require('../../../../Protocol/Wrappers/ScalarValues/bytes');\n\nconst parser = options => r => Pa\n    .alt(\n        r.FLOAT.map(data => {\n            const scalar = new Scalar();\n            scalar.setType(Scalar.Type.V_DOUBLE);\n            scalar.setVDouble(data);\n\n            return scalar;\n        }),\n        r.INT.map(data => {\n            const int = parseInt(data, 10);\n            const scalar = new Scalar();\n\n            if (int > Number.MAX_SAFE_INTEGER || int < Number.MIN_SAFE_INTEGER) {\n                const str = new Scalar.String();\n                str.setValue(bytes.create(Buffer.from(`${int}`)).valueOf());\n\n                scalar.setType(Scalar.Type.V_STRING);\n                scalar.setVString(str);\n\n                return scalar;\n            }\n\n            if (int >= 0) {\n                scalar.setType(Scalar.Type.V_UINT);\n                scalar.setVUnsignedInt(int);\n\n                return scalar;\n            }\n\n            scalar.setType(Scalar.Type.V_SINT);\n            scalar.setVSignedInt(int);\n\n            return scalar;\n        }),\n        r.STRING_DQ.map(data => {\n            const str = new Scalar.String();\n            const unquoted = data.slice(1, data.length - 1);\n            str.setValue(bytes.create(Buffer.from(unquoted)).valueOf());\n\n            const scalar = new Scalar();\n            scalar.setType(Scalar.Type.V_STRING);\n            scalar.setVString(str);\n\n            return scalar;\n        }),\n        r.STRING_SQ.map(data => {\n            const str = new Scalar.String();\n            const unquoted = data.slice(1, data.length - 1);\n            str.setValue(bytes.create(Buffer.from(unquoted)).valueOf());\n\n            const scalar = new Scalar();\n            scalar.setType(Scalar.Type.V_STRING);\n            scalar.setVString(str);\n\n            return scalar;\n        }),\n        r.NULL.map(() => {\n            const scalar = new Scalar();\n            scalar.setType(Scalar.Type.V_NULL);\n\n            return scalar;\n        }),\n        r.FALSE.map(() => {\n            const scalar = new Scalar();\n            scalar.setType(Scalar.Type.V_BOOL);\n            scalar.setVBool(false);\n\n            return scalar;\n        }),\n        r.TRUE.map(() => {\n            const scalar = new Scalar();\n            scalar.setType(Scalar.Type.V_BOOL);\n            scalar.setVBool(true);\n\n            return scalar;\n        })\n    )\n    .map(data => ({ output: data }));\n\nmodule.exports = { name: 'LITERAL', parser };\n"]},"metadata":{},"sourceType":"script"}