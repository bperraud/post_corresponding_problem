{"ast":null,"code":"/*\n * Copyright (c) 2018, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst connection = require('./PoolConnection');\n\nconst errors = require('../constants/errors');\n\nconst util = require('util');\n\nconst {\n  isValidBoolean,\n  isValidInteger\n} = require('../validator');\n/**\n * XDevAPI implementation of a connection pool. Should be used via the {@link module:Client|Client} API.\n * @module ConnectionPool\n * @example\n * const pool = mysqlx.getClient('mysqlx://root@localhost', {\n *   pooling: {\n *     enabled: true,\n *     maxSize: 10,\n *     maxIdleTime: 20000,\n *     queueTimeout: 5000\n *   }\n * })\n *\n * pool.getSession()\n *   .then(session => {\n *     // A new session is created using a connection from the pool.\n *   })\n */\n\n/**\n * Connection pool configuration properties.\n * @typedef {Object} Properties\n * @prop {boolean} [enabled=true] - use a connection pool\n * @prop {number} [maxSize=25] - maximum number of connections in the pool\n * @prop {number} [maxIdleTime=0] - maximum number of milliseconds to allow a connection to be idle (0 - infinite)\n * @prop {number} [queueTimeout=0] - maximum number of milliseconds to wait for a connection to become available (0 - infinite)\n */\n\n\nconst VALID_OPTIONS = ['enabled', 'maxIdleTime', 'maxSize', 'queueTimeout'];\n/**\n * @private\n * @alias module:ConnectionPool\n * @param {Object} [options] - pooling options\n * @returns {module:ConnectionPool}\n */\n\nfunction ConnectionPool() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Internal pool state containing a list of connections\n  // given their current state.\n  const state = {\n    // Contains the list of active connections i.e. that have not been\n    // closed neither by the client nor the server.\n    active: [],\n    // Contains the list of connections that have expired i.e. where\n    // maxIdleTime was exceeded or have been closed by the server.\n    expired: [],\n    // Contains the list of connections that became idle i.e. have been\n    // closed by the client.\n    idle: [],\n    // Keep track of the number of reserved slots in order to ensure\n    // connections are only created when there is space in the pool.\n    tickets: 0\n  };\n  return {\n    /**\n     * Returns the current list of active connections in the pool.\n     * @private\n     * @function\n     * @name module:ConnectionPool#activeConnections\n     * @returns {Array<PoolConnection>} The list of connection instances.\n     */\n    activeConnections() {\n      return state.active;\n    },\n\n    /**\n     * Returns the current list of idle connections in the pool.\n     * @private\n     * @function\n     * @name module:ConnectionPool#idleConnections\n     * @param {Object} [state={}] - The initial state of the pool.\n     * @param {Array<PoolConnection>} [state.active=[]] - A list of active connections\n     * @param {Array<PoolConnection>} [state.idle=[]] - A list of idle connections\n     * @param {Array<PoolConnection>} [state.expired=[]] - A list of expired connections.\n     * @returns {ConnectionPool} The pool instance.\n     */\n    create() {\n      let {\n        active = [],\n        expired = [],\n        idle = []\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      state.active = active;\n      state.expired = expired;\n      state.idle = idle;\n      state.tickets = active.length;\n      return this;\n    },\n\n    /**\n     * Close all the connections in the pool.\n     * @private\n     * @function\n     * @name module:ConnectionPool#destroy\n     * @returns {Promise}\n     */\n    destroy() {\n      // Expired connections have already been destroyed by this point.\n      return Promise.all(state.idle.concat(state.active).map(con => con.destroy())).then(() => {\n        this.reset();\n      }).catch(err => {\n        this.reset();\n        throw err;\n      });\n    },\n\n    /**\n     * Returns the current list of expired connections in the pool.\n     * @private\n     * @function\n     * @name module:ConnectionPool#expiredConnections\n     * @returns {Array<PoolConnection>} The list of connection instances.\n     */\n    expiredConnections() {\n      return state.expired;\n    },\n\n    /**\n     * Retrieve a usable connection from the pool.\n     * If there are idle connections available on is returned.\n     * If there are no idle connections available and the pool is not\n     * full, either an expired connection is re-created or a new\n     * connection is created.\n     * If the pool is full, it will wait until queueTimeout is reached.\n     * Every time this function is called, the list of connections\n     * is updated according to the status of each connection.\n     * @private\n     * @function\n     * @name module:ConnectionPool#getConnection\n     * @throws Will return a rejected Promise if queueTimeout is exceeded.\n     * @returns {Promise<PoolConnection>}\n     */\n    getConnection() {\n      let requestedAt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n      return this.update().then(() => {\n        const elapsedTime = Date.now() - requestedAt;\n        const queueTimeout = options.pooling.queueTimeout;\n\n        const postConnect = con => {\n          // The connection needs to be blocked from being released.\n          con.acquire(); // The connection should be moved to the active list.\n\n          state.active.push(con); // And returned back to the X DevAPI client.\n\n          return con;\n        }; // Use an existing connection or create a new one.\n        // If the pool is full, it means the idle and expired\n        // queues are empty and the connection will be undefined.\n\n\n        const con = state.idle.shift() || state.expired.shift(); // If the pool is full (all the connections are active) we\n        // need to check if the time elapsed since the previous\n        // attempt to retrieve the connection from the pool. If\n        // it exceeds the value of queueTimeout we need to throw\n        // an error. However, if queueTimeout = 0 that means it\n        // is supposed to be infinite, so, in that case, we do not\n        // throw an error and need to try indefinitely.\n\n        if (this.isFull() && queueTimeout !== 0 && elapsedTime >= queueTimeout) {\n          throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_POOL_QUEUE_TIMEOUT, queueTimeout));\n        } // If the pool is full and the elapsed time since the last\n        // attempt to retrieve the connection does not exceed the\n        // value of queueTimeout (which can be infinite), we need\n        // to attempt to retrieve the connection again, given a\n        // proper sliding window. In this case, the next attempt\n        // will happen only after the same time it passed since\n        // the last check.\n        // If the connection is expired but is still being closed,\n        // which can happen with parallel connection requests, we\n        // also need to queue the request.\n\n\n        if (this.isFull() || con && con.isClosing()) {\n          return new Promise((resolve, reject) => setTimeout(() => this.getConnection(requestedAt).then(resolve).catch(reject), elapsedTime));\n        } // Given the connection is only considered active after it\n        // is effectively created. Due to the asynchronous nature\n        // of the pool, in the presence of parallel connection\n        // requests, we need to create a ticket for each\n        // connection that can and will start to be created.\n\n\n        state.tickets += 1; // If there is an idle connection which has not been\n        // closed and has not expired (\"maxIdleTime\" still has\n        // not been exceeded) we can re-use it.\n\n        if (con && con.isOpen() && !con.isExpired()) {\n          return con.override().then(postConnect);\n        } // If the connection is not open or has expired, we need\n        // to refurbish the same instance, to ensure the endpoint\n        // availability is up-to-date.\n\n\n        if (con) {\n          return con.open().then(postConnect);\n        } // Otherwise we need to create a new one.\n\n\n        return connection(options).open().then(postConnect);\n      });\n    },\n\n    /**\n     * Returns the current list of idle connections in the pool.\n     * @private\n     * @function\n     * @name module:ConnectionPool#idleConnections\n     * @returns {Array<PoolConnection>} The list of connection instances.\n     */\n    idleConnections() {\n      return state.idle;\n    },\n\n    /**\n     * Checks if a pool is full i.e. a total of \"maxSize\" number of\n     * connections are currently active.\n     * @private\n     * @function\n     * @name module:ConnectionPool#isFull\n     * @returns {boolean}\n     */\n    isFull() {\n      // A connection pool is full if the current number of tickets is\n      // equal to the maximum size of the pool.\n      return state.tickets === options.pooling.maxSize;\n    },\n\n    /**\n     * Reset the pool state.\n     * @private\n     * @function\n     * @name module:ConnectionPool#reset\n     * @returns {module:ConnectionPool} The pool instance.\n     */\n    reset() {\n      state.active = [];\n      state.expired = [];\n      state.idle = [];\n      state.tickets = 0;\n      return this;\n    },\n\n    /**\n     * Update the list of connections given their current state.\n     * @private\n     * @function\n     * @name module:ConnectionPool#update\n     * @returns {Promise}\n     */\n    update() {\n      // A connection can be closed from the server side, which means\n      // there is a chance that the active connection queue contains\n      // connections that have been closed. If that is the case, those\n      // should become expired.\n      const openActiveConnections = state.active.filter(c => c.isOpen());\n      const closedActiveConnections = state.active.filter(c => !c.isOpen());\n      const releasedActiveConnections = state.active.filter(c => c.isIdle());\n      state.expired = state.expired.concat(closedActiveConnections);\n      state.active = openActiveConnections; // The number of reserved slots should decrease given the\n      // number of connections that are no longer active.\n\n      state.tickets = state.tickets - closedActiveConnections.length - releasedActiveConnections.length; // Active connections that have been closed by the application\n      // should be released back into the pool, which means they become\n      // idle.\n\n      const validActiveConnections = state.active.filter(c => !c.isIdle());\n      state.idle = state.idle.concat(releasedActiveConnections);\n      state.active = validActiveConnections; // Idle connections can also have expired (when \"maxIdleTime\" has\n      // been exceeded).\n\n      const expiredIdleConnections = state.idle.filter(c => c.isExpired());\n      const validIdleConnections = state.idle.filter(c => !c.isExpired());\n      state.expired = state.expired.concat(expiredIdleConnections);\n      state.idle = validIdleConnections; // Expired connections should be destroyed.\n\n      return Promise.all(state.expired.map(con => con.destroy()));\n    }\n\n  };\n}\n\nConnectionPool.validate = function (options) {\n  const invalidKeys = Object.keys(options).filter(k => VALID_OPTIONS.indexOf(k) === -1);\n\n  if (invalidKeys.length) {\n    throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION, `pooling.${invalidKeys[0]}`));\n  }\n\n  const {\n    enabled,\n    maxIdleTime,\n    maxSize,\n    queueTimeout\n  } = options;\n\n  if (!isValidBoolean({\n    value: enabled\n  })) {\n    throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION_VALUE, 'pooling.enabled', enabled));\n  }\n\n  if (!isValidInteger({\n    value: maxIdleTime,\n    min: 0\n  })) {\n    throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION_VALUE, 'pooling.maxIdleTime', maxIdleTime));\n  }\n\n  if (!isValidInteger({\n    value: maxSize,\n    min: 1\n  })) {\n    throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION_VALUE, 'pooling.maxSize', maxSize));\n  }\n\n  if (!isValidInteger({\n    value: queueTimeout,\n    min: 0\n  })) {\n    throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION_VALUE, 'pooling.queueTimeout', queueTimeout));\n  }\n\n  return true;\n};\n\nConnectionPool.VALID_OPTIONS = VALID_OPTIONS;\nmodule.exports = ConnectionPool;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/DevAPI/ConnectionPool.js"],"names":["connection","require","errors","util","isValidBoolean","isValidInteger","VALID_OPTIONS","ConnectionPool","options","state","active","expired","idle","tickets","activeConnections","create","length","destroy","Promise","all","concat","map","con","then","reset","catch","err","expiredConnections","getConnection","requestedAt","Date","now","update","elapsedTime","queueTimeout","pooling","postConnect","acquire","push","shift","isFull","Error","format","MESSAGES","ER_DEVAPI_POOL_QUEUE_TIMEOUT","isClosing","resolve","reject","setTimeout","isOpen","isExpired","override","open","idleConnections","maxSize","openActiveConnections","filter","c","closedActiveConnections","releasedActiveConnections","isIdle","validActiveConnections","expiredIdleConnections","validIdleConnections","validate","invalidKeys","Object","keys","k","indexOf","ER_DEVAPI_BAD_CLIENT_OPTION","enabled","maxIdleTime","value","ER_DEVAPI_BAD_CLIENT_OPTION_VALUE","min","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2018, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst connection = require('./PoolConnection');\nconst errors = require('../constants/errors');\nconst util = require('util');\nconst { isValidBoolean, isValidInteger } = require('../validator');\n\n/**\n * XDevAPI implementation of a connection pool. Should be used via the {@link module:Client|Client} API.\n * @module ConnectionPool\n * @example\n * const pool = mysqlx.getClient('mysqlx://root@localhost', {\n *   pooling: {\n *     enabled: true,\n *     maxSize: 10,\n *     maxIdleTime: 20000,\n *     queueTimeout: 5000\n *   }\n * })\n *\n * pool.getSession()\n *   .then(session => {\n *     // A new session is created using a connection from the pool.\n *   })\n */\n\n/**\n * Connection pool configuration properties.\n * @typedef {Object} Properties\n * @prop {boolean} [enabled=true] - use a connection pool\n * @prop {number} [maxSize=25] - maximum number of connections in the pool\n * @prop {number} [maxIdleTime=0] - maximum number of milliseconds to allow a connection to be idle (0 - infinite)\n * @prop {number} [queueTimeout=0] - maximum number of milliseconds to wait for a connection to become available (0 - infinite)\n */\nconst VALID_OPTIONS = ['enabled', 'maxIdleTime', 'maxSize', 'queueTimeout'];\n\n/**\n * @private\n * @alias module:ConnectionPool\n * @param {Object} [options] - pooling options\n * @returns {module:ConnectionPool}\n */\nfunction ConnectionPool (options = {}) {\n    // Internal pool state containing a list of connections\n    // given their current state.\n    const state = {\n        // Contains the list of active connections i.e. that have not been\n        // closed neither by the client nor the server.\n        active: [],\n        // Contains the list of connections that have expired i.e. where\n        // maxIdleTime was exceeded or have been closed by the server.\n        expired: [],\n        // Contains the list of connections that became idle i.e. have been\n        // closed by the client.\n        idle: [],\n        // Keep track of the number of reserved slots in order to ensure\n        // connections are only created when there is space in the pool.\n        tickets: 0\n    };\n\n    return {\n        /**\n         * Returns the current list of active connections in the pool.\n         * @private\n         * @function\n         * @name module:ConnectionPool#activeConnections\n         * @returns {Array<PoolConnection>} The list of connection instances.\n         */\n        activeConnections () {\n            return state.active;\n        },\n\n        /**\n         * Returns the current list of idle connections in the pool.\n         * @private\n         * @function\n         * @name module:ConnectionPool#idleConnections\n         * @param {Object} [state={}] - The initial state of the pool.\n         * @param {Array<PoolConnection>} [state.active=[]] - A list of active connections\n         * @param {Array<PoolConnection>} [state.idle=[]] - A list of idle connections\n         * @param {Array<PoolConnection>} [state.expired=[]] - A list of expired connections.\n         * @returns {ConnectionPool} The pool instance.\n         */\n        create ({ active = [], expired = [], idle = [] } = {}) {\n            state.active = active;\n            state.expired = expired;\n            state.idle = idle;\n            state.tickets = active.length;\n\n            return this;\n        },\n\n        /**\n         * Close all the connections in the pool.\n         * @private\n         * @function\n         * @name module:ConnectionPool#destroy\n         * @returns {Promise}\n         */\n        destroy () {\n            // Expired connections have already been destroyed by this point.\n            return Promise.all(state.idle.concat(state.active).map(con => con.destroy()))\n                .then(() => {\n                    this.reset();\n                })\n                .catch(err => {\n                    this.reset();\n                    throw err;\n                });\n        },\n\n        /**\n         * Returns the current list of expired connections in the pool.\n         * @private\n         * @function\n         * @name module:ConnectionPool#expiredConnections\n         * @returns {Array<PoolConnection>} The list of connection instances.\n         */\n        expiredConnections () {\n            return state.expired;\n        },\n\n        /**\n         * Retrieve a usable connection from the pool.\n         * If there are idle connections available on is returned.\n         * If there are no idle connections available and the pool is not\n         * full, either an expired connection is re-created or a new\n         * connection is created.\n         * If the pool is full, it will wait until queueTimeout is reached.\n         * Every time this function is called, the list of connections\n         * is updated according to the status of each connection.\n         * @private\n         * @function\n         * @name module:ConnectionPool#getConnection\n         * @throws Will return a rejected Promise if queueTimeout is exceeded.\n         * @returns {Promise<PoolConnection>}\n         */\n        getConnection (requestedAt = Date.now()) {\n            return this.update()\n                .then(() => {\n                    const elapsedTime = Date.now() - requestedAt;\n                    const queueTimeout = options.pooling.queueTimeout;\n\n                    const postConnect = con => {\n                        // The connection needs to be blocked from being released.\n                        con.acquire();\n                        // The connection should be moved to the active list.\n                        state.active.push(con);\n                        // And returned back to the X DevAPI client.\n                        return con;\n                    };\n\n                    // Use an existing connection or create a new one.\n                    // If the pool is full, it means the idle and expired\n                    // queues are empty and the connection will be undefined.\n                    const con = state.idle.shift() || state.expired.shift();\n\n                    // If the pool is full (all the connections are active) we\n                    // need to check if the time elapsed since the previous\n                    // attempt to retrieve the connection from the pool. If\n                    // it exceeds the value of queueTimeout we need to throw\n                    // an error. However, if queueTimeout = 0 that means it\n                    // is supposed to be infinite, so, in that case, we do not\n                    // throw an error and need to try indefinitely.\n                    if (this.isFull() && queueTimeout !== 0 && elapsedTime >= queueTimeout) {\n                        throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_POOL_QUEUE_TIMEOUT, queueTimeout));\n                    }\n\n                    // If the pool is full and the elapsed time since the last\n                    // attempt to retrieve the connection does not exceed the\n                    // value of queueTimeout (which can be infinite), we need\n                    // to attempt to retrieve the connection again, given a\n                    // proper sliding window. In this case, the next attempt\n                    // will happen only after the same time it passed since\n                    // the last check.\n                    // If the connection is expired but is still being closed,\n                    // which can happen with parallel connection requests, we\n                    // also need to queue the request.\n                    if (this.isFull() || (con && con.isClosing())) {\n                        return new Promise((resolve, reject) => setTimeout(() => this.getConnection(requestedAt).then(resolve).catch(reject), elapsedTime));\n                    }\n\n                    // Given the connection is only considered active after it\n                    // is effectively created. Due to the asynchronous nature\n                    // of the pool, in the presence of parallel connection\n                    // requests, we need to create a ticket for each\n                    // connection that can and will start to be created.\n                    state.tickets += 1;\n\n                    // If there is an idle connection which has not been\n                    // closed and has not expired (\"maxIdleTime\" still has\n                    // not been exceeded) we can re-use it.\n                    if (con && con.isOpen() && !con.isExpired()) {\n                        return con.override().then(postConnect);\n                    }\n\n                    // If the connection is not open or has expired, we need\n                    // to refurbish the same instance, to ensure the endpoint\n                    // availability is up-to-date.\n                    if (con) {\n                        return con.open().then(postConnect);\n                    }\n\n                    // Otherwise we need to create a new one.\n                    return connection(options).open().then(postConnect);\n                });\n        },\n\n        /**\n         * Returns the current list of idle connections in the pool.\n         * @private\n         * @function\n         * @name module:ConnectionPool#idleConnections\n         * @returns {Array<PoolConnection>} The list of connection instances.\n         */\n        idleConnections () {\n            return state.idle;\n        },\n\n        /**\n         * Checks if a pool is full i.e. a total of \"maxSize\" number of\n         * connections are currently active.\n         * @private\n         * @function\n         * @name module:ConnectionPool#isFull\n         * @returns {boolean}\n         */\n        isFull () {\n            // A connection pool is full if the current number of tickets is\n            // equal to the maximum size of the pool.\n            return state.tickets === options.pooling.maxSize;\n        },\n\n        /**\n         * Reset the pool state.\n         * @private\n         * @function\n         * @name module:ConnectionPool#reset\n         * @returns {module:ConnectionPool} The pool instance.\n         */\n        reset () {\n            state.active = [];\n            state.expired = [];\n            state.idle = [];\n            state.tickets = 0;\n\n            return this;\n        },\n\n        /**\n         * Update the list of connections given their current state.\n         * @private\n         * @function\n         * @name module:ConnectionPool#update\n         * @returns {Promise}\n         */\n        update () {\n            // A connection can be closed from the server side, which means\n            // there is a chance that the active connection queue contains\n            // connections that have been closed. If that is the case, those\n            // should become expired.\n            const openActiveConnections = state.active.filter(c => c.isOpen());\n            const closedActiveConnections = state.active.filter(c => !c.isOpen());\n            const releasedActiveConnections = state.active.filter(c => c.isIdle());\n\n            state.expired = state.expired.concat(closedActiveConnections);\n            state.active = openActiveConnections;\n\n            // The number of reserved slots should decrease given the\n            // number of connections that are no longer active.\n            state.tickets = state.tickets - closedActiveConnections.length - releasedActiveConnections.length;\n\n            // Active connections that have been closed by the application\n            // should be released back into the pool, which means they become\n            // idle.\n            const validActiveConnections = state.active.filter(c => !c.isIdle());\n\n            state.idle = state.idle.concat(releasedActiveConnections);\n            state.active = validActiveConnections;\n\n            // Idle connections can also have expired (when \"maxIdleTime\" has\n            // been exceeded).\n            const expiredIdleConnections = state.idle.filter(c => c.isExpired());\n            const validIdleConnections = state.idle.filter(c => !c.isExpired());\n\n            state.expired = state.expired.concat(expiredIdleConnections);\n            state.idle = validIdleConnections;\n\n            // Expired connections should be destroyed.\n            return Promise.all(state.expired.map(con => con.destroy()));\n        }\n    };\n}\n\nConnectionPool.validate = function (options) {\n    const invalidKeys = Object.keys(options).filter(k => VALID_OPTIONS.indexOf(k) === -1);\n\n    if (invalidKeys.length) {\n        throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION, `pooling.${invalidKeys[0]}`));\n    }\n\n    const { enabled, maxIdleTime, maxSize, queueTimeout } = options;\n\n    if (!isValidBoolean({ value: enabled })) {\n        throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION_VALUE, 'pooling.enabled', enabled));\n    }\n\n    if (!isValidInteger({ value: maxIdleTime, min: 0 })) {\n        throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION_VALUE, 'pooling.maxIdleTime', maxIdleTime));\n    }\n\n    if (!isValidInteger({ value: maxSize, min: 1 })) {\n        throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION_VALUE, 'pooling.maxSize', maxSize));\n    }\n\n    if (!isValidInteger({ value: queueTimeout, min: 0 })) {\n        throw new Error(util.format(errors.MESSAGES.ER_DEVAPI_BAD_CLIENT_OPTION_VALUE, 'pooling.queueTimeout', queueTimeout));\n    }\n\n    return true;\n};\n\nConnectionPool.VALID_OPTIONS = VALID_OPTIONS;\n\nmodule.exports = ConnectionPool;\n"]},"metadata":{},"sourceType":"script"}