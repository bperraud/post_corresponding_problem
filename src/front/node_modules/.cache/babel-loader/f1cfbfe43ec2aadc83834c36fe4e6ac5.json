{"ast":null,"code":"/*\n * Copyright (c) 2015, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst collectionAdd = require('./CollectionAdd');\n\nconst collectionFind = require('./CollectionFind');\n\nconst collectionModify = require('./CollectionModify');\n\nconst collectionRemove = require('./CollectionRemove');\n\nconst databaseObject = require('./DatabaseObject');\n\nconst errors = require('../constants/errors');\n\nconst escapeQuotes = require('./Util/escapeQuotes');\n\nconst parseFlexibleParamList = require('./Util/parseFlexibleParamList');\n\nconst sqlExecute = require('./SqlExecute');\n\nconst table = require('./Table');\n/**\n * Collection factory.\n * @module Collection\n * @mixes DatabaseObject\n */\n\n/**\n * @private\n * @alias module:Collection\n * @param {Connection} connection - database connection context\n * @param {module:Schema} schema - schema to bind\n * @param {string} name - collection name\n * @returns {module:Collection}\n */\n\n\nfunction Collection(connection, schema, name) {\n  const state = Object.assign({}, {\n    name,\n    schema\n  });\n  const collection = Object.assign({}, databaseObject(connection), {\n    /**\n     * Literal object or JSON counterpart.\n     * @typedef {Object|string} DocumentOrJSON\n     * @global\n     * @example\n     * // literal object\n     * { foo: 'bar' }\n     * // JSON string\n     * '{ \"foo\": \"bar\" }'\n     */\n\n    /**\n     * Create an operation to add one or more documents to the collection.\n     * @function\n     * @name module:Collection#add\n     * @param {...DocumentOrJSON|DocumentOrJSON[]} expr - object with document data\n     * @throws {Error} When the input type is invalid.\n     * @example\n     * // arguments as single documents\n     * collection.add({ foo: 'baz' }, { bar: 'qux' })\n     *\n     * // array of documents\n     * collection.add([{ foo: 'baz' }, { bar: 'qux' }])\n     * @returns {module:CollectionAdd} The operation instance.\n     */\n    add() {\n      const documents = parseFlexibleParamList(Array.prototype.slice.call(arguments));\n      return collectionAdd(connection, this.getSchema(), this.getName(), documents);\n    },\n\n    /**\n     * Create or replace a document with the given id.\n     * @function\n     * @name module:Collection#addOrReplaceOne\n     * @param {string} id - document id\n     * @param {Object} data - document properties\n     * @example\n     * collection.addOrReplaceOne('foo', { prop1: 'bar', prop2: 'baz' })\n     * @returns {Promise.<module:Result>} A promise that resolves to the operation result.\n     */\n    addOrReplaceOne(id) {\n      let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // If the reference id does not match a potential replacement\n      // document id, the operation should be aborted.\n      if (typeof data._id !== 'undefined' && data._id !== id) {\n        return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_DOCUMENT_ID_MISMATCH));\n      }\n\n      const doc = Object.assign({}, data, {\n        _id: escapeQuotes(id)\n      });\n      return collectionAdd(connection, this.getSchema(), this.getName(), [doc], {\n        upsert: true\n      }).execute();\n    },\n\n    /**\n     * Retrieve the total number of documents in the collection.\n     * @function\n     * @name module:Collection#count\n     * @returns {Promise.<number>}\n     */\n    count() {\n      const schema = table.escapeIdentifier(this.getSchema().getName());\n      const collection = table.escapeIdentifier(this.getName());\n      let count = 0;\n\n      const callback = row => {\n        count = row[0];\n      };\n\n      return sqlExecute(connection, `SELECT COUNT(*) FROM ${schema}.${collection}`).execute(callback).then(() => count).catch(err => {\n        // TODO(Rui): The server error message does not make the\n        // distinction between collections and tables, so we need\n        // to update it. Maybe this should become the job of the\n        // plugin at some point in the future.\n        const message = err.message.replace('Table', 'Collection').replace('table', 'collection');\n        err.message = err.info.msg = message;\n        throw err;\n      });\n    },\n\n    /**\n     * Check if this collection exists in the database.\n     * @function\n     * @name module:Collection#existsInDatabase\n     * @returns {Promise.<boolean>}\n     */\n    existsInDatabase() {\n      const args = [{\n        schema: this.getSchema().getName(),\n        pattern: this.getName()\n      }]; // table name must be stringified since the plugin is converting it to BINARY somehow\n\n      return sqlExecute(connection, 'list_objects', args, sqlExecute.Namespace.X_PLUGIN).execute().then(res => {\n        return res.fetchAll().some(record => record[1] === 'COLLECTION');\n      });\n    },\n\n    /**\n     * Expression that establishes the filtering criteria.\n     * @typedef {string} SearchConditionStr\n     * @global\n     * @see {@link https://dev.mysql.com/doc/x-devapi-userguide/en/crud-ebnf-other-definitions.html|X DevAPI User Guide}\n     */\n\n    /**\n     * Create an operation to find documents in the collection.\n     * @function\n     * @name module:Collection#find\n     * @param {SearchConditionStr} expr - filtering criteria\n     * @returns {module:CollectionFind} The operation instance.\n     */\n    find(expr) {\n      return collectionFind(connection, this.getSchema(), this.getName(), expr);\n    },\n\n    /**\n     * Retrieve the collection name.\n     * @function\n     * @name module:Collection#getName\n     * @returns {string}\n     */\n    getName() {\n      return state.name;\n    },\n\n    /**\n     * Retrieve the schema associated to the collection.\n     * @function\n     * @name module:Collection#getSchema\n     * @returns {module:Schema}\n     */\n    getSchema() {\n      return state.schema;\n    },\n\n    /**\n     * Retrieve the collection metadata.\n     * @function\n     * @name module:Collection#inspect\n     * @returns {Object} An object containing the relevant metadata.\n     */\n    inspect() {\n      return {\n        schema: this.getSchema().getName(),\n        collection: this.getName()\n      };\n    },\n\n    /**\n     * Create an operation to modify documents in the collection.\n     * @function\n     * @name module:Collection#modify\n     * @param {SearchConditionStr} expr - filtering criteria\n     * @example\n     * // update all documents in a collection\n     * collection.modify('true').set('name', 'bar')\n     *\n     * // update documents that match a given condition\n     * collection.modify('name = \"foo\"').set('name', 'bar')\n     * @returns {module:CollectionModify} The operation instance.\n     */\n    modify(expr) {\n      return collectionModify(connection, this.getSchema(), this.getName(), expr);\n    },\n\n    /**\n     * Create an operation to remove documents from the collection.\n     * @function\n     * @name module:Collection#remove\n     * @param {SearchConditionStr} expr - filtering criteria\n     * @example\n     * // remove all documents from a collection\n     * collection.remove('true')\n     *\n     * // remove documents that match a given condition\n     * collection.remove('name = \"foobar\"')\n     * @returns {module:CollectionRemove} The operation instance.\n     */\n    remove(expr) {\n      return collectionRemove(connection, this.getSchema(), this.getName(), expr);\n    },\n\n    /**\n     * Remove a single document with the given id.\n     * @function\n     * @name module:Collection#removeOne\n     * @param {string} id - document id\n     * @example\n     * collection.removeOne('1')\n     * @returns {Promise.<module:Result>} A promise that resolves to the operation result.\n     */\n    removeOne(id) {\n      return this.remove(`_id = \"${escapeQuotes(id)}\"`).execute();\n    },\n\n    /**\n     * Replace an entire document with a given id.\n     * @function\n     * @name module:Collection#replaceOne\n     * @param {string} id - document id\n     * @param {Object} data - document properties\n     * @example\n     * collection.replaceOne('foo', { prop1: 'bar', prop2: 'baz' })\n     * @returns {Promise.<module:Result>} A promise that resolves to the operation result.\n     */\n    replaceOne(id) {\n      let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // If the reference id does not match a potential replacement\n      // document id, the operation should be aborted.\n      if (typeof data._id !== 'undefined' && data._id !== id) {\n        return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_DOCUMENT_ID_MISMATCH));\n      }\n\n      return this.modify('_id = :id').bind('id', id).set('$', data).execute();\n    },\n\n    /**\n     * Drop an Index on a Collection given a name.\n     * @function\n     * @name module:Collection#dropIndex\n     * @param {string} name - Index name\n     * @returns {Promise.<boolean>}\n     */\n    dropIndex(name) {\n      if (typeof name !== 'string' || !name.trim().length) {\n        return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_BAD_INDEX_NAME));\n      }\n\n      const args = [{\n        name: name,\n        schema: this.getSchema().getName(),\n        collection: this.getName()\n      }];\n      return sqlExecute(connection, 'drop_collection_index', args, sqlExecute.Namespace.X_PLUGIN).execute().then(() => true).catch(err => {\n        if (!err.info || err.info.code !== errors.ER_CANT_DROP_FIELD_OR_KEY) {\n          throw err;\n        }\n\n        return false;\n      });\n    },\n\n    /**\n     * Index field definition.\n     *\n     * @typedef {Object} FieldDefinition\n     * @prop {string} field - document path\n     * @prop {string} type - index type (see example)\n     * @prop {boolean} [required=false] - allow (or not) `null` values for the column\n     * @prop {number} [options] - describes how to handle GeoJSON documents that contain geometries with coordinate dimensions higher than 2\n     * @prop {number} [srid] - unique value used to unambiguously identify projected, unprojected, and local spatial coordinate system definitions.\n     *\n     * @example\n     * INT [UNSIGNED]\n     * TINYINT [UNSIGNED]\n     * SMALLINT [UNSIGNED]\n     * MEDIUMINT [UNSIGNED]\n     * INTEGER [UNSIGNED]\n     * BIGINT [UNSIGNED]\n     * REAL [UNSIGNED]\n     * FLOAT [UNSIGNED]\n     * DOUBLE [UNSIGNED]\n     * DECIMAL [UNSIGNED]\n     * NUMERIC [UNSIGNED]\n     * DATE\n     * TIME\n     * TIMESTAMP\n     * DATETIME\n     * TEXT[(length)]\n     * GEOJSON (extra options: options, srid)\n     */\n\n    /**\n     * Index overall definition.\n     *\n     * @typedef {Object} IndexDefinition\n     * @prop {string} [type=INDEX] - index type (INDEX or SPATIAL).\n     * @prop {FieldDefinition[]} fields - index field definitions\n     */\n\n    /**\n     * Create a new index.\n     * @function\n     * @name module:Collection#createIndex\n     * @param {string} name - index name\n     * @param {IndexDefinition} constraint - index definition\n     * @returns {Promise.<boolean>}\n     */\n    createIndex(name, constraint) {\n      constraint = Object.assign({\n        fields: []\n      }, constraint);\n\n      if (typeof name !== 'string' || !name.trim().length) {\n        return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_BAD_INDEX_NAME));\n      }\n\n      const isValidDefinition = Array.isArray(constraint.fields) && constraint.fields.length && constraint.fields.every(field => {\n        return typeof field.field === 'string' && typeof field.type === 'string';\n      });\n\n      if (!isValidDefinition) {\n        return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_BAD_INDEX_DEFINITION));\n      }\n\n      if (constraint.unique === true) {\n        return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_NO_UNIQUE_INDEX));\n      }\n\n      const args = [{\n        name: name,\n        schema: this.getSchema().getName(),\n        collection: this.getName(),\n        unique: false,\n        type: constraint.type || 'INDEX',\n        constraint: constraint.fields.map(item => {\n          // 'field' property is renamed to 'member' to avoid an x-plugin incompatibility.\n          const data = Object.assign({\n            array: item.array || false,\n            member: item.field,\n            required: false\n          }, item);\n          delete data.field;\n          return data;\n        })\n      }];\n      return sqlExecute(connection, 'create_collection_index', args, sqlExecute.Namespace.X_PLUGIN).execute().then(() => true);\n    }\n\n  }); // Building the operation once avoids to parse the same expression over and over again\n  // and at the same time allows it to take advantage of server-side prepared statements.\n\n  const findOne = collection.find('_id = :id');\n  const extendedCollection = Object.assign({}, collection, {\n    /**\n     * Retrieve a single document with the given id.\n     * @function\n     * @name module:Collection#getOne\n     * @param {string} id - document id\n     * @example\n     * collection.getOne('1')\n     * @returns {Object} The document instance.\n     */\n    getOne(id) {\n      let instance = null; // if the id is not provided, there is no need to even ask the server\n\n      if (typeof id === 'undefined') {\n        return Promise.resolve(instance);\n      }\n\n      return findOne.bind('id', id).execute(doc => {\n        instance = doc;\n      }).then(() => instance);\n    }\n\n  });\n  return extendedCollection;\n}\n\nmodule.exports = Collection;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/DevAPI/Collection.js"],"names":["collectionAdd","require","collectionFind","collectionModify","collectionRemove","databaseObject","errors","escapeQuotes","parseFlexibleParamList","sqlExecute","table","Collection","connection","schema","name","state","Object","assign","collection","add","documents","Array","prototype","slice","call","arguments","getSchema","getName","addOrReplaceOne","id","data","_id","Promise","reject","Error","MESSAGES","ER_DEVAPI_DOCUMENT_ID_MISMATCH","doc","upsert","execute","count","escapeIdentifier","callback","row","then","catch","err","message","replace","info","msg","existsInDatabase","args","pattern","Namespace","X_PLUGIN","res","fetchAll","some","record","find","expr","inspect","modify","remove","removeOne","replaceOne","bind","set","dropIndex","trim","length","ER_DEVAPI_BAD_INDEX_NAME","code","ER_CANT_DROP_FIELD_OR_KEY","createIndex","constraint","fields","isValidDefinition","isArray","every","field","type","ER_DEVAPI_BAD_INDEX_DEFINITION","unique","ER_DEVAPI_NO_UNIQUE_INDEX","map","item","array","member","required","findOne","extendedCollection","getOne","instance","resolve","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2015, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst collectionAdd = require('./CollectionAdd');\nconst collectionFind = require('./CollectionFind');\nconst collectionModify = require('./CollectionModify');\nconst collectionRemove = require('./CollectionRemove');\nconst databaseObject = require('./DatabaseObject');\nconst errors = require('../constants/errors');\nconst escapeQuotes = require('./Util/escapeQuotes');\nconst parseFlexibleParamList = require('./Util/parseFlexibleParamList');\nconst sqlExecute = require('./SqlExecute');\nconst table = require('./Table');\n\n/**\n * Collection factory.\n * @module Collection\n * @mixes DatabaseObject\n */\n\n/**\n * @private\n * @alias module:Collection\n * @param {Connection} connection - database connection context\n * @param {module:Schema} schema - schema to bind\n * @param {string} name - collection name\n * @returns {module:Collection}\n */\nfunction Collection (connection, schema, name) {\n    const state = Object.assign({}, { name, schema });\n\n    const collection = Object.assign({}, databaseObject(connection), {\n        /**\n         * Literal object or JSON counterpart.\n         * @typedef {Object|string} DocumentOrJSON\n         * @global\n         * @example\n         * // literal object\n         * { foo: 'bar' }\n         * // JSON string\n         * '{ \"foo\": \"bar\" }'\n         */\n\n        /**\n         * Create an operation to add one or more documents to the collection.\n         * @function\n         * @name module:Collection#add\n         * @param {...DocumentOrJSON|DocumentOrJSON[]} expr - object with document data\n         * @throws {Error} When the input type is invalid.\n         * @example\n         * // arguments as single documents\n         * collection.add({ foo: 'baz' }, { bar: 'qux' })\n         *\n         * // array of documents\n         * collection.add([{ foo: 'baz' }, { bar: 'qux' }])\n         * @returns {module:CollectionAdd} The operation instance.\n         */\n        add () {\n            const documents = parseFlexibleParamList(Array.prototype.slice.call(arguments));\n\n            return collectionAdd(connection, this.getSchema(), this.getName(), documents);\n        },\n\n        /**\n         * Create or replace a document with the given id.\n         * @function\n         * @name module:Collection#addOrReplaceOne\n         * @param {string} id - document id\n         * @param {Object} data - document properties\n         * @example\n         * collection.addOrReplaceOne('foo', { prop1: 'bar', prop2: 'baz' })\n         * @returns {Promise.<module:Result>} A promise that resolves to the operation result.\n         */\n        addOrReplaceOne (id, data = {}) {\n            // If the reference id does not match a potential replacement\n            // document id, the operation should be aborted.\n            if (typeof data._id !== 'undefined' && data._id !== id) {\n                return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_DOCUMENT_ID_MISMATCH));\n            }\n\n            const doc = Object.assign({}, data, { _id: escapeQuotes(id) });\n\n            return collectionAdd(connection, this.getSchema(), this.getName(), [doc], { upsert: true }).execute();\n        },\n\n        /**\n         * Retrieve the total number of documents in the collection.\n         * @function\n         * @name module:Collection#count\n         * @returns {Promise.<number>}\n         */\n        count () {\n            const schema = table.escapeIdentifier(this.getSchema().getName());\n            const collection = table.escapeIdentifier(this.getName());\n\n            let count = 0;\n            const callback = row => { count = row[0]; };\n\n            return sqlExecute(connection, `SELECT COUNT(*) FROM ${schema}.${collection}`)\n                .execute(callback)\n                .then(() => count)\n                .catch(err => {\n                    // TODO(Rui): The server error message does not make the\n                    // distinction between collections and tables, so we need\n                    // to update it. Maybe this should become the job of the\n                    // plugin at some point in the future.\n                    const message = err.message.replace('Table', 'Collection').replace('table', 'collection');\n                    err.message = err.info.msg = message;\n\n                    throw err;\n                });\n        },\n\n        /**\n         * Check if this collection exists in the database.\n         * @function\n         * @name module:Collection#existsInDatabase\n         * @returns {Promise.<boolean>}\n         */\n        existsInDatabase () {\n            const args = [{ schema: this.getSchema().getName(), pattern: this.getName() }];\n\n            // table name must be stringified since the plugin is converting it to BINARY somehow\n            return sqlExecute(connection, 'list_objects', args, sqlExecute.Namespace.X_PLUGIN)\n                .execute()\n                .then(res => {\n                    return res.fetchAll().some(record => record[1] === 'COLLECTION');\n                });\n        },\n\n        /**\n         * Expression that establishes the filtering criteria.\n         * @typedef {string} SearchConditionStr\n         * @global\n         * @see {@link https://dev.mysql.com/doc/x-devapi-userguide/en/crud-ebnf-other-definitions.html|X DevAPI User Guide}\n         */\n\n        /**\n         * Create an operation to find documents in the collection.\n         * @function\n         * @name module:Collection#find\n         * @param {SearchConditionStr} expr - filtering criteria\n         * @returns {module:CollectionFind} The operation instance.\n         */\n        find (expr) {\n            return collectionFind(connection, this.getSchema(), this.getName(), expr);\n        },\n\n        /**\n         * Retrieve the collection name.\n         * @function\n         * @name module:Collection#getName\n         * @returns {string}\n         */\n        getName () {\n            return state.name;\n        },\n\n        /**\n         * Retrieve the schema associated to the collection.\n         * @function\n         * @name module:Collection#getSchema\n         * @returns {module:Schema}\n         */\n        getSchema () {\n            return state.schema;\n        },\n\n        /**\n         * Retrieve the collection metadata.\n         * @function\n         * @name module:Collection#inspect\n         * @returns {Object} An object containing the relevant metadata.\n         */\n        inspect () {\n            return { schema: this.getSchema().getName(), collection: this.getName() };\n        },\n\n        /**\n         * Create an operation to modify documents in the collection.\n         * @function\n         * @name module:Collection#modify\n         * @param {SearchConditionStr} expr - filtering criteria\n         * @example\n         * // update all documents in a collection\n         * collection.modify('true').set('name', 'bar')\n         *\n         * // update documents that match a given condition\n         * collection.modify('name = \"foo\"').set('name', 'bar')\n         * @returns {module:CollectionModify} The operation instance.\n         */\n        modify (expr) {\n            return collectionModify(connection, this.getSchema(), this.getName(), expr);\n        },\n\n        /**\n         * Create an operation to remove documents from the collection.\n         * @function\n         * @name module:Collection#remove\n         * @param {SearchConditionStr} expr - filtering criteria\n         * @example\n         * // remove all documents from a collection\n         * collection.remove('true')\n         *\n         * // remove documents that match a given condition\n         * collection.remove('name = \"foobar\"')\n         * @returns {module:CollectionRemove} The operation instance.\n         */\n        remove (expr) {\n            return collectionRemove(connection, this.getSchema(), this.getName(), expr);\n        },\n\n        /**\n         * Remove a single document with the given id.\n         * @function\n         * @name module:Collection#removeOne\n         * @param {string} id - document id\n         * @example\n         * collection.removeOne('1')\n         * @returns {Promise.<module:Result>} A promise that resolves to the operation result.\n         */\n        removeOne (id) {\n            return this.remove(`_id = \"${escapeQuotes(id)}\"`).execute();\n        },\n\n        /**\n         * Replace an entire document with a given id.\n         * @function\n         * @name module:Collection#replaceOne\n         * @param {string} id - document id\n         * @param {Object} data - document properties\n         * @example\n         * collection.replaceOne('foo', { prop1: 'bar', prop2: 'baz' })\n         * @returns {Promise.<module:Result>} A promise that resolves to the operation result.\n         */\n        replaceOne (id, data = {}) {\n            // If the reference id does not match a potential replacement\n            // document id, the operation should be aborted.\n            if (typeof data._id !== 'undefined' && data._id !== id) {\n                return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_DOCUMENT_ID_MISMATCH));\n            }\n\n            return this.modify('_id = :id')\n                .bind('id', id)\n                .set('$', data)\n                .execute();\n        },\n\n        /**\n         * Drop an Index on a Collection given a name.\n         * @function\n         * @name module:Collection#dropIndex\n         * @param {string} name - Index name\n         * @returns {Promise.<boolean>}\n         */\n        dropIndex (name) {\n            if (typeof name !== 'string' || !name.trim().length) {\n                return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_BAD_INDEX_NAME));\n            }\n\n            const args = [{\n                name: name,\n                schema: this.getSchema().getName(),\n                collection: this.getName()\n            }];\n\n            return sqlExecute(connection, 'drop_collection_index', args, sqlExecute.Namespace.X_PLUGIN).execute()\n                .then(() => true)\n                .catch(err => {\n                    if (!err.info || err.info.code !== errors.ER_CANT_DROP_FIELD_OR_KEY) {\n                        throw err;\n                    }\n\n                    return false;\n                });\n        },\n\n        /**\n         * Index field definition.\n         *\n         * @typedef {Object} FieldDefinition\n         * @prop {string} field - document path\n         * @prop {string} type - index type (see example)\n         * @prop {boolean} [required=false] - allow (or not) `null` values for the column\n         * @prop {number} [options] - describes how to handle GeoJSON documents that contain geometries with coordinate dimensions higher than 2\n         * @prop {number} [srid] - unique value used to unambiguously identify projected, unprojected, and local spatial coordinate system definitions.\n         *\n         * @example\n         * INT [UNSIGNED]\n         * TINYINT [UNSIGNED]\n         * SMALLINT [UNSIGNED]\n         * MEDIUMINT [UNSIGNED]\n         * INTEGER [UNSIGNED]\n         * BIGINT [UNSIGNED]\n         * REAL [UNSIGNED]\n         * FLOAT [UNSIGNED]\n         * DOUBLE [UNSIGNED]\n         * DECIMAL [UNSIGNED]\n         * NUMERIC [UNSIGNED]\n         * DATE\n         * TIME\n         * TIMESTAMP\n         * DATETIME\n         * TEXT[(length)]\n         * GEOJSON (extra options: options, srid)\n         */\n\n        /**\n         * Index overall definition.\n         *\n         * @typedef {Object} IndexDefinition\n         * @prop {string} [type=INDEX] - index type (INDEX or SPATIAL).\n         * @prop {FieldDefinition[]} fields - index field definitions\n         */\n\n        /**\n         * Create a new index.\n         * @function\n         * @name module:Collection#createIndex\n         * @param {string} name - index name\n         * @param {IndexDefinition} constraint - index definition\n         * @returns {Promise.<boolean>}\n         */\n        createIndex (name, constraint) {\n            constraint = Object.assign({ fields: [] }, constraint);\n            if (typeof name !== 'string' || !name.trim().length) {\n                return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_BAD_INDEX_NAME));\n            }\n\n            const isValidDefinition = Array.isArray(constraint.fields) && constraint.fields.length && constraint.fields.every((field) => {\n                return typeof field.field === 'string' && typeof field.type === 'string';\n            });\n\n            if (!isValidDefinition) {\n                return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_BAD_INDEX_DEFINITION));\n            }\n\n            if (constraint.unique === true) {\n                return Promise.reject(new Error(errors.MESSAGES.ER_DEVAPI_NO_UNIQUE_INDEX));\n            }\n\n            const args = [{\n                name: name,\n                schema: this.getSchema().getName(),\n                collection: this.getName(),\n                unique: false,\n                type: constraint.type || 'INDEX',\n                constraint: constraint.fields.map(item => {\n                    // 'field' property is renamed to 'member' to avoid an x-plugin incompatibility.\n                    const data = Object.assign({ array: item.array || false, member: item.field, required: false }, item);\n                    delete data.field;\n\n                    return data;\n                })\n            }];\n\n            return sqlExecute(connection, 'create_collection_index', args, sqlExecute.Namespace.X_PLUGIN)\n                .execute()\n                .then(() => true);\n        }\n    });\n\n    // Building the operation once avoids to parse the same expression over and over again\n    // and at the same time allows it to take advantage of server-side prepared statements.\n    const findOne = collection.find('_id = :id');\n\n    const extendedCollection = Object.assign({}, collection, {\n        /**\n         * Retrieve a single document with the given id.\n         * @function\n         * @name module:Collection#getOne\n         * @param {string} id - document id\n         * @example\n         * collection.getOne('1')\n         * @returns {Object} The document instance.\n         */\n        getOne (id) {\n            let instance = null;\n\n            // if the id is not provided, there is no need to even ask the server\n            if (typeof id === 'undefined') {\n                return Promise.resolve(instance);\n            }\n\n            return findOne.bind('id', id)\n                .execute(doc => {\n                    instance = doc;\n                })\n                .then(() => instance);\n        }\n    });\n\n    return extendedCollection;\n}\n\nmodule.exports = Collection;\n"]},"metadata":{},"sourceType":"script"}