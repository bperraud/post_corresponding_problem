{"ast":null,"code":"/*\n * Copyright (c) 2016, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst AuthenticationHandler = require('./InboundHandlers/AuthenticationHandler');\n\nconst CapabilitiesGetHandler = require('./InboundHandlers/CapabilitiesGetHandler');\n\nconst ClientMessages = require('./Stubs/mysqlx_pb').ClientMessages;\n\nconst Connection = require('./OutboundHandlers/Connection');\n\nconst Crud = require('./OutboundHandlers/Crud');\n\nconst Expect = require('./OutboundHandlers/Expect');\n\nconst NoticeStub = require('./Stubs/mysqlx_notice_pb');\n\nconst OkHandler = require('./InboundHandlers/OkHandler');\n\nconst Prepare = require('./OutboundHandlers/Prepare');\n\nconst Session = require('./OutboundHandlers/Session');\n\nconst Sql = require('./OutboundHandlers/Sql');\n\nconst SqlResultHandler = require('./InboundHandlers/SqlResultHandler');\n\nconst WorkQueue = require('../WorkQueue');\n\nconst condition = require('./Wrappers/Messages/Expect/Condition');\n\nconst error = require('./Wrappers/Messages/Error');\n\nconst errors = require('../constants/errors');\n\nconst log = require('../logger');\n\nconst notice = require('./Wrappers/Messages/Notice/Frame');\n\nconst REQUIRES_REAUTH = {\n  NO: 'NO',\n  UNKNOWN: 'UNKNOWN',\n  YES: 'YES'\n};\n/**\n * Main Protocol class\n * @param stream {stream}\n * @constructor\n * @private\n */\n\nfunction Client(stream) {\n  this._stream = stream;\n  this._workQueue = new WorkQueue();\n  this._danglingFragment = null;\n  this._requiresAuthenticationAfterReset = REQUIRES_REAUTH.UNKNOWN;\n}\n\nmodule.exports = Client;\n\nClient.prototype.getConnection = function () {\n  return this._stream;\n};\n\nClient.prototype.setConnection = function (connection) {\n  this._stream = connection;\n  return this;\n};\n/**\n * Encode X protocol message (with header and payload).\n * @param {number} messageType - type of the message payload\n * @param {Buffer} data - raw payload data\n * @returns {Buffer} The full X protocol message buffer.\n */\n\n\nClient.prototype.encodeMessage = function (messageType, data) {\n  // The message must accommodate (besides payload size) additionally, 4\n  // bytes for the header and 1 byte for the message id.\n  // Since the entire buffer will be written, we should use\n  // \"Buffer.allocUnsafe()\" instead of \"Buffer.alloc()\" because it is faster.\n  // https://nodejs.org/docs/v12.0.0/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe\n  const buffer = Buffer.allocUnsafe(data.length + 5);\n  data.copy(buffer, 5); // The total payload size should not include the size of the length header field.\n\n  buffer.writeUInt32LE(buffer.length - 4, 0);\n  buffer[4] = messageType;\n  return buffer;\n};\n\nClient.prototype.decodeMessage = function (data) {\n  // Check if the connection is using the old MySQL wire protocol.\n  const isWireProtocol = data.readInt32LE(0) + 4 <= data.length && // package length\n  data[3] === 0 && // package number\n  data[4] === 10; // protocol version\n\n  if (isWireProtocol) {\n    throw new Error(errors.MESSAGES.ER_CLIENT_NO_X_PROTOCOL);\n  }\n\n  const header = this.decodeMessageHeader(data);\n\n  if (data.length < header.packetLength) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_INCOMPLETE_PROTOCOL_MESSAGE);\n  }\n\n  const payload = data.slice(5, header.packetLength);\n  return {\n    id: header.messageId,\n    payload\n  };\n};\n\nClient.prototype.decodeMessageHeader = function (data) {\n  if (data.length < 4\n  /* header size */\n  + 1\n  /* type flag size */\n  ) {\n    throw new Error(errors.MESSAGES.ER_X_CLIENT_UNKNOWN_PROTOCOL_HEADER);\n  }\n\n  return {\n    // The length reported by the server does not include the length of the header.\n    packetLength: data.readUInt32LE(0) + 4,\n    messageId: data[4]\n  };\n};\n/**\n * Handle an individual message\n *\n * The passed buffer must only contain the single message\n *\n * @param {Buffer} message\n */\n\n\nClient.prototype.handleServerMessage = function (message) {\n  const decoded = this.decodeMessage(message);\n\n  if (decoded.id === notice.MESSAGE_ID) {\n    // TODO(Rui): Non-global notices are being decoded twice (in the handler as well).\n    // This will change in an upcoming refactoring plan.\n    const frame = notice.deserialize(decoded.payload);\n\n    if (frame.getScopeId() === NoticeStub.Frame.Scope.GLOBAL) {\n      log('protocol:inbound:Mysqlx.Notice').info('Frame', frame);\n\n      if (frame.getTypeId() === NoticeStub.Frame.Type.WARNING) {\n        const payload = frame.getPayload();\n\n        if (payload.getLevelId() === NoticeStub.Warning.Level.ERROR) {\n          const error = new Error(errors.MESSAGES[errors[payload.getCode()]]);\n\n          this._stream.emit('error', error);\n        }\n      }\n\n      return;\n    }\n  }\n\n  this._workQueue.process(decoded);\n};\n/**\n * This is the entry point for everything from the network\n *\n * Here we split multiple messages from one network packet and and reassemble\n * fragmented pieces. Each individual message is passed over to\n * handleServerMessage.\n *\n * @param {Buffer} fragment\n */\n\n\nClient.prototype.handleNetworkFragment = function (fragment) {\n  if (this._danglingFragment) {\n    // The previous fragment contained an incomplete message that requires data from the current fragment.\n    fragment = Buffer.concat([this._danglingFragment, fragment], this._danglingFragment.length + fragment.length);\n  } // X Protocol header length = 4 bytes.\n\n\n  const headerLength = 4;\n  let offset = 0;\n\n  while (offset < fragment.length) {\n    // Work on the scope of a single message.\n    const chunk = fragment.slice(offset);\n\n    if (chunk.length < headerLength) {\n      // There is no reason for this to happen, but we can play it safe.\n      this._danglingFragment = chunk;\n      return;\n    } // The value encoded in the message length segment does not include the size\n    // of that same segment.\n\n\n    const payloadLength = chunk.readUInt32LE(0) + headerLength;\n\n    if (chunk.length < payloadLength) {\n      // The message is still incomplete.\n      this._danglingFragment = chunk;\n      return;\n    }\n\n    this._danglingFragment = null;\n    this.handleServerMessage(chunk.slice(0, payloadLength));\n\n    if (chunk.length === payloadLength) {\n      // The current chunk matches an entire message.\n      return;\n    } // The current chunk contains data from additional messages.\n    // The next loop iteration should start from the beginning of the next one.\n\n\n    offset += payloadLength;\n  }\n};\n\nClient.prototype.handleServerClose = function () {\n  while (this._workQueue.hasMore()) {\n    this._workQueue.process({\n      id: error.SERVER_GONE\n    });\n  }\n};\n\nClient.prototype.isRunning = function () {\n  return this._workQueue.hasMore();\n};\n/**\n * Send a Mysqlx.Connection.CapabilitiesGet message to the server.\n * @private\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.capabilitiesGet = function () {\n  const messageType = ClientMessages.Type.CON_CAPABILITIES_GET;\n  const protobuf = this.encodeMessage(messageType, Connection.encodeCapabilitiesGet());\n  const handler = new CapabilitiesGetHandler(this);\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Connection.CapabilitiesSet message to the server.\n * @private\n * @param {Object} properties - connection properties\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.capabilitiesSet = function (properties) {\n  const messageType = ClientMessages.Type.CON_CAPABILITIES_SET;\n  const protobuf = this.encodeMessage(messageType, Connection.encodeCapabilitiesSet(properties));\n  const handler = new OkHandler(this);\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Session.AuthenticateStart message to the server.\n * @private\n * @param {IAuthenticator} authenticator - authenticator instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.authenticate = function (authenticator) {\n  // cache the authentication plugin\n  this._authenticator = authenticator;\n  const messageType = ClientMessages.Type.SESS_AUTHENTICATE_START;\n  const protobuf = this.encodeMessage(messageType, Session.encodeAuthenticateStart(authenticator.getName(), authenticator.getInitialAuthData()));\n  const handler = new AuthenticationHandler(authenticator, this);\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Session.AuthenticateContinue message to the server.\n * @private\n * @param {Buffer} data - raw connection data\n * @param {AuthenticationHandler} handler - active authentication handler\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.authenticateContinue = function (data, handler) {\n  const messageType = ClientMessages.Type.SESS_AUTHENTICATE_CONTINUE;\n  const protobuf = this.encodeMessage(messageType, Session.encodeAuthenticateContinue(data));\n  handler.sendDirect(this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Crud.Insert message to the server.\n * @private\n * @param {module:CollectionAdd|module:TableInsert} query - the operation instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.crudInsert = function (query) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.CRUD_INSERT, Crud.encodeInsert(query));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new SqlResultHandler();\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Crud.Find message to the server.\n * @private\n * @param {Object} query - the query data\n * @param {Function} resultSetCursor\n * @param {Function} metadataCursor\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.crudFind = function (query, resultSetCursor, metadataCursor) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.CRUD_FIND, Crud.encodeFind(query));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new SqlResultHandler(resultSetCursor, metadataCursor);\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Crud.Update message to the server.\n * @private\n * @param {module:CollectionModify|module:TableUpdate} query - the operation instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.crudModify = function (query) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.CRUD_UPDATE, Crud.encodeUpdate(query));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new SqlResultHandler();\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Crud.Delete message to the server.\n * @private\n * @param {module:CollectionRemove|module:TableDelete} query - the operation instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.crudRemove = function (query) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.CRUD_DELETE, Crud.encodeDelete(query));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new SqlResultHandler();\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Sql.StmtExecute message to the server.\n * @private\n * @param {StmtExecute} query - the operation instance\n * @param {Function} resultSetCursor\n * @param {Function} metadataCursor\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.sqlStmtExecute = function (query, resultSetCursor, metadataCursor) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.SQL_STMT_EXECUTE, Sql.encodeStmtExecute(query));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new SqlResultHandler(resultSetCursor, metadataCursor);\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Prepare.Prepare message to the server.\n * @private\n * @param {Query} statement - the statement instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.prepare = function (statement) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.PREPARE_PREPARE, Prepare.encodePrepare(statement));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new OkHandler();\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Prepare.Execute message to the server.\n * @private\n * @param {Query} statement - the statement instance\n * @param {Function} resultSetCursor\n * @param {Function} metadataCursor\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.prepareExecute = function (statement, resultSetCursor, metadataCursor) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.PREPARE_EXECUTE, Prepare.encodeExecute(statement));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new SqlResultHandler(resultSetCursor, metadataCursor);\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Prepare.Deallocate message to the server.\n * @private\n * @param {Query} statement - the statement instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.deallocate = function (statement) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.PREPARE_DEALLOCATE, Prepare.encodeDeallocate(statement));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new OkHandler();\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Session.Close message to the server.\n * @private\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.sessionClose = function () {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.SESS_CLOSE, Session.encodeClose());\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new OkHandler();\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n/**\n * Send a Mysqlx.Session.Reset message to the server.\n * @private\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.sessionReset = function () {\n  const reset = options => {\n    let protobuf;\n\n    try {\n      protobuf = this.encodeMessage(ClientMessages.Type.SESS_RESET, Session.encodeReset(options));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    const handler = new OkHandler();\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n  };\n\n  if (this._requiresAuthenticationAfterReset === REQUIRES_REAUTH.NO) {\n    return reset({\n      keepOpen: true\n    });\n  }\n\n  if (this._requiresAuthenticationAfterReset === REQUIRES_REAUTH.YES) {\n    return reset({\n      keepOpen: false\n    }).then(() => this.authenticate(this._authenticator));\n  }\n\n  const expectations = [{\n    condition: condition.ACTION.EXPECT_OP_SET,\n    key: condition.TYPE.EXPECT_FIELD_EXIST,\n    value: '6.1' // checks if SESS_RESET message supports the \"keep_open\" property\n\n  }];\n  return this.expectOpen(expectations).then(() => reset({\n    keepOpen: true\n  })).then(() => this.expectClose()).then(() => {\n    this._requiresAuthenticationAfterReset = REQUIRES_REAUTH.NO;\n  }).catch(err => {\n    if (err.info && err.info.code !== errors.ER_X_EXPECT_FIELD_EXISTS_FAILED) {\n      throw err;\n    }\n\n    this._requiresAuthenticationAfterReset = REQUIRES_REAUTH.YES;\n    return this.sessionReset();\n  });\n};\n/**\n * Send a Mysqlx.Connection.Close message to the server.\n * @private\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\n\n\nClient.prototype.connectionClose = function () {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.CON_CLOSE, Connection.encodeClose());\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new OkHandler();\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\nClient.prototype.expectClose = function () {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.EXPECT_OPEN, Expect.encodeClose());\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new OkHandler(this);\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\nClient.prototype.expectOpen = function (expectations) {\n  let protobuf;\n\n  try {\n    protobuf = this.encodeMessage(ClientMessages.Type.EXPECT_OPEN, Expect.encodeOpen(expectations));\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  const handler = new OkHandler(this);\n  return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/Protocol/Client.js"],"names":["AuthenticationHandler","require","CapabilitiesGetHandler","ClientMessages","Connection","Crud","Expect","NoticeStub","OkHandler","Prepare","Session","Sql","SqlResultHandler","WorkQueue","condition","error","errors","log","notice","REQUIRES_REAUTH","NO","UNKNOWN","YES","Client","stream","_stream","_workQueue","_danglingFragment","_requiresAuthenticationAfterReset","module","exports","prototype","getConnection","setConnection","connection","encodeMessage","messageType","data","buffer","Buffer","allocUnsafe","length","copy","writeUInt32LE","decodeMessage","isWireProtocol","readInt32LE","Error","MESSAGES","ER_CLIENT_NO_X_PROTOCOL","header","decodeMessageHeader","packetLength","ER_DEVAPI_INCOMPLETE_PROTOCOL_MESSAGE","payload","slice","id","messageId","ER_X_CLIENT_UNKNOWN_PROTOCOL_HEADER","readUInt32LE","handleServerMessage","message","decoded","MESSAGE_ID","frame","deserialize","getScopeId","Frame","Scope","GLOBAL","info","getTypeId","Type","WARNING","getPayload","getLevelId","Warning","Level","ERROR","getCode","emit","process","handleNetworkFragment","fragment","concat","headerLength","offset","chunk","payloadLength","handleServerClose","hasMore","SERVER_GONE","isRunning","capabilitiesGet","CON_CAPABILITIES_GET","protobuf","encodeCapabilitiesGet","handler","sendMessage","capabilitiesSet","properties","CON_CAPABILITIES_SET","encodeCapabilitiesSet","authenticate","authenticator","_authenticator","SESS_AUTHENTICATE_START","encodeAuthenticateStart","getName","getInitialAuthData","authenticateContinue","SESS_AUTHENTICATE_CONTINUE","encodeAuthenticateContinue","sendDirect","crudInsert","query","CRUD_INSERT","encodeInsert","err","Promise","reject","crudFind","resultSetCursor","metadataCursor","CRUD_FIND","encodeFind","crudModify","CRUD_UPDATE","encodeUpdate","crudRemove","CRUD_DELETE","encodeDelete","sqlStmtExecute","SQL_STMT_EXECUTE","encodeStmtExecute","prepare","statement","PREPARE_PREPARE","encodePrepare","prepareExecute","PREPARE_EXECUTE","encodeExecute","deallocate","PREPARE_DEALLOCATE","encodeDeallocate","sessionClose","SESS_CLOSE","encodeClose","sessionReset","reset","options","SESS_RESET","encodeReset","keepOpen","then","expectations","ACTION","EXPECT_OP_SET","key","TYPE","EXPECT_FIELD_EXIST","value","expectOpen","expectClose","catch","code","ER_X_EXPECT_FIELD_EXISTS_FAILED","connectionClose","CON_CLOSE","EXPECT_OPEN","encodeOpen"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst AuthenticationHandler = require('./InboundHandlers/AuthenticationHandler');\nconst CapabilitiesGetHandler = require('./InboundHandlers/CapabilitiesGetHandler');\nconst ClientMessages = require('./Stubs/mysqlx_pb').ClientMessages;\nconst Connection = require('./OutboundHandlers/Connection');\nconst Crud = require('./OutboundHandlers/Crud');\nconst Expect = require('./OutboundHandlers/Expect');\nconst NoticeStub = require('./Stubs/mysqlx_notice_pb');\nconst OkHandler = require('./InboundHandlers/OkHandler');\nconst Prepare = require('./OutboundHandlers/Prepare');\nconst Session = require('./OutboundHandlers/Session');\nconst Sql = require('./OutboundHandlers/Sql');\nconst SqlResultHandler = require('./InboundHandlers/SqlResultHandler');\nconst WorkQueue = require('../WorkQueue');\nconst condition = require('./Wrappers/Messages/Expect/Condition');\nconst error = require('./Wrappers/Messages/Error');\nconst errors = require('../constants/errors');\nconst log = require('../logger');\nconst notice = require('./Wrappers/Messages/Notice/Frame');\n\nconst REQUIRES_REAUTH = {\n    NO: 'NO',\n    UNKNOWN: 'UNKNOWN',\n    YES: 'YES'\n};\n\n/**\n * Main Protocol class\n * @param stream {stream}\n * @constructor\n * @private\n */\nfunction Client (stream) {\n    this._stream = stream;\n    this._workQueue = new WorkQueue();\n    this._danglingFragment = null;\n    this._requiresAuthenticationAfterReset = REQUIRES_REAUTH.UNKNOWN;\n}\n\nmodule.exports = Client;\n\nClient.prototype.getConnection = function () {\n    return this._stream;\n};\n\nClient.prototype.setConnection = function (connection) {\n    this._stream = connection;\n    return this;\n};\n\n/**\n * Encode X protocol message (with header and payload).\n * @param {number} messageType - type of the message payload\n * @param {Buffer} data - raw payload data\n * @returns {Buffer} The full X protocol message buffer.\n */\nClient.prototype.encodeMessage = function (messageType, data) {\n    // The message must accommodate (besides payload size) additionally, 4\n    // bytes for the header and 1 byte for the message id.\n    // Since the entire buffer will be written, we should use\n    // \"Buffer.allocUnsafe()\" instead of \"Buffer.alloc()\" because it is faster.\n    // https://nodejs.org/docs/v12.0.0/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe\n    const buffer = Buffer.allocUnsafe(data.length + 5);\n\n    data.copy(buffer, 5);\n\n    // The total payload size should not include the size of the length header field.\n    buffer.writeUInt32LE(buffer.length - 4, 0);\n    buffer[4] = messageType;\n\n    return buffer;\n};\n\nClient.prototype.decodeMessage = function (data) {\n    // Check if the connection is using the old MySQL wire protocol.\n    const isWireProtocol = data.readInt32LE(0) + 4 <= data.length && // package length\n        data[3] === 0 && // package number\n        data[4] === 10; // protocol version\n\n    if (isWireProtocol) {\n        throw new Error(errors.MESSAGES.ER_CLIENT_NO_X_PROTOCOL);\n    }\n\n    const header = this.decodeMessageHeader(data);\n\n    if (data.length < header.packetLength) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_INCOMPLETE_PROTOCOL_MESSAGE);\n    }\n\n    const payload = data.slice(5, header.packetLength);\n\n    return { id: header.messageId, payload };\n};\n\nClient.prototype.decodeMessageHeader = function (data) {\n    if (data.length < 4 /* header size */ + 1 /* type flag size */) {\n        throw new Error(errors.MESSAGES.ER_X_CLIENT_UNKNOWN_PROTOCOL_HEADER);\n    }\n\n    return {\n        // The length reported by the server does not include the length of the header.\n        packetLength: data.readUInt32LE(0) + 4,\n        messageId: data[4]\n    };\n};\n\n/**\n * Handle an individual message\n *\n * The passed buffer must only contain the single message\n *\n * @param {Buffer} message\n */\nClient.prototype.handleServerMessage = function (message) {\n    const decoded = this.decodeMessage(message);\n\n    if (decoded.id === notice.MESSAGE_ID) {\n        // TODO(Rui): Non-global notices are being decoded twice (in the handler as well).\n        // This will change in an upcoming refactoring plan.\n        const frame = notice.deserialize(decoded.payload);\n\n        if (frame.getScopeId() === NoticeStub.Frame.Scope.GLOBAL) {\n            log('protocol:inbound:Mysqlx.Notice').info('Frame', frame);\n\n            if (frame.getTypeId() === NoticeStub.Frame.Type.WARNING) {\n                const payload = frame.getPayload();\n\n                if (payload.getLevelId() === NoticeStub.Warning.Level.ERROR) {\n                    const error = new Error(errors.MESSAGES[errors[payload.getCode()]]);\n                    this._stream.emit('error', error);\n                }\n            }\n\n            return;\n        }\n    }\n\n    this._workQueue.process(decoded);\n};\n\n/**\n * This is the entry point for everything from the network\n *\n * Here we split multiple messages from one network packet and and reassemble\n * fragmented pieces. Each individual message is passed over to\n * handleServerMessage.\n *\n * @param {Buffer} fragment\n */\nClient.prototype.handleNetworkFragment = function (fragment) {\n    if (this._danglingFragment) {\n        // The previous fragment contained an incomplete message that requires data from the current fragment.\n        fragment = Buffer.concat([this._danglingFragment, fragment], this._danglingFragment.length + fragment.length);\n    }\n\n    // X Protocol header length = 4 bytes.\n    const headerLength = 4;\n\n    let offset = 0;\n\n    while (offset < fragment.length) {\n        // Work on the scope of a single message.\n        const chunk = fragment.slice(offset);\n\n        if (chunk.length < headerLength) {\n            // There is no reason for this to happen, but we can play it safe.\n            this._danglingFragment = chunk;\n            return;\n        }\n\n        // The value encoded in the message length segment does not include the size\n        // of that same segment.\n        const payloadLength = chunk.readUInt32LE(0) + headerLength;\n\n        if (chunk.length < payloadLength) {\n            // The message is still incomplete.\n            this._danglingFragment = chunk;\n            return;\n        }\n\n        this._danglingFragment = null;\n        this.handleServerMessage(chunk.slice(0, payloadLength));\n\n        if (chunk.length === payloadLength) {\n            // The current chunk matches an entire message.\n            return;\n        }\n\n        // The current chunk contains data from additional messages.\n        // The next loop iteration should start from the beginning of the next one.\n        offset += payloadLength;\n    }\n};\n\nClient.prototype.handleServerClose = function () {\n    while (this._workQueue.hasMore()) {\n        this._workQueue.process({ id: error.SERVER_GONE });\n    }\n};\n\nClient.prototype.isRunning = function () {\n    return this._workQueue.hasMore();\n};\n\n/**\n * Send a Mysqlx.Connection.CapabilitiesGet message to the server.\n * @private\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.capabilitiesGet = function () {\n    const messageType = ClientMessages.Type.CON_CAPABILITIES_GET;\n    const protobuf = this.encodeMessage(messageType, Connection.encodeCapabilitiesGet());\n    const handler = new CapabilitiesGetHandler(this);\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Connection.CapabilitiesSet message to the server.\n * @private\n * @param {Object} properties - connection properties\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.capabilitiesSet = function (properties) {\n    const messageType = ClientMessages.Type.CON_CAPABILITIES_SET;\n    const protobuf = this.encodeMessage(messageType, Connection.encodeCapabilitiesSet(properties));\n    const handler = new OkHandler(this);\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Session.AuthenticateStart message to the server.\n * @private\n * @param {IAuthenticator} authenticator - authenticator instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.authenticate = function (authenticator) {\n    // cache the authentication plugin\n    this._authenticator = authenticator;\n\n    const messageType = ClientMessages.Type.SESS_AUTHENTICATE_START;\n    const protobuf = this.encodeMessage(messageType, Session.encodeAuthenticateStart(authenticator.getName(), authenticator.getInitialAuthData()));\n    const handler = new AuthenticationHandler(authenticator, this);\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Session.AuthenticateContinue message to the server.\n * @private\n * @param {Buffer} data - raw connection data\n * @param {AuthenticationHandler} handler - active authentication handler\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.authenticateContinue = function (data, handler) {\n    const messageType = ClientMessages.Type.SESS_AUTHENTICATE_CONTINUE;\n    const protobuf = this.encodeMessage(messageType, Session.encodeAuthenticateContinue(data));\n\n    handler.sendDirect(this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Crud.Insert message to the server.\n * @private\n * @param {module:CollectionAdd|module:TableInsert} query - the operation instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.crudInsert = function (query) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.CRUD_INSERT, Crud.encodeInsert(query));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new SqlResultHandler();\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Crud.Find message to the server.\n * @private\n * @param {Object} query - the query data\n * @param {Function} resultSetCursor\n * @param {Function} metadataCursor\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.crudFind = function (query, resultSetCursor, metadataCursor) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.CRUD_FIND, Crud.encodeFind(query));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new SqlResultHandler(resultSetCursor, metadataCursor);\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Crud.Update message to the server.\n * @private\n * @param {module:CollectionModify|module:TableUpdate} query - the operation instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.crudModify = function (query) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.CRUD_UPDATE, Crud.encodeUpdate(query));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new SqlResultHandler();\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Crud.Delete message to the server.\n * @private\n * @param {module:CollectionRemove|module:TableDelete} query - the operation instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.crudRemove = function (query) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.CRUD_DELETE, Crud.encodeDelete(query));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new SqlResultHandler();\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Sql.StmtExecute message to the server.\n * @private\n * @param {StmtExecute} query - the operation instance\n * @param {Function} resultSetCursor\n * @param {Function} metadataCursor\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.sqlStmtExecute = function (query, resultSetCursor, metadataCursor) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.SQL_STMT_EXECUTE, Sql.encodeStmtExecute(query));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new SqlResultHandler(resultSetCursor, metadataCursor);\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Prepare.Prepare message to the server.\n * @private\n * @param {Query} statement - the statement instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.prepare = function (statement) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.PREPARE_PREPARE, Prepare.encodePrepare(statement));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new OkHandler();\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Prepare.Execute message to the server.\n * @private\n * @param {Query} statement - the statement instance\n * @param {Function} resultSetCursor\n * @param {Function} metadataCursor\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.prepareExecute = function (statement, resultSetCursor, metadataCursor) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.PREPARE_EXECUTE, Prepare.encodeExecute(statement));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new SqlResultHandler(resultSetCursor, metadataCursor);\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Prepare.Deallocate message to the server.\n * @private\n * @param {Query} statement - the statement instance\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.deallocate = function (statement) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.PREPARE_DEALLOCATE, Prepare.encodeDeallocate(statement));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new OkHandler();\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Session.Close message to the server.\n * @private\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.sessionClose = function () {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.SESS_CLOSE, Session.encodeClose());\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new OkHandler();\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\n/**\n * Send a Mysqlx.Session.Reset message to the server.\n * @private\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.sessionReset = function () {\n    const reset = (options) => {\n        let protobuf;\n\n        try {\n            protobuf = this.encodeMessage(ClientMessages.Type.SESS_RESET, Session.encodeReset(options));\n        } catch (err) {\n            return Promise.reject(err);\n        }\n\n        const handler = new OkHandler();\n\n        return handler.sendMessage(this._workQueue, this._stream, protobuf);\n    };\n\n    if (this._requiresAuthenticationAfterReset === REQUIRES_REAUTH.NO) {\n        return reset({ keepOpen: true });\n    }\n\n    if (this._requiresAuthenticationAfterReset === REQUIRES_REAUTH.YES) {\n        return reset({ keepOpen: false }).then(() => this.authenticate(this._authenticator));\n    }\n\n    const expectations = [{\n        condition: condition.ACTION.EXPECT_OP_SET,\n        key: condition.TYPE.EXPECT_FIELD_EXIST,\n        value: '6.1' // checks if SESS_RESET message supports the \"keep_open\" property\n    }];\n\n    return this.expectOpen(expectations)\n        .then(() => reset({ keepOpen: true }))\n        .then(() => this.expectClose())\n        .then(() => {\n            this._requiresAuthenticationAfterReset = REQUIRES_REAUTH.NO;\n        })\n        .catch(err => {\n            if (err.info && err.info.code !== errors.ER_X_EXPECT_FIELD_EXISTS_FAILED) {\n                throw err;\n            }\n\n            this._requiresAuthenticationAfterReset = REQUIRES_REAUTH.YES;\n\n            return this.sessionReset();\n        });\n};\n\n/**\n * Send a Mysqlx.Connection.Close message to the server.\n * @private\n * @returns {Promise<Object>} A promise that resolves to an object describing the operation status.\n */\nClient.prototype.connectionClose = function () {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.CON_CLOSE, Connection.encodeClose());\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new OkHandler();\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\nClient.prototype.expectClose = function () {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.EXPECT_OPEN, Expect.encodeClose());\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new OkHandler(this);\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n\nClient.prototype.expectOpen = function (expectations) {\n    let protobuf;\n\n    try {\n        protobuf = this.encodeMessage(ClientMessages.Type.EXPECT_OPEN, Expect.encodeOpen(expectations));\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    const handler = new OkHandler(this);\n\n    return handler.sendMessage(this._workQueue, this._stream, protobuf);\n};\n"]},"metadata":{},"sourceType":"script"}