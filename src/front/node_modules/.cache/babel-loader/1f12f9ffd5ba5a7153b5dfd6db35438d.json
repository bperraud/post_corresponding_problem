{"ast":null,"code":"/*\n * Copyright (c) 2020, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst LimitExprStub = require('../../../Stubs/mysqlx_crud_pb').LimitExpr;\n\nconst expr = require('../../Messages/Expr/Expr');\n\nconst wraps = require('../../Traits/Wraps');\n/**\n * @private\n * @alias module:adapters.Mysqlx.Crud.LimitExpr\n * @param {proto.Mysqlx.Crud.LimitExpr} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Crud.LimitExpr}\n */\n\n\nfunction LimitExpr(proto) {\n  return Object.assign({}, wraps(proto), {\n    /**\n     * Serialize to JSON using a protobuf-like convention.\n     * @function\n     * @name module:adapters.Mysqlx.Crud.LimitExpr#toJSON\n     * @returns {Object} The JSON representation\n     */\n    toJSON() {\n      // Mysqlx.Crud.Limit and Mysqlx.Crud.LimitExpr are exclusive which\n      // means one of them will be undefined.\n      if (typeof proto === 'undefined') {\n        // In that case, we want the field to be ignored in the parent object.\n        return;\n      }\n\n      return {\n        row_count: expr(proto.getRowCount()).toJSON(),\n        offset: expr(proto.getOffset()).toJSON()\n      };\n    }\n\n  });\n}\n/**\n * Creates a wrapper of a generic Mysqlx.Crud.LimitExpr instance given a count (and offset).\n * @param {number} count\n * @param {number} [offset]\n * @param {Object} [options] - extended options\n * @returns {module:adapters.Mysqlx.Crud.LimitExpr}\n */\n\n\nLimitExpr.create = function (count, offset, options) {\n  // since offset is optional, we need to check if the options object is the second argument\n  options = typeof offset === 'object' ? offset : options;\n  options = Object.assign({}, {\n    isPlaceholder: false,\n    position: 0\n  }, options);\n  const position = options.position; // position is no longer need in the options object\n\n  delete options.position; // If the count is not defined there's nothing to do.\n  // We can't wrap an empty Mysqlx.Crud.Limit stub instance because it\n  // contains a default value of an empty Mysqlx.Expr.Expr for row_count,\n  // which in turn, gets assigned a default type creating some\n  // inconsistencies.\n\n  if (typeof count === 'undefined') {\n    return LimitExpr();\n  }\n\n  const proto = new LimitExprStub();\n\n  if (!options.toPrepare) {\n    // Execute stage\n    proto.setRowCount(expr.create(count, options).valueOf());\n\n    if (typeof offset !== 'undefined' && typeof offset !== 'object') {\n      proto.setOffset(expr.create(offset, options).valueOf());\n    }\n\n    return LimitExpr(proto);\n  } // In the Prepare stage, the message should contain proper placeholder expressions\n  // i.e. encoding the position of each future variable assigment\n\n\n  options.isPlaceholder = true; // count should be always defined at this point\n\n  proto.setRowCount(expr.create(position, options).valueOf()); // if an offset is provided, it must be a number, and the options\n  // object can be provided as the second argument\n\n  if (typeof offset !== 'object') {\n    proto.setOffset(expr.create(position + 1, options).valueOf());\n  }\n\n  return LimitExpr(proto);\n};\n\nmodule.exports = LimitExpr;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/Protocol/Wrappers/Messages/Crud/LimitExpr.js"],"names":["LimitExprStub","require","LimitExpr","expr","wraps","proto","Object","assign","toJSON","row_count","getRowCount","offset","getOffset","create","count","options","isPlaceholder","position","toPrepare","setRowCount","valueOf","setOffset","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,+BAAD,CAAP,CAAyCC,SAA/D;;AACA,MAAMC,IAAI,GAAGF,OAAO,CAAC,0BAAD,CAApB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,oBAAD,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,SAAT,CAAoBG,KAApB,EAA2B;AACvB,SAAOC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,KAAK,CAACC,KAAD,CAAvB,EAAgC;AACnC;AACR;AACA;AACA;AACA;AACA;AACQG,IAAAA,MAAM,GAAI;AACN;AACA;AACA,UAAI,OAAOH,KAAP,KAAiB,WAArB,EAAkC;AAC9B;AACA;AACH;;AAED,aAAO;AACHI,QAAAA,SAAS,EAAEN,IAAI,CAACE,KAAK,CAACK,WAAN,EAAD,CAAJ,CAA0BF,MAA1B,EADR;AAEHG,QAAAA,MAAM,EAAER,IAAI,CAACE,KAAK,CAACO,SAAN,EAAD,CAAJ,CAAwBJ,MAAxB;AAFL,OAAP;AAIH;;AAnBkC,GAAhC,CAAP;AAqBH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,SAAS,CAACW,MAAV,GAAmB,UAAUC,KAAV,EAAiBH,MAAjB,EAAyBI,OAAzB,EAAkC;AACjD;AACAA,EAAAA,OAAO,GAAG,OAAOJ,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCI,OAAhD;AACAA,EAAAA,OAAO,GAAGT,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB;AAAES,IAAAA,aAAa,EAAE,KAAjB;AAAwBC,IAAAA,QAAQ,EAAE;AAAlC,GAAlB,EAAyDF,OAAzD,CAAV;AAEA,QAAME,QAAQ,GAAGF,OAAO,CAACE,QAAzB,CALiD,CAOjD;;AACA,SAAOF,OAAO,CAACE,QAAf,CARiD,CAUjD;AACA;AACA;AACA;AACA;;AACA,MAAI,OAAOH,KAAP,KAAiB,WAArB,EAAkC;AAC9B,WAAOZ,SAAS,EAAhB;AACH;;AAED,QAAMG,KAAK,GAAG,IAAIL,aAAJ,EAAd;;AAEA,MAAI,CAACe,OAAO,CAACG,SAAb,EAAwB;AAAE;AACtBb,IAAAA,KAAK,CAACc,WAAN,CAAkBhB,IAAI,CAACU,MAAL,CAAYC,KAAZ,EAAmBC,OAAnB,EAA4BK,OAA5B,EAAlB;;AAEA,QAAI,OAAOT,MAAP,KAAkB,WAAlB,IAAiC,OAAOA,MAAP,KAAkB,QAAvD,EAAiE;AAC7DN,MAAAA,KAAK,CAACgB,SAAN,CAAgBlB,IAAI,CAACU,MAAL,CAAYF,MAAZ,EAAoBI,OAApB,EAA6BK,OAA7B,EAAhB;AACH;;AAED,WAAOlB,SAAS,CAACG,KAAD,CAAhB;AACH,GA7BgD,CA+BjD;AACA;;;AACAU,EAAAA,OAAO,CAACC,aAAR,GAAwB,IAAxB,CAjCiD,CAmCjD;;AACAX,EAAAA,KAAK,CAACc,WAAN,CAAkBhB,IAAI,CAACU,MAAL,CAAYI,QAAZ,EAAsBF,OAAtB,EAA+BK,OAA/B,EAAlB,EApCiD,CAsCjD;AACA;;AACA,MAAI,OAAOT,MAAP,KAAkB,QAAtB,EAAgC;AAC5BN,IAAAA,KAAK,CAACgB,SAAN,CAAgBlB,IAAI,CAACU,MAAL,CAAYI,QAAQ,GAAG,CAAvB,EAA0BF,OAA1B,EAAmCK,OAAnC,EAAhB;AACH;;AAED,SAAOlB,SAAS,CAACG,KAAD,CAAhB;AACH,CA7CD;;AA+CAiB,MAAM,CAACC,OAAP,GAAiBrB,SAAjB","sourcesContent":["/*\n * Copyright (c) 2020, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst LimitExprStub = require('../../../Stubs/mysqlx_crud_pb').LimitExpr;\nconst expr = require('../../Messages/Expr/Expr');\nconst wraps = require('../../Traits/Wraps');\n\n/**\n * @private\n * @alias module:adapters.Mysqlx.Crud.LimitExpr\n * @param {proto.Mysqlx.Crud.LimitExpr} proto - protobuf stub\n * @returns {module:adapters.Mysqlx.Crud.LimitExpr}\n */\nfunction LimitExpr (proto) {\n    return Object.assign({}, wraps(proto), {\n        /**\n         * Serialize to JSON using a protobuf-like convention.\n         * @function\n         * @name module:adapters.Mysqlx.Crud.LimitExpr#toJSON\n         * @returns {Object} The JSON representation\n         */\n        toJSON () {\n            // Mysqlx.Crud.Limit and Mysqlx.Crud.LimitExpr are exclusive which\n            // means one of them will be undefined.\n            if (typeof proto === 'undefined') {\n                // In that case, we want the field to be ignored in the parent object.\n                return;\n            }\n\n            return {\n                row_count: expr(proto.getRowCount()).toJSON(),\n                offset: expr(proto.getOffset()).toJSON()\n            };\n        }\n    });\n}\n\n/**\n * Creates a wrapper of a generic Mysqlx.Crud.LimitExpr instance given a count (and offset).\n * @param {number} count\n * @param {number} [offset]\n * @param {Object} [options] - extended options\n * @returns {module:adapters.Mysqlx.Crud.LimitExpr}\n */\nLimitExpr.create = function (count, offset, options) {\n    // since offset is optional, we need to check if the options object is the second argument\n    options = typeof offset === 'object' ? offset : options;\n    options = Object.assign({}, { isPlaceholder: false, position: 0 }, options);\n\n    const position = options.position;\n\n    // position is no longer need in the options object\n    delete options.position;\n\n    // If the count is not defined there's nothing to do.\n    // We can't wrap an empty Mysqlx.Crud.Limit stub instance because it\n    // contains a default value of an empty Mysqlx.Expr.Expr for row_count,\n    // which in turn, gets assigned a default type creating some\n    // inconsistencies.\n    if (typeof count === 'undefined') {\n        return LimitExpr();\n    }\n\n    const proto = new LimitExprStub();\n\n    if (!options.toPrepare) { // Execute stage\n        proto.setRowCount(expr.create(count, options).valueOf());\n\n        if (typeof offset !== 'undefined' && typeof offset !== 'object') {\n            proto.setOffset(expr.create(offset, options).valueOf());\n        }\n\n        return LimitExpr(proto);\n    }\n\n    // In the Prepare stage, the message should contain proper placeholder expressions\n    // i.e. encoding the position of each future variable assigment\n    options.isPlaceholder = true;\n\n    // count should be always defined at this point\n    proto.setRowCount(expr.create(position, options).valueOf());\n\n    // if an offset is provided, it must be a number, and the options\n    // object can be provided as the second argument\n    if (typeof offset !== 'object') {\n        proto.setOffset(expr.create(position + 1, options).valueOf());\n    }\n\n    return LimitExpr(proto);\n};\n\nmodule.exports = LimitExpr;\n"]},"metadata":{},"sourceType":"script"}