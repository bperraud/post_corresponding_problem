{"ast":null,"code":"/*\n * Copyright (c) 2017, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst errors = require('../../../constants/errors');\n\nconst parsePlainAddress = require('./parsePlainAddress');\n\nconst parsePriorityAddress = require('./parsePriorityAddress');\n\nmodule.exports = parse;\n/**\n * Address object.\n * @private\n * @typedef {Object} Address\n * @prop {string} host - address host\n * @prop {number} [port] - address port\n */\n\n/**\n * Parse a list of failover addresses.\n * @private\n * @param {string} input - formatted string with a list of addresses (check examples)\n * @throws {Error} When explicit priorities are not provided for all failover addresses.\n * @throws {Error} When failover address priorities are out of bounds.\n * @returns {Address[]} The list of objects containing the details of each address.\n * @example\n * // list of addresses without priority\n * const addressList = '[::1:33060, localhost:33060, 127.0.0.1:33060]'\n * // list of addresses with priority\n * const priorityAddressList = '[(address=[::1], priority=100), (adddress=localhost, priority=99), (address=127.0.0.1, priority=98)]'\n */\n\nfunction parse(input) {\n  const addressListMatch = input.trim().match(/^\\[(.+)\\]$/) || [];\n  const expressions = addressListMatch[1] || '';\n  let addresses = parseAddressListWithPriority(expressions);\n\n  if (addresses && addresses.length) {\n    return addresses;\n  }\n\n  addresses = parseAddressListWithoutPriority(expressions);\n\n  if (addresses && addresses.length) {\n    return addresses;\n  }\n\n  return [parsePlainAddress(input)];\n}\n/**\n * Parse an unordered list of failover addresses with an explicit priority.\n * @private\n * @param {string} input - formatted string with a list of addresses (check examples)\n * @throws {Error} When explicit priorities are not provided for all failover addresses.\n * @returns {Address[]} Ordered list of addresses.\n * @example\n * const addressList = '[(address=[::1], priority=100), (address=localhost, priority=99), (address=127.0.0.1, priority=98)]'\n */\n\n\nfunction parseAddressListWithPriority(input) {\n  const items = input.trim().match(/[^ (),]+/g) || [];\n  const tuples = input.trim().match(/\\(([^)]+)\\)/g) || [];\n\n  if (tuples.length && items.length && items.length % 2 !== 0) {\n    throw new Error(errors.MESSAGES.ER_DEVAPI_MIXED_CONNECTION_ENDPOINT_PRIORITY);\n  }\n\n  return tuples.reduce((result, tuple) => result.concat(parsePriorityAddress(tuple)), []);\n}\n/**\n * Parse a an ordered list of failover addresses without an explicit priority.\n * @private\n * @param {string} input - formatted string with a list of addresses (check examples)\n * @throws {Error} When the host is not valid.\n * @returns {Address[]} List of addresses.\n * @example\n * const addressList = '[[::1]:33060, localhost:33060, 127.0.0.1:33060]'\n */\n\n\nfunction parseAddressListWithoutPriority(input) {\n  const singles = input.trim().match(/[^,]+/g) || [];\n  return singles.length > 1 ? singles.map(parsePlainAddress) : [];\n}","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/DevAPI/Util/URIParser/parseAddressList.js"],"names":["errors","require","parsePlainAddress","parsePriorityAddress","module","exports","parse","input","addressListMatch","trim","match","expressions","addresses","parseAddressListWithPriority","length","parseAddressListWithoutPriority","items","tuples","Error","MESSAGES","ER_DEVAPI_MIXED_CONNECTION_ENDPOINT_PRIORITY","reduce","result","tuple","concat","singles","map"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,2BAAD,CAAtB;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,qBAAD,CAAjC;;AACA,MAAME,oBAAoB,GAAGF,OAAO,CAAC,wBAAD,CAApC;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,KAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,KAAT,CAAgBC,KAAhB,EAAuB;AACnB,QAAMC,gBAAgB,GAAGD,KAAK,CAACE,IAAN,GAAaC,KAAb,CAAmB,YAAnB,KAAoC,EAA7D;AACA,QAAMC,WAAW,GAAGH,gBAAgB,CAAC,CAAD,CAAhB,IAAuB,EAA3C;AAEA,MAAII,SAAS,GAAGC,4BAA4B,CAACF,WAAD,CAA5C;;AAEA,MAAIC,SAAS,IAAIA,SAAS,CAACE,MAA3B,EAAmC;AAC/B,WAAOF,SAAP;AACH;;AAEDA,EAAAA,SAAS,GAAGG,+BAA+B,CAACJ,WAAD,CAA3C;;AAEA,MAAIC,SAAS,IAAIA,SAAS,CAACE,MAA3B,EAAmC;AAC/B,WAAOF,SAAP;AACH;;AAED,SAAO,CAACV,iBAAiB,CAACK,KAAD,CAAlB,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,4BAAT,CAAuCN,KAAvC,EAA8C;AAC1C,QAAMS,KAAK,GAAGT,KAAK,CAACE,IAAN,GAAaC,KAAb,CAAmB,WAAnB,KAAmC,EAAjD;AACA,QAAMO,MAAM,GAAGV,KAAK,CAACE,IAAN,GAAaC,KAAb,CAAmB,cAAnB,KAAsC,EAArD;;AAEA,MAAIO,MAAM,CAACH,MAAP,IAAiBE,KAAK,CAACF,MAAvB,IAAiCE,KAAK,CAACF,MAAN,GAAe,CAAf,KAAqB,CAA1D,EAA6D;AACzD,UAAM,IAAII,KAAJ,CAAUlB,MAAM,CAACmB,QAAP,CAAgBC,4CAA1B,CAAN;AACH;;AAED,SAAOH,MAAM,CAACI,MAAP,CAAc,CAACC,MAAD,EAASC,KAAT,KAAmBD,MAAM,CAACE,MAAP,CAAcrB,oBAAoB,CAACoB,KAAD,CAAlC,CAAjC,EAA6E,EAA7E,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASR,+BAAT,CAA0CR,KAA1C,EAAiD;AAC7C,QAAMkB,OAAO,GAAGlB,KAAK,CAACE,IAAN,GAAaC,KAAb,CAAmB,QAAnB,KAAgC,EAAhD;AAEA,SAAOe,OAAO,CAACX,MAAR,GAAiB,CAAjB,GAAqBW,OAAO,CAACC,GAAR,CAAYxB,iBAAZ,CAArB,GAAsD,EAA7D;AACH","sourcesContent":["/*\n * Copyright (c) 2017, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst errors = require('../../../constants/errors');\nconst parsePlainAddress = require('./parsePlainAddress');\nconst parsePriorityAddress = require('./parsePriorityAddress');\n\nmodule.exports = parse;\n\n/**\n * Address object.\n * @private\n * @typedef {Object} Address\n * @prop {string} host - address host\n * @prop {number} [port] - address port\n */\n\n/**\n * Parse a list of failover addresses.\n * @private\n * @param {string} input - formatted string with a list of addresses (check examples)\n * @throws {Error} When explicit priorities are not provided for all failover addresses.\n * @throws {Error} When failover address priorities are out of bounds.\n * @returns {Address[]} The list of objects containing the details of each address.\n * @example\n * // list of addresses without priority\n * const addressList = '[::1:33060, localhost:33060, 127.0.0.1:33060]'\n * // list of addresses with priority\n * const priorityAddressList = '[(address=[::1], priority=100), (adddress=localhost, priority=99), (address=127.0.0.1, priority=98)]'\n */\nfunction parse (input) {\n    const addressListMatch = input.trim().match(/^\\[(.+)\\]$/) || [];\n    const expressions = addressListMatch[1] || '';\n\n    let addresses = parseAddressListWithPriority(expressions);\n\n    if (addresses && addresses.length) {\n        return addresses;\n    }\n\n    addresses = parseAddressListWithoutPriority(expressions);\n\n    if (addresses && addresses.length) {\n        return addresses;\n    }\n\n    return [parsePlainAddress(input)];\n}\n\n/**\n * Parse an unordered list of failover addresses with an explicit priority.\n * @private\n * @param {string} input - formatted string with a list of addresses (check examples)\n * @throws {Error} When explicit priorities are not provided for all failover addresses.\n * @returns {Address[]} Ordered list of addresses.\n * @example\n * const addressList = '[(address=[::1], priority=100), (address=localhost, priority=99), (address=127.0.0.1, priority=98)]'\n */\nfunction parseAddressListWithPriority (input) {\n    const items = input.trim().match(/[^ (),]+/g) || [];\n    const tuples = input.trim().match(/\\(([^)]+)\\)/g) || [];\n\n    if (tuples.length && items.length && items.length % 2 !== 0) {\n        throw new Error(errors.MESSAGES.ER_DEVAPI_MIXED_CONNECTION_ENDPOINT_PRIORITY);\n    }\n\n    return tuples.reduce((result, tuple) => result.concat(parsePriorityAddress(tuple)), []);\n}\n\n/**\n * Parse a an ordered list of failover addresses without an explicit priority.\n * @private\n * @param {string} input - formatted string with a list of addresses (check examples)\n * @throws {Error} When the host is not valid.\n * @returns {Address[]} List of addresses.\n * @example\n * const addressList = '[[::1]:33060, localhost:33060, 127.0.0.1:33060]'\n */\nfunction parseAddressListWithoutPriority (input) {\n    const singles = input.trim().match(/[^,]+/g) || [];\n\n    return singles.length > 1 ? singles.map(parsePlainAddress) : [];\n}\n"]},"metadata":{},"sourceType":"script"}