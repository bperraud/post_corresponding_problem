{"ast":null,"code":"/*\n * Copyright (c) 2019, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst errors = require('../constants/errors');\n/**\n * Enum the current statement lifecycle stage.\n * @readonly\n * @private\n * @name STATEMENT_STATUS\n * @enum {number}\n */\n\n\nconst STATEMENT_STATUS = {\n  TO_START: 1,\n  TO_PREPARE: 2,\n  TO_EXECUTE: 3,\n  TO_REPREPARE: 4,\n  TO_RESTART: 5,\n  TO_SKIP: 6\n};\n/**\n * Preparing mixin.\n * @mixin\n * @private\n * @alias Preparing\n * @param {Object} state\n * @returns {Preparing}\n */\n\nfunction Preparing(state) {\n  state = Object.assign({\n    statementId: 0,\n    stage: STATEMENT_STATUS.TO_START\n  }, state);\n  return {\n    /**\n     * Acquire a statement context.\n     * @function\n     * @private\n     * @name Preparing#allocate\n     * @return {Preparing} The statement instance.\n     */\n    allocate() {\n      const statements = state.connection.getPreparedStatements();\n      let id = 0;\n\n      while (statements[id]) {\n        ++id;\n      }\n\n      statements[id] = true;\n      state.statementId = id + 1;\n      return this;\n    },\n\n    /**\n     * Release a previously prepared statement.\n     * @function\n     * @private\n     * @name Preparing#deallocate\n     * @return {Preparing} The statement instance.\n     */\n    deallocate() {\n      return state.connection.getClient().deallocate(this).then(() => {\n        if (state.stage === STATEMENT_STATUS.TO_RESTART) {\n          state.stage = STATEMENT_STATUS.TO_START;\n        } else if (state.stage === STATEMENT_STATUS.TO_REPREPARE) {\n          state.stage = STATEMENT_STATUS.TO_PREPARE;\n        }\n\n        state.connection.removePreparedStatement(state.statementId);\n        return this;\n      });\n    },\n\n    /**\n     * Manage statement execution (prepared or plain) given the existing context.\n     * @function\n     * @private\n     * @name Preparing#execute\n     * @param {Function} fn - fallback function to execute when the server does not support prepared statements.\n     * @param {Function} [dataCursor] - callback function used to process result set data\n     * @param {Function} [metadataCursor] - callback function used to process result set metadata\n     * @returns {Promise.<Object>}\n     */\n    execute(fn, dataCursor, metadataCursor) {\n      if (state.stage === STATEMENT_STATUS.TO_RESTART || state.stage === STATEMENT_STATUS.TO_REPREPARE) {\n        return this.deallocate().then(() => this.execute(fn, dataCursor, metadataCursor));\n      }\n\n      if (state.stage === STATEMENT_STATUS.TO_PREPARE) {\n        return this.prepare().then(() => this.execute(fn, dataCursor, metadataCursor)).catch(err => this.handlePrepareError(err, fn));\n      }\n\n      if (state.stage === STATEMENT_STATUS.TO_EXECUTE) {\n        return this.executePrepared(dataCursor, metadataCursor);\n      }\n\n      return this.executePlain(fn);\n    },\n\n    /**\n     * Execute a plain statement wrapped inside an operation factory function.\n     * @function\n     * @private\n     * @name Preparing#executePlain\n     * @param {Function} fn - fallback function\n     * @returns {Promise.<Object>}\n     */\n    executePlain(fn) {\n      return fn().then(res => {\n        if (state.stage !== STATEMENT_STATUS.TO_SKIP) {\n          state.stage = STATEMENT_STATUS.TO_PREPARE;\n        }\n\n        return res;\n      });\n    },\n\n    /**\n     * Execute a previously prepared statement.\n     * @function\n     * @private\n     * @name Preparing#executePrepared\n     * @param {module:CollectionFind~documentCursor|module:TableSelect~rowCursor} [rowcb]\n     * @param {module:TableSelect~metadataCursor} [metacb]\n     * @return {Promise.<Object>}\n     */\n    executePrepared(rowcb, metacb) {\n      return state.connection.getClient().prepareExecute(this, rowcb, metacb);\n    },\n\n    /**\n     * Force statement to be re-prepared in the next execution.\n     * @function\n     * @private\n     * @name Preparing#forceReprepare\n     * @return {Preparing}\n     */\n    forceReprepare() {\n      if (state.stage === STATEMENT_STATUS.TO_EXECUTE) {\n        state.stage = STATEMENT_STATUS.TO_REPREPARE;\n      }\n\n      return this;\n    },\n\n    /**\n     * Force statement lifecycle to be restarted in the next execution.\n     * @function\n     * @private\n     * @name Preparing#forceRestart\n     * @return {Preparing}\n     */\n    forceRestart() {\n      if (state.stage === STATEMENT_STATUS.TO_EXECUTE) {\n        state.stage = STATEMENT_STATUS.TO_RESTART;\n      } else {\n        state.stage = STATEMENT_STATUS.TO_START;\n      }\n\n      return this;\n    },\n\n    /**\n     * Get the current statement lifecycle stage.\n     * @function\n     * @private\n     * @name Preparing#getStage\n     * @returns {}\n     */\n    getStage() {\n      return state.stage;\n    },\n\n    /**\n     * Retrieve the statement id.\n     * @function\n     * @private\n     * @name Preparing#getStatementId\n     * @returns {Number} The statement id.\n     */\n    getStatementId() {\n      return state.statementId;\n    },\n\n    /**\n     * Execute plain statement if the server does not support prepared statements.\n     * @function\n     * @private\n     * @name Preparing#handlePrepareError\n     * @param {Error} err - error to evaluate\n     * @param {Function} fn - fallback function to execute when the server does not support prepared statements.\n     */\n    handlePrepareError(err, fn) {\n      // Non-fatal errors include errors when max_prepared_stmt_count\n      // has been exceeded, or when the server does not support\n      // prepared statements and reports an unexpected message.\n      const nonFatalErrors = [errors.ER_UNKNOWN_COM_ERROR, errors.ER_MAX_PREPARED_STMT_COUNT_REACHED];\n\n      if (!err.info || nonFatalErrors.indexOf(err.info.code) === -1) {\n        // Needs to return a failing Promise\n        return Promise.reject(err);\n      }\n\n      state.connection.disablePreparedStatements();\n      state.stage = STATEMENT_STATUS.TO_SKIP;\n      return fn();\n    },\n\n    /**\n     * Prepare a statement in the server.\n     * @function\n     * @private\n     * @name Preparing#prepare\n     * @return {Preparing} The statement instance.\n     */\n    prepare() {\n      this.allocate();\n      return state.connection.getClient().prepare(this).then(() => {\n        state.stage = STATEMENT_STATUS.TO_EXECUTE;\n        return this;\n      });\n    }\n\n  };\n}\n\nPreparing.Stages = STATEMENT_STATUS;\nmodule.exports = Preparing;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/DevAPI/Preparing.js"],"names":["errors","require","STATEMENT_STATUS","TO_START","TO_PREPARE","TO_EXECUTE","TO_REPREPARE","TO_RESTART","TO_SKIP","Preparing","state","Object","assign","statementId","stage","allocate","statements","connection","getPreparedStatements","id","deallocate","getClient","then","removePreparedStatement","execute","fn","dataCursor","metadataCursor","prepare","catch","err","handlePrepareError","executePrepared","executePlain","res","rowcb","metacb","prepareExecute","forceReprepare","forceRestart","getStage","getStatementId","nonFatalErrors","ER_UNKNOWN_COM_ERROR","ER_MAX_PREPARED_STMT_COUNT_REACHED","info","indexOf","code","Promise","reject","disablePreparedStatements","Stages","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst errors = require('../constants/errors');\n\n/**\n * Enum the current statement lifecycle stage.\n * @readonly\n * @private\n * @name STATEMENT_STATUS\n * @enum {number}\n */\nconst STATEMENT_STATUS = {\n    TO_START: 1,\n    TO_PREPARE: 2,\n    TO_EXECUTE: 3,\n    TO_REPREPARE: 4,\n    TO_RESTART: 5,\n    TO_SKIP: 6\n};\n\n/**\n * Preparing mixin.\n * @mixin\n * @private\n * @alias Preparing\n * @param {Object} state\n * @returns {Preparing}\n */\nfunction Preparing (state) {\n    state = Object.assign({ statementId: 0, stage: STATEMENT_STATUS.TO_START }, state);\n\n    return {\n        /**\n         * Acquire a statement context.\n         * @function\n         * @private\n         * @name Preparing#allocate\n         * @return {Preparing} The statement instance.\n         */\n        allocate () {\n            const statements = state.connection.getPreparedStatements();\n            let id = 0;\n\n            while (statements[id]) {\n                ++id;\n            }\n\n            statements[id] = true;\n            state.statementId = id + 1;\n\n            return this;\n        },\n\n        /**\n         * Release a previously prepared statement.\n         * @function\n         * @private\n         * @name Preparing#deallocate\n         * @return {Preparing} The statement instance.\n         */\n        deallocate () {\n            return state.connection.getClient().deallocate(this)\n                .then(() => {\n                    if (state.stage === STATEMENT_STATUS.TO_RESTART) {\n                        state.stage = STATEMENT_STATUS.TO_START;\n                    } else if (state.stage === STATEMENT_STATUS.TO_REPREPARE) {\n                        state.stage = STATEMENT_STATUS.TO_PREPARE;\n                    }\n\n                    state.connection.removePreparedStatement(state.statementId);\n\n                    return this;\n                });\n        },\n\n        /**\n         * Manage statement execution (prepared or plain) given the existing context.\n         * @function\n         * @private\n         * @name Preparing#execute\n         * @param {Function} fn - fallback function to execute when the server does not support prepared statements.\n         * @param {Function} [dataCursor] - callback function used to process result set data\n         * @param {Function} [metadataCursor] - callback function used to process result set metadata\n         * @returns {Promise.<Object>}\n         */\n        execute (fn, dataCursor, metadataCursor) {\n            if (state.stage === STATEMENT_STATUS.TO_RESTART || state.stage === STATEMENT_STATUS.TO_REPREPARE) {\n                return this.deallocate().then(() => this.execute(fn, dataCursor, metadataCursor));\n            }\n\n            if (state.stage === STATEMENT_STATUS.TO_PREPARE) {\n                return this.prepare().then(() => this.execute(fn, dataCursor, metadataCursor)).catch(err => this.handlePrepareError(err, fn));\n            }\n\n            if (state.stage === STATEMENT_STATUS.TO_EXECUTE) {\n                return this.executePrepared(dataCursor, metadataCursor);\n            }\n\n            return this.executePlain(fn);\n        },\n\n        /**\n         * Execute a plain statement wrapped inside an operation factory function.\n         * @function\n         * @private\n         * @name Preparing#executePlain\n         * @param {Function} fn - fallback function\n         * @returns {Promise.<Object>}\n         */\n        executePlain (fn) {\n            return fn()\n                .then(res => {\n                    if (state.stage !== STATEMENT_STATUS.TO_SKIP) {\n                        state.stage = STATEMENT_STATUS.TO_PREPARE;\n                    }\n\n                    return res;\n                });\n        },\n\n        /**\n         * Execute a previously prepared statement.\n         * @function\n         * @private\n         * @name Preparing#executePrepared\n         * @param {module:CollectionFind~documentCursor|module:TableSelect~rowCursor} [rowcb]\n         * @param {module:TableSelect~metadataCursor} [metacb]\n         * @return {Promise.<Object>}\n         */\n        executePrepared (rowcb, metacb) {\n            return state.connection.getClient().prepareExecute(this, rowcb, metacb);\n        },\n\n        /**\n         * Force statement to be re-prepared in the next execution.\n         * @function\n         * @private\n         * @name Preparing#forceReprepare\n         * @return {Preparing}\n         */\n        forceReprepare () {\n            if (state.stage === STATEMENT_STATUS.TO_EXECUTE) {\n                state.stage = STATEMENT_STATUS.TO_REPREPARE;\n            }\n\n            return this;\n        },\n\n        /**\n         * Force statement lifecycle to be restarted in the next execution.\n         * @function\n         * @private\n         * @name Preparing#forceRestart\n         * @return {Preparing}\n         */\n        forceRestart () {\n            if (state.stage === STATEMENT_STATUS.TO_EXECUTE) {\n                state.stage = STATEMENT_STATUS.TO_RESTART;\n            } else {\n                state.stage = STATEMENT_STATUS.TO_START;\n            }\n\n            return this;\n        },\n\n        /**\n         * Get the current statement lifecycle stage.\n         * @function\n         * @private\n         * @name Preparing#getStage\n         * @returns {}\n         */\n        getStage () {\n            return state.stage;\n        },\n\n        /**\n         * Retrieve the statement id.\n         * @function\n         * @private\n         * @name Preparing#getStatementId\n         * @returns {Number} The statement id.\n         */\n        getStatementId () {\n            return state.statementId;\n        },\n\n        /**\n         * Execute plain statement if the server does not support prepared statements.\n         * @function\n         * @private\n         * @name Preparing#handlePrepareError\n         * @param {Error} err - error to evaluate\n         * @param {Function} fn - fallback function to execute when the server does not support prepared statements.\n         */\n        handlePrepareError (err, fn) {\n            // Non-fatal errors include errors when max_prepared_stmt_count\n            // has been exceeded, or when the server does not support\n            // prepared statements and reports an unexpected message.\n            const nonFatalErrors = [errors.ER_UNKNOWN_COM_ERROR, errors.ER_MAX_PREPARED_STMT_COUNT_REACHED];\n\n            if (!err.info || nonFatalErrors.indexOf(err.info.code) === -1) {\n                // Needs to return a failing Promise\n                return Promise.reject(err);\n            }\n\n            state.connection.disablePreparedStatements();\n            state.stage = STATEMENT_STATUS.TO_SKIP;\n\n            return fn();\n        },\n\n        /**\n         * Prepare a statement in the server.\n         * @function\n         * @private\n         * @name Preparing#prepare\n         * @return {Preparing} The statement instance.\n         */\n        prepare () {\n            this.allocate();\n\n            return state.connection.getClient().prepare(this)\n                .then(() => {\n                    state.stage = STATEMENT_STATUS.TO_EXECUTE;\n\n                    return this;\n                });\n        }\n    };\n}\n\nPreparing.Stages = STATEMENT_STATUS;\n\nmodule.exports = Preparing;\n"]},"metadata":{},"sourceType":"script"}