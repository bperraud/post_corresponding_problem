{"ast":null,"code":"/*\n * Copyright (c) 2015, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst databaseObject = require('./DatabaseObject');\n\nconst errors = require('../constants/errors');\n\nconst escapeQuotes = require('./Util/escapeQuotes');\n\nconst logger = require('../logger');\n\nconst parseFlexibleParamList = require('./Util/parseFlexibleParamList');\n\nconst sqlExecute = require('./SqlExecute');\n\nconst tableDelete = require('./TableDelete');\n\nconst tableInsert = require('./TableInsert');\n\nconst tableSelect = require('./TableSelect');\n\nconst tableUpdate = require('./TableUpdate');\n\nconst warnings = require('../constants/warnings');\n/**\n * Table factory.\n * @module Table\n * @mixes DatabaseObject\n */\n\n\nconst log = logger('api:table');\n/**\n * @private\n * @alias module:Table\n * @param {Connection} connection - database connection context\n * @param {module:Schema} schema - schema to bind\n * @param {string} name - table name\n * @returns {module:Table}\n */\n\nfunction Table(connection, schema, name) {\n  const state = Object.assign({}, {\n    name,\n    schema\n  });\n  return Object.assign({}, databaseObject(connection), {\n    /**\n     * Retrieve the total number of rows in the table.\n     * @function\n     * @name module:Table#count\n     * @returns {Promise.<number>}\n     */\n    count: function () {\n      const schema = Table.escapeIdentifier(this.getSchema().getName());\n      const table = Table.escapeIdentifier(this.getName());\n      let count = 0;\n\n      const callback = row => {\n        count = row[0];\n      };\n\n      return sqlExecute(connection, `SELECT COUNT(*) FROM ${schema}.${table}`).execute(callback).then(() => count);\n    },\n\n    /**\n     * Create operation to delete rows from a table.\n     * @function\n     * @name module:Table#delete\n     * @param {SearchConditionStr} [expr] - filtering criteria\n     * @example\n     * // delete all rows from a table\n     * table.delete('true')\n     *\n     * // delete rows that match a given criteria\n     * table.delete('`name` == \"foobar\"')\n     * @returns {module:TableDelete} The operation instance.\n     */\n    delete(expr) {\n      if (typeof expr !== 'undefined') {\n        log.warning('delete', warnings.MESSAGES.WARN_DEPRECATED_TABLE_DELETE_EXPR_ARGUMENT, {\n          type: warnings.TYPES.DEPRECATION,\n          code: warnings.CODES.DEPRECATION\n        });\n      }\n\n      return tableDelete(connection, this.getSchema(), this.getName(), expr);\n    },\n\n    /**\n     * Check if the table exists in the database.\n     * @function\n     * @name module:Table#existsInDatabase\n     * @returns {Promise.<boolean>}\n     */\n    existsInDatabase() {\n      const args = [{\n        schema: this.getSchema().getName(),\n        pattern: this.getName()\n      }]; // table name must be stringified since the plugin is converting it to BINARY somehow\n\n      return sqlExecute(connection, 'list_objects', args, sqlExecute.Namespace.X_PLUGIN).execute().then(res => {\n        return res.fetchAll().some(record => record[1] === 'TABLE');\n      });\n    },\n\n    /**\n     * Retrieve the table name.\n     * @function\n     * @name module:Table#getName\n     * @returns {string}\n     */\n    getName() {\n      return state.name;\n    },\n\n    /**\n     * Retrieve the schema associated to the table.\n     * @function\n     * @name module:Table#getSchema\n     * @returns {module:Schema}\n     */\n    getSchema() {\n      return state.schema;\n    },\n\n    /**\n     * Retrieve the table metadata.\n     * @function\n     * @name module:Table#inspect\n     * @returns {Object} An object containing the relevant metadata.\n     */\n    inspect() {\n      return {\n        schema: this.getSchema() ? this.getSchema().getName() : this.getSchema(),\n        table: this.getName()\n      };\n    },\n\n    /**\n     * Create operation to insert rows in the table.\n     * @function\n     * @name module:Table#insert\n     * @param {...string|string[]|Object} fields - column names or column-value object\n     * @throws {Error} When the input type is invalid.\n     * @example\n     * // arguments as column names\n     * table.insert('foo', 'bar')\n     *\n     * // array of column names\n     * table.insert(['foo', 'bar'])\n     *\n     * // object with column name and value\n     * table.insert({ foo: 'baz', bar: 'qux' })\n     * @returns {module:TableInsert} The operation instance.\n     */\n    insert() {\n      if (!Array.isArray(arguments[0]) && typeof arguments[0] !== 'string') {\n        log.warning('insert', warnings.MESSAGES.WARN_DEPRECATED_TABLE_INSERT_OBJECT_ARGUMENT, {\n          type: warnings.TYPES.DEPRECATION,\n          code: warnings.CODES.DEPRECATION\n        });\n        const fields = arguments[0];\n\n        if (typeof fields !== 'object') {\n          throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_TABLE_INSERT_ARGUMENT);\n        }\n\n        const columns = Object.keys(fields);\n        const values = columns.map(column => fields[column]);\n        return tableInsert(connection, this.getSchema(), this.getName(), columns).values(values);\n      }\n\n      const columns = parseFlexibleParamList(Array.prototype.slice.call(arguments));\n      return tableInsert(connection, this.getSchema(), this.getName(), columns);\n    },\n\n    /**\n     * Check whether the table is a view.\n     * @function\n     * @name module:Table#isView\n     * @returns {Promise.<boolean>}\n     */\n    isView() {\n      const query = 'SELECT COUNT(*) cnt FROM information_schema.VIEWS WHERE TABLE_CATALOG = ? AND TABLE_SCHEMA = ? AND TABLE_NAME = ? HAVING COUNT(*) = 1';\n      const args = ['def', this.getSchema().getName(), this.getName()];\n      let status = false;\n\n      const callback = found => {\n        status = !!found.length;\n      };\n\n      return sqlExecute(connection, query, args).execute(callback).then(() => status);\n    },\n\n    /**\n     * Create operation to select rows from the table.\n     * @function\n     * @name module:Table#select\n     * @param {...string|string[]} [expr] - columns to be projected\n     * @throws {Error} When an expression is invalid.\n     * @example\n     * // all columns should be projected\n     * const selection = table.select()\n     *\n     * // arguments as columns to be projected\n     * const selection = table.select('foo', 'bar')\n     *\n     * // array of columns to be projected\n     * const selection = table.select(['foo', 'bar'])\n     * @returns {module:TableSelect} The operation instance.\n     */\n    select() {\n      const fields = parseFlexibleParamList(Array.prototype.slice.call(arguments));\n      return tableSelect(connection, this.getSchema(), this.getName(), fields);\n    },\n\n    /**\n     * Create operation to update rows in the table.\n     * @function\n     * @name module:Table#update\n     * @param {string} [expr] - filtering criteria\n     * @example\n     * // update all rows in a table\n     * table.update('true').set('name', 'foo')\n     * table.update().where('true').set('name', 'foo')\n     *\n     * // update rows that match a given criteria\n     * table.update().where('`name` == \"foo\"').set('name', 'bar')\n     * @returns {module:TableUpdate} The operation instance.\n     */\n    update(expr) {\n      if (typeof expr !== 'undefined') {\n        log.warning('update', warnings.MESSAGES.WARN_DEPRECATED_TABLE_UPDATE_EXPR_ARGUMENT, {\n          type: warnings.TYPES.DEPRECATION,\n          code: warnings.CODES.DEPRECATION\n        });\n      }\n\n      return tableUpdate(connection, this.getSchema(), this.getName(), expr);\n    }\n\n  });\n}\n/**\n * Internal utility function.\n */\n// TODO(Rui): refactor somehow.\n\n\nTable.escapeIdentifier = function (ident) {\n  return '`' + escapeQuotes(ident) + '`';\n};\n\nmodule.exports = Table;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/DevAPI/Table.js"],"names":["databaseObject","require","errors","escapeQuotes","logger","parseFlexibleParamList","sqlExecute","tableDelete","tableInsert","tableSelect","tableUpdate","warnings","log","Table","connection","schema","name","state","Object","assign","count","escapeIdentifier","getSchema","getName","table","callback","row","execute","then","delete","expr","warning","MESSAGES","WARN_DEPRECATED_TABLE_DELETE_EXPR_ARGUMENT","type","TYPES","DEPRECATION","code","CODES","existsInDatabase","args","pattern","Namespace","X_PLUGIN","res","fetchAll","some","record","inspect","insert","Array","isArray","arguments","WARN_DEPRECATED_TABLE_INSERT_OBJECT_ARGUMENT","fields","Error","ER_DEVAPI_BAD_TABLE_INSERT_ARGUMENT","columns","keys","values","map","column","prototype","slice","call","isView","query","status","found","length","select","update","WARN_DEPRECATED_TABLE_UPDATE_EXPR_ARGUMENT","ident","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2015, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst databaseObject = require('./DatabaseObject');\nconst errors = require('../constants/errors');\nconst escapeQuotes = require('./Util/escapeQuotes');\nconst logger = require('../logger');\nconst parseFlexibleParamList = require('./Util/parseFlexibleParamList');\nconst sqlExecute = require('./SqlExecute');\nconst tableDelete = require('./TableDelete');\nconst tableInsert = require('./TableInsert');\nconst tableSelect = require('./TableSelect');\nconst tableUpdate = require('./TableUpdate');\nconst warnings = require('../constants/warnings');\n\n/**\n * Table factory.\n * @module Table\n * @mixes DatabaseObject\n */\n\nconst log = logger('api:table');\n\n/**\n * @private\n * @alias module:Table\n * @param {Connection} connection - database connection context\n * @param {module:Schema} schema - schema to bind\n * @param {string} name - table name\n * @returns {module:Table}\n */\nfunction Table (connection, schema, name) {\n    const state = Object.assign({}, { name, schema });\n\n    return Object.assign({}, databaseObject(connection), {\n        /**\n         * Retrieve the total number of rows in the table.\n         * @function\n         * @name module:Table#count\n         * @returns {Promise.<number>}\n         */\n        count: function () {\n            const schema = Table.escapeIdentifier(this.getSchema().getName());\n            const table = Table.escapeIdentifier(this.getName());\n\n            let count = 0;\n            const callback = row => { count = row[0]; };\n\n            return sqlExecute(connection, `SELECT COUNT(*) FROM ${schema}.${table}`)\n                .execute(callback)\n                .then(() => count);\n        },\n\n        /**\n         * Create operation to delete rows from a table.\n         * @function\n         * @name module:Table#delete\n         * @param {SearchConditionStr} [expr] - filtering criteria\n         * @example\n         * // delete all rows from a table\n         * table.delete('true')\n         *\n         * // delete rows that match a given criteria\n         * table.delete('`name` == \"foobar\"')\n         * @returns {module:TableDelete} The operation instance.\n         */\n        delete (expr) {\n            if (typeof expr !== 'undefined') {\n                log.warning('delete', warnings.MESSAGES.WARN_DEPRECATED_TABLE_DELETE_EXPR_ARGUMENT, {\n                    type: warnings.TYPES.DEPRECATION,\n                    code: warnings.CODES.DEPRECATION\n                });\n            }\n\n            return tableDelete(connection, this.getSchema(), this.getName(), expr);\n        },\n\n        /**\n         * Check if the table exists in the database.\n         * @function\n         * @name module:Table#existsInDatabase\n         * @returns {Promise.<boolean>}\n         */\n        existsInDatabase () {\n            const args = [{ schema: this.getSchema().getName(), pattern: this.getName() }];\n\n            // table name must be stringified since the plugin is converting it to BINARY somehow\n            return sqlExecute(connection, 'list_objects', args, sqlExecute.Namespace.X_PLUGIN)\n                .execute()\n                .then(res => {\n                    return res.fetchAll().some(record => record[1] === 'TABLE');\n                });\n        },\n\n        /**\n         * Retrieve the table name.\n         * @function\n         * @name module:Table#getName\n         * @returns {string}\n         */\n        getName () {\n            return state.name;\n        },\n\n        /**\n         * Retrieve the schema associated to the table.\n         * @function\n         * @name module:Table#getSchema\n         * @returns {module:Schema}\n         */\n        getSchema () {\n            return state.schema;\n        },\n\n        /**\n         * Retrieve the table metadata.\n         * @function\n         * @name module:Table#inspect\n         * @returns {Object} An object containing the relevant metadata.\n         */\n        inspect () {\n            return { schema: this.getSchema() ? this.getSchema().getName() : this.getSchema(), table: this.getName() };\n        },\n\n        /**\n         * Create operation to insert rows in the table.\n         * @function\n         * @name module:Table#insert\n         * @param {...string|string[]|Object} fields - column names or column-value object\n         * @throws {Error} When the input type is invalid.\n         * @example\n         * // arguments as column names\n         * table.insert('foo', 'bar')\n         *\n         * // array of column names\n         * table.insert(['foo', 'bar'])\n         *\n         * // object with column name and value\n         * table.insert({ foo: 'baz', bar: 'qux' })\n         * @returns {module:TableInsert} The operation instance.\n         */\n        insert () {\n            if (!Array.isArray(arguments[0]) && typeof arguments[0] !== 'string') {\n                log.warning('insert', warnings.MESSAGES.WARN_DEPRECATED_TABLE_INSERT_OBJECT_ARGUMENT, {\n                    type: warnings.TYPES.DEPRECATION,\n                    code: warnings.CODES.DEPRECATION\n                });\n\n                const fields = arguments[0];\n\n                if (typeof fields !== 'object') {\n                    throw new Error(errors.MESSAGES.ER_DEVAPI_BAD_TABLE_INSERT_ARGUMENT);\n                }\n\n                const columns = Object.keys(fields);\n                const values = columns.map(column => fields[column]);\n\n                return tableInsert(connection, this.getSchema(), this.getName(), columns).values(values);\n            }\n\n            const columns = parseFlexibleParamList(Array.prototype.slice.call(arguments));\n\n            return tableInsert(connection, this.getSchema(), this.getName(), columns);\n        },\n\n        /**\n         * Check whether the table is a view.\n         * @function\n         * @name module:Table#isView\n         * @returns {Promise.<boolean>}\n         */\n        isView () {\n            const query = 'SELECT COUNT(*) cnt FROM information_schema.VIEWS WHERE TABLE_CATALOG = ? AND TABLE_SCHEMA = ? AND TABLE_NAME = ? HAVING COUNT(*) = 1';\n            const args = ['def', this.getSchema().getName(), this.getName()];\n\n            let status = false;\n            const callback = found => { status = !!found.length; };\n\n            return sqlExecute(connection, query, args)\n                .execute(callback)\n                .then(() => status);\n        },\n\n        /**\n         * Create operation to select rows from the table.\n         * @function\n         * @name module:Table#select\n         * @param {...string|string[]} [expr] - columns to be projected\n         * @throws {Error} When an expression is invalid.\n         * @example\n         * // all columns should be projected\n         * const selection = table.select()\n         *\n         * // arguments as columns to be projected\n         * const selection = table.select('foo', 'bar')\n         *\n         * // array of columns to be projected\n         * const selection = table.select(['foo', 'bar'])\n         * @returns {module:TableSelect} The operation instance.\n         */\n        select () {\n            const fields = parseFlexibleParamList(Array.prototype.slice.call(arguments));\n\n            return tableSelect(connection, this.getSchema(), this.getName(), fields);\n        },\n\n        /**\n         * Create operation to update rows in the table.\n         * @function\n         * @name module:Table#update\n         * @param {string} [expr] - filtering criteria\n         * @example\n         * // update all rows in a table\n         * table.update('true').set('name', 'foo')\n         * table.update().where('true').set('name', 'foo')\n         *\n         * // update rows that match a given criteria\n         * table.update().where('`name` == \"foo\"').set('name', 'bar')\n         * @returns {module:TableUpdate} The operation instance.\n         */\n        update (expr) {\n            if (typeof expr !== 'undefined') {\n                log.warning('update', warnings.MESSAGES.WARN_DEPRECATED_TABLE_UPDATE_EXPR_ARGUMENT, {\n                    type: warnings.TYPES.DEPRECATION,\n                    code: warnings.CODES.DEPRECATION\n                });\n            }\n\n            return tableUpdate(connection, this.getSchema(), this.getName(), expr);\n        }\n    });\n}\n\n/**\n * Internal utility function.\n */\n// TODO(Rui): refactor somehow.\nTable.escapeIdentifier = function (ident) {\n    return '`' + escapeQuotes(ident) + '`';\n};\n\nmodule.exports = Table;\n"]},"metadata":{},"sourceType":"script"}