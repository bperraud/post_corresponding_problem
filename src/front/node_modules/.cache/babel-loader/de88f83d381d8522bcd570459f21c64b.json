{"ast":null,"code":"/*\n * Copyright (c) 2015, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n'use strict';\n\nconst collection = require('./Collection');\n\nconst errors = require('../constants/errors');\n\nconst databaseObject = require('./DatabaseObject');\n\nconst logger = require('../logger');\n\nconst sqlExecute = require('./SqlExecute');\n\nconst table = require('./Table');\n\nconst warnings = require('../constants/warnings');\n\nconst log = logger('api:schema');\n/**\n * Enum to identify schema validation levels.\n * @readonly\n * @name ValidationLevel\n * @enum {string}\n * @example\n * ValidationLevel.OFF\n * ValidationLevel.STRICT\n */\n\nconst ValidationLevel = {\n  OFF: 'off',\n  STRICT: 'strict'\n};\n/**\n * Schema factory.\n * @module Schema\n * @mixes DatabaseObject\n */\n\n/**\n * Options available for specifying a collection validation schema.\n * @typedef {object} module:Schema.SchemaValidationOptions\n * @prop {object} [schema] - [JSON Schema]{@link https://json-schema.org/} definition\n * @prop {ValidationLevel} [level] - enforcement level\n */\n\n/**\n * Options available for creating a new collection.\n * @typedef {object} module:Schema.CreateCollectionOptions\n * @prop {bool} [reuseExisting] re-use or throw error if a collection with the same name already exists\n * @prop {module:Schema.SchemaValidationOptions} [validation] schema validation options\n */\n\n/**\n * Options available for modifying an existing collection.\n * @typedef {object} module:Schema.ModifyCollectionOptions\n * @prop {module:Schema.SchemaValidationOptions} [validation] schema validation options\n */\n\n/**\n * @private\n * @alias module:Schema\n * @param {Connection} connection - database connection context\n * @param {string} name - schema name\n * @returns {module:Schema}\n */\n\nfunction Schema(connection, name) {\n  return Object.assign({}, databaseObject(connection), {\n    /**\n     * Create a new collection in the schema.\n     * @function\n     * @name module:Schema#createCollection\n     * @param {string} name - collection name\n     * @param {module:Schema.CreateCollectionOptions} [options]\n     * @returns {Promise.<module:Collection>}\n     */\n    createCollection(name, options) {\n      options = Object.assign({}, {\n        reuseExisting: false\n      }, options);\n\n      if (options.ReuseExistingObject) {\n        log.warning('createCollection', warnings.MESSAGES.WARN_DEPRECATED_CREATE_COLLECTION_REUSE_EXISTING, {\n          type: warnings.TYPES.DEPRECATION,\n          code: warnings.CODES.DEPRECATION\n        });\n      }\n\n      options.reuse_existing = options.ReuseExistingObject || options.reuseExisting; // remove API deprecated option\n\n      delete options.ReuseExistingObject; // remove unknown plugin option (should use \"reuse_existing\" instead)\n\n      delete options.reuseExisting;\n      const args = [{\n        schema: this.getName(),\n        name,\n        options\n      }]; // The options object only contains the \"reuse_existing\" property, and in that case, no options\n      // should be encoded in the message arguments to ensure compatibility with older MySQL server versions.\n\n      if (Object.keys(options).length === 1) {\n        delete args[0].options;\n      }\n\n      return sqlExecute(connection, 'create_collection', args, sqlExecute.Namespace.X_PLUGIN).execute().then(() => {\n        return this.getCollection(name);\n      }).catch(err => {\n        // Handle existing collections on older MySQL server versions.\n        if (err.info && err.info.code === errors.ER_TABLE_EXISTS_ERROR && options.reuse_existing) {\n          return this.getCollection(name);\n        }\n\n        if (err.info && err.info.code === errors.ER_X_CMD_NUM_ARGUMENTS) {\n          err.message = errors.MESSAGES.ER_DEVAPI_COLLECTION_OPTIONS_NOT_SUPPORTED;\n        }\n\n        throw err;\n      });\n    },\n\n    /**\n     * Drop a collection from the schema (without failing even if the collection does not exist).\n     * @function\n     * @name module:Schema#dropCollection\n     * @param {string} name - collection name\n     * @returns {Promise.<boolean>}\n     */\n    dropCollection(name) {\n      const args = [{\n        schema: this.getName(),\n        name\n      }];\n      return sqlExecute(connection, 'drop_collection', args, sqlExecute.Namespace.X_PLUGIN).execute().then(() => {\n        return true;\n      }).catch(err => {\n        // Don't fail if the collection does not exist.\n        if (!err.info || err.info.code !== errors.ER_BAD_TABLE_ERROR) {\n          throw err;\n        }\n\n        return true;\n      });\n    },\n\n    /**\n     * Check if this schema exists in the database.\n     * @function\n     * @name module:Schema#existsInDatabase\n     * @returns {Promise.<boolean>}\n     */\n    existsInDatabase() {\n      return sqlExecute(connection, 'SHOW DATABASES LIKE ?', [this.getName()]).execute().then(res => {\n        return res.fetchAll().length > 0;\n      });\n    },\n\n    /**\n     * Retrieve the instance of a given collection.\n     * @function\n     * @name module:Schema#getCollection\n     * @param {string} name - collection name\n     * @returns {module:Collection}\n     */\n    getCollection(name) {\n      return collection(connection, this, name);\n    },\n\n    /**\n     * Retrieve the instance of a given table or named collection.\n     * @function\n     * @name module:Schema#getCollectionAsTable\n     * @param {string} name - collection name\n     * @returns {module:Table}\n     */\n    getCollectionAsTable(name) {\n      return this.getTable(name);\n    },\n\n    /**\n     * Retrieve the list of collections that exist in the schema.\n     * @function\n     * @name module:Schema#getCollections\n     * @returns {Promise.<Array.<module:Collection>>} A promise that resolves to the array of collection instances.\n     */\n    getCollections() {\n      const args = [{\n        schema: this.getName()\n      }];\n      const collections = [];\n\n      const callback = row => {\n        if (row[1] !== 'COLLECTION') {\n          return;\n        }\n\n        collections.push(this.getCollection(row[0].toString()));\n      };\n\n      return sqlExecute(connection, 'list_objects', args, sqlExecute.Namespace.X_PLUGIN).execute(callback).then(() => {\n        return collections;\n      });\n    },\n\n    /**\n     * Retrieve the schema name.\n     * @function\n     * @name module:Schema#getName\n     * @returns {string}\n     */\n    getName() {\n      return name;\n    },\n\n    /**\n     * Retrieve the instance of a given table.\n     * @function\n     * @name module:Schema#getTable\n     * @param {string} name - table name\n     * @returns {module:Table}\n     */\n    getTable(name) {\n      return table(connection, this, name);\n    },\n\n    /**\n     * Retrieve the list of tables that exist in the schema.\n     * @function\n     * @name module:Schema#getTables\n     * @returns {Promise.<Array.<module:Table>>} A promise that resolves to the array of table instances.\n     */\n    getTables() {\n      const args = [{\n        schema: this.getName()\n      }];\n      const tables = [];\n\n      const callback = row => {\n        if (row[1] !== 'TABLE' && row[1] !== 'VIEW') {\n          return;\n        }\n\n        tables.push(this.getTable(row[0].toString()));\n      };\n\n      return sqlExecute(connection, 'list_objects', args, sqlExecute.Namespace.X_PLUGIN).execute(callback).then(() => tables);\n    },\n\n    /**\n     * Retrieve the schema metadata.\n     * @function\n     * @name module:Schema#inspect\n     * @returns {Object} An object containing the relevant metadata.\n     */\n    inspect() {\n      return {\n        name: this.getName()\n      };\n    },\n\n    /**\n     * Modify the options of an existing collection in the schema.\n     * @function\n     * @name module:Schema#modifyCollection\n     * @param {string} name - collection name\n     * @param {module:Schema.ModifyCollectionOptions} [options]\n     * @returns {Promise.<module:Collection>}\n     */\n    modifyCollection(name, options) {\n      const args = [{\n        schema: this.getName(),\n        name,\n        options\n      }];\n      const command = 'modify_collection_options';\n      return sqlExecute(connection, command, args, sqlExecute.Namespace.X_PLUGIN).execute().then(() => {\n        return this.getCollection(name);\n      }).catch(err => {\n        if (err.info && err.info.code === errors.ER_X_INVALID_ADMIN_COMMAND) {\n          err.message = errors.MESSAGES.ER_DEVAPI_COLLECTION_OPTIONS_NOT_SUPPORTED;\n        }\n\n        throw err;\n      });\n    }\n\n  });\n}\n\nSchema.ValidationLevel = ValidationLevel;\nmodule.exports = Schema;","map":{"version":3,"sources":["/home/ad/Bureau/infof308/src/node_modules/@mysql/xdevapi/lib/DevAPI/Schema.js"],"names":["collection","require","errors","databaseObject","logger","sqlExecute","table","warnings","log","ValidationLevel","OFF","STRICT","Schema","connection","name","Object","assign","createCollection","options","reuseExisting","ReuseExistingObject","warning","MESSAGES","WARN_DEPRECATED_CREATE_COLLECTION_REUSE_EXISTING","type","TYPES","DEPRECATION","code","CODES","reuse_existing","args","schema","getName","keys","length","Namespace","X_PLUGIN","execute","then","getCollection","catch","err","info","ER_TABLE_EXISTS_ERROR","ER_X_CMD_NUM_ARGUMENTS","message","ER_DEVAPI_COLLECTION_OPTIONS_NOT_SUPPORTED","dropCollection","ER_BAD_TABLE_ERROR","existsInDatabase","res","fetchAll","getCollectionAsTable","getTable","getCollections","collections","callback","row","push","toString","getTables","tables","inspect","modifyCollection","command","ER_X_INVALID_ADMIN_COMMAND","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2015, 2021, Oracle and/or its affiliates.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2.0, as\n * published by the Free Software Foundation.\n *\n * This program is also distributed with certain software (including\n * but not limited to OpenSSL) that is licensed under separate terms,\n * as designated in a particular file or component or in included license\n * documentation.  The authors of MySQL hereby grant you an\n * additional permission to link the program and your derivative works\n * with the separately licensed software that they have included with\n * MySQL.\n *\n * Without limiting anything contained in the foregoing, this file,\n * which is part of MySQL Connector/Node.js, is also subject to the\n * Universal FOSS Exception, version 1.0, a copy of which can be found at\n * http://oss.oracle.com/licenses/universal-foss-exception.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License, version 2.0, for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n'use strict';\n\nconst collection = require('./Collection');\nconst errors = require('../constants/errors');\nconst databaseObject = require('./DatabaseObject');\nconst logger = require('../logger');\nconst sqlExecute = require('./SqlExecute');\nconst table = require('./Table');\nconst warnings = require('../constants/warnings');\n\nconst log = logger('api:schema');\n\n/**\n * Enum to identify schema validation levels.\n * @readonly\n * @name ValidationLevel\n * @enum {string}\n * @example\n * ValidationLevel.OFF\n * ValidationLevel.STRICT\n */\nconst ValidationLevel = {\n    OFF: 'off',\n    STRICT: 'strict'\n};\n\n/**\n * Schema factory.\n * @module Schema\n * @mixes DatabaseObject\n */\n\n/**\n * Options available for specifying a collection validation schema.\n * @typedef {object} module:Schema.SchemaValidationOptions\n * @prop {object} [schema] - [JSON Schema]{@link https://json-schema.org/} definition\n * @prop {ValidationLevel} [level] - enforcement level\n */\n\n/**\n * Options available for creating a new collection.\n * @typedef {object} module:Schema.CreateCollectionOptions\n * @prop {bool} [reuseExisting] re-use or throw error if a collection with the same name already exists\n * @prop {module:Schema.SchemaValidationOptions} [validation] schema validation options\n */\n\n/**\n * Options available for modifying an existing collection.\n * @typedef {object} module:Schema.ModifyCollectionOptions\n * @prop {module:Schema.SchemaValidationOptions} [validation] schema validation options\n */\n\n/**\n * @private\n * @alias module:Schema\n * @param {Connection} connection - database connection context\n * @param {string} name - schema name\n * @returns {module:Schema}\n */\nfunction Schema (connection, name) {\n    return Object.assign({}, databaseObject(connection), {\n        /**\n         * Create a new collection in the schema.\n         * @function\n         * @name module:Schema#createCollection\n         * @param {string} name - collection name\n         * @param {module:Schema.CreateCollectionOptions} [options]\n         * @returns {Promise.<module:Collection>}\n         */\n        createCollection (name, options) {\n            options = Object.assign({}, { reuseExisting: false }, options);\n\n            if (options.ReuseExistingObject) {\n                log.warning('createCollection', warnings.MESSAGES.WARN_DEPRECATED_CREATE_COLLECTION_REUSE_EXISTING, {\n                    type: warnings.TYPES.DEPRECATION,\n                    code: warnings.CODES.DEPRECATION\n                });\n            }\n\n            options.reuse_existing = options.ReuseExistingObject || options.reuseExisting;\n            // remove API deprecated option\n            delete options.ReuseExistingObject;\n            // remove unknown plugin option (should use \"reuse_existing\" instead)\n            delete options.reuseExisting;\n\n            const args = [{ schema: this.getName(), name, options }];\n\n            // The options object only contains the \"reuse_existing\" property, and in that case, no options\n            // should be encoded in the message arguments to ensure compatibility with older MySQL server versions.\n            if (Object.keys(options).length === 1) {\n                delete args[0].options;\n            }\n\n            return sqlExecute(connection, 'create_collection', args, sqlExecute.Namespace.X_PLUGIN)\n                .execute()\n                .then(() => {\n                    return this.getCollection(name);\n                })\n                .catch(err => {\n                    // Handle existing collections on older MySQL server versions.\n                    if (err.info && err.info.code === errors.ER_TABLE_EXISTS_ERROR && options.reuse_existing) {\n                        return this.getCollection(name);\n                    }\n\n                    if (err.info && err.info.code === errors.ER_X_CMD_NUM_ARGUMENTS) {\n                        err.message = errors.MESSAGES.ER_DEVAPI_COLLECTION_OPTIONS_NOT_SUPPORTED;\n                    }\n\n                    throw err;\n                });\n        },\n\n        /**\n         * Drop a collection from the schema (without failing even if the collection does not exist).\n         * @function\n         * @name module:Schema#dropCollection\n         * @param {string} name - collection name\n         * @returns {Promise.<boolean>}\n         */\n        dropCollection (name) {\n            const args = [{ schema: this.getName(), name }];\n\n            return sqlExecute(connection, 'drop_collection', args, sqlExecute.Namespace.X_PLUGIN)\n                .execute()\n                .then(() => {\n                    return true;\n                })\n                .catch(err => {\n                    // Don't fail if the collection does not exist.\n                    if (!err.info || err.info.code !== errors.ER_BAD_TABLE_ERROR) {\n                        throw err;\n                    }\n\n                    return true;\n                });\n        },\n\n        /**\n         * Check if this schema exists in the database.\n         * @function\n         * @name module:Schema#existsInDatabase\n         * @returns {Promise.<boolean>}\n         */\n        existsInDatabase () {\n            return sqlExecute(connection, 'SHOW DATABASES LIKE ?', [this.getName()])\n                .execute()\n                .then(res => {\n                    return res.fetchAll().length > 0;\n                });\n        },\n\n        /**\n         * Retrieve the instance of a given collection.\n         * @function\n         * @name module:Schema#getCollection\n         * @param {string} name - collection name\n         * @returns {module:Collection}\n         */\n        getCollection (name) {\n            return collection(connection, this, name);\n        },\n\n        /**\n         * Retrieve the instance of a given table or named collection.\n         * @function\n         * @name module:Schema#getCollectionAsTable\n         * @param {string} name - collection name\n         * @returns {module:Table}\n         */\n        getCollectionAsTable (name) {\n            return this.getTable(name);\n        },\n\n        /**\n         * Retrieve the list of collections that exist in the schema.\n         * @function\n         * @name module:Schema#getCollections\n         * @returns {Promise.<Array.<module:Collection>>} A promise that resolves to the array of collection instances.\n         */\n        getCollections () {\n            const args = [{ schema: this.getName() }];\n            const collections = [];\n\n            const callback = row => {\n                if (row[1] !== 'COLLECTION') {\n                    return;\n                }\n\n                collections.push(this.getCollection(row[0].toString()));\n            };\n\n            return sqlExecute(connection, 'list_objects', args, sqlExecute.Namespace.X_PLUGIN)\n                .execute(callback)\n                .then(() => {\n                    return collections;\n                });\n        },\n\n        /**\n         * Retrieve the schema name.\n         * @function\n         * @name module:Schema#getName\n         * @returns {string}\n         */\n        getName () {\n            return name;\n        },\n\n        /**\n         * Retrieve the instance of a given table.\n         * @function\n         * @name module:Schema#getTable\n         * @param {string} name - table name\n         * @returns {module:Table}\n         */\n        getTable (name) {\n            return table(connection, this, name);\n        },\n\n        /**\n         * Retrieve the list of tables that exist in the schema.\n         * @function\n         * @name module:Schema#getTables\n         * @returns {Promise.<Array.<module:Table>>} A promise that resolves to the array of table instances.\n         */\n        getTables () {\n            const args = [{ schema: this.getName() }];\n            const tables = [];\n\n            const callback = row => {\n                if (row[1] !== 'TABLE' && row[1] !== 'VIEW') {\n                    return;\n                }\n\n                tables.push(this.getTable(row[0].toString()));\n            };\n\n            return sqlExecute(connection, 'list_objects', args, sqlExecute.Namespace.X_PLUGIN)\n                .execute(callback)\n                .then(() => tables);\n        },\n\n        /**\n         * Retrieve the schema metadata.\n         * @function\n         * @name module:Schema#inspect\n         * @returns {Object} An object containing the relevant metadata.\n         */\n        inspect () {\n            return { name: this.getName() };\n        },\n\n        /**\n         * Modify the options of an existing collection in the schema.\n         * @function\n         * @name module:Schema#modifyCollection\n         * @param {string} name - collection name\n         * @param {module:Schema.ModifyCollectionOptions} [options]\n         * @returns {Promise.<module:Collection>}\n         */\n        modifyCollection (name, options) {\n            const args = [{ schema: this.getName(), name, options }];\n            const command = 'modify_collection_options';\n\n            return sqlExecute(connection, command, args, sqlExecute.Namespace.X_PLUGIN)\n                .execute()\n                .then(() => {\n                    return this.getCollection(name);\n                })\n                .catch(err => {\n                    if (err.info && err.info.code === errors.ER_X_INVALID_ADMIN_COMMAND) {\n                        err.message = errors.MESSAGES.ER_DEVAPI_COLLECTION_OPTIONS_NOT_SUPPORTED;\n                    }\n\n                    throw err;\n                });\n        }\n    });\n}\n\nSchema.ValidationLevel = ValidationLevel;\n\nmodule.exports = Schema;\n"]},"metadata":{},"sourceType":"script"}